// /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
// /*
// 
// function Cipher(input, w) {    // main Cipher function [_5.1]
  0:                 meta   12  255          // [to be rewritten]
// 
//   var Nb = 4;               // block size (in words): no of columns in state (fixed at 4 for AES)
// 
//   var Nr = w.length/Nb - 1; // no of rounds: 10/12/14 for 128/192/256-bit keys
// 
//   var state = [[],[],[],[]];  // initialise 4xNb byte-array 'state' with input [_3.4]
// 
//   for (var i=0; i<4*Nb; i++) state[i%4][Math.floor(i/4)] = input[i];
//   state = AddRoundKey(state, w, 0, Nb);
//   for (var round=1; round<Nr; round++) {
//     state = SubBytes(state, Nb);
//     state = ShiftRows(state, Nb);
//     state = MixColumns(state, Nb);
//     state = AddRoundKey(state, w, round, Nb);
//   }
//   state = SubBytes(state, Nb);
//   state = ShiftRows(state, Nb);
//   state = AddRoundKey(state, w, Nr, Nb);
//   var output = new Array(4*Nb);  // convert state to 1-d array before returning [_3.4]
// 
//   for (var i=0; i<4*Nb; i++) output[i] = state[i%4][Math.floor(i/4)];
//   return output;
// }
// function SubBytes(s, Nb) {    // apply SBox to state S [_5.1.1]
// 
//   for (var r=0; r<4; r++) {
//     for (var c=0; c<Nb; c++) s[r][c] = Sbox[s[r][c]];
//   }
//   return s;
// }
// function ShiftRows(s, Nb) {    // shift row r of state S left by r bytes [_5.1.2]
// 
//   var t = new Array(4);
//   for (var r=1; r<4; r++) {
//     for (var c=0; c<4; c++) t[c] = s[r][(c+r)%Nb];  // shift into temp copy
// 
//     for (var c=0; c<4; c++) s[r][c] = t[c];         // and copy back
// 
//   }          // note that this will work for Nb=4,5,6, but not 7,8 (always 4 for AES):
// 
//   return s;  // see fp.gladman.plus.com/cryptography_technology/rijndael/aes.spec.311.pdf 
// 
// }
// function MixColumns(s, Nb) {   // combine bytes of each col of state S [_5.1.3]
// 
//   for (var c=0; c<4; c++) {
//     var a = new Array(4);  // 'a' is a copy of the current column from 's'
// 
//     var b = new Array(4);  // 'b' is a_{02} in GF(2^8)
// 
//     for (var i=0; i<4; i++) {
//       a[i] = s[i][c];
//       b[i] = s[i][c]&0x80 ? s[i][c]<<1 ^ 0x011b : s[i][c]<<1;
//     }
//     // a[n] ^ b[n] is a_{03} in GF(2^8)
// 
//     s[0][c] = b[0] ^ a[1] ^ b[1] ^ a[2] ^ a[3]; // 2*a0 + 3*a1 + a2 + a3
// 
//     s[1][c] = a[0] ^ b[1] ^ a[2] ^ b[2] ^ a[3]; // a0 * 2*a1 + 3*a2 + a3
// 
//     s[2][c] = a[0] ^ a[1] ^ b[2] ^ a[3] ^ b[3]; // a0 + a1 + 2*a2 + 3*a3
// 
//     s[3][c] = a[0] ^ b[0] ^ a[1] ^ a[2] ^ b[3]; // 3*a0 + a1 + a2 + 2*a3
// 
//   }
//   return s;
// }
// function AddRoundKey(state, w, rnd, Nb) {  // xor Round Key into state S [_5.1.4]
// 
//   for (var r=0; r<4; r++) {
//     for (var c=0; c<Nb; c++) state[r][c] ^= w[rnd*4+c][r];
//   }
//   return state;
// }
// function KeyExpansion(key) {  // generate Key Schedule (byte-array Nr+1 x Nb) from Key [_5.2]
// 
//   var Nb = 4;            // block size (in words): no of columns in state (fixed at 4 for AES)
// 
//   var Nk = key.length/4  // key length (in words): 4/6/8 for 128/192/256-bit keys
// 
//   var Nr = Nk + 6;       // no of rounds: 10/12/14 for 128/192/256-bit keys
// 
//   var w = new Array(Nb*(Nr+1));
//   var temp = new Array(4);
//   for (var i=0; i<Nk; i++) {
//     var r = [key[4*i], key[4*i+1], key[4*i+2], key[4*i+3]];
//     w[i] = r;
//   }
//   for (var i=Nk; i<(Nb*(Nr+1)); i++) {
//     w[i] = new Array(4);
//     for (var t=0; t<4; t++) temp[t] = w[i-1][t];
//     if (i % Nk == 0) {
//       temp = SubWord(RotWord(temp));
//       for (var t=0; t<4; t++) temp[t] ^= Rcon[i/Nk][t];
//     } else if (Nk > 6 && i%Nk == 4) {
//       temp = SubWord(temp);
//     }
//     for (var t=0; t<4; t++) w[i][t] = w[i-Nk][t] ^ temp[t];
//   }
//   return w;
// }
// function SubWord(w) {    // apply SBox to 4-byte word w
// 
//   for (var i=0; i<4; i++) w[i] = Sbox[w[i]];
//   return w;
// }
// function RotWord(w) {    // rotate 4-byte word w left by one byte
// 
//   w[4] = w[0];
//   for (var i=0; i<4; i++) w[i] = w[i+1];
//   return w;
// }
// // Sbox is pre-computed multiplicative inverse in GF(2^8) used in SubBytes and KeyExpansion [_5.1.1]
// 
// var Sbox =  [0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,
//              0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,
//              0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,
//              0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,
//              0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,
//              0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,
//              0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,
//              0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,
//              0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,
//              0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,
//              0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,
//              0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,
//              0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,
//              0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,
//              0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,
//              0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16];
// // Rcon is Round Constant used for the Key Expansion [1st col is 2^(r-1) in GF(2^8)] [_5.2]
// 
// var Rcon = [ [0x00, 0x00, 0x00, 0x00],
//              [0x01, 0x00, 0x00, 0x00],
//              [0x02, 0x00, 0x00, 0x00],
//              [0x04, 0x00, 0x00, 0x00],
//              [0x08, 0x00, 0x00, 0x00],
//              [0x10, 0x00, 0x00, 0x00],
//              [0x20, 0x00, 0x00, 0x00],
//              [0x40, 0x00, 0x00, 0x00],
//              [0x80, 0x00, 0x00, 0x00],
//              [0x1b, 0x00, 0x00, 0x00],
//              [0x36, 0x00, 0x00, 0x00] ]; 
// /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
// /* 
// 
// function AESEncryptCtr(plaintext, password, nBits) {
//   if (!(nBits==128 || nBits==192 || nBits==256)) return '';  // standard allows 128/192/256 bit keys
// 
//   // for this example script, generate the key by applying Cipher to 1st 16/24/32 chars of password; 
// 
//   // for real-world applications, a more secure approach would be to hash the password e.g. with SHA-1
// 
//   var nBytes = nBits/8;  // no bytes in key
// 
//   var pwBytes = new Array(nBytes);
//   for (var i=0; i<nBytes; i++) pwBytes[i] = password.charCodeAt(i) & 0xff;
//   var key = Cipher(pwBytes, KeyExpansion(pwBytes));
//   key = key.concat(key.slice(0, nBytes-16));  // key is now 16/24/32 bytes long
// 
//   // initialise counter block (NIST SP800-38A _B.2): millisecond time-stamp for nonce in 1st 8 bytes,
// 
//   // block counter in 2nd 8 bytes
// 
//   var blockSize = 16;  // block size fixed at 16 bytes / 128 bits (Nb=4) for AES
// 
//   var counterBlock = new Array(blockSize);  // block size fixed at 16 bytes / 128 bits (Nb=4) for AES
// 
//   var nonce = (new Date()).getTime();  // milliseconds since 1-Jan-1970
// 
//   // encode nonce in two stages to cater for JavaScript 32-bit limit on bitwise ops
// 
//   for (var i=0; i<4; i++) counterBlock[i] = (nonce >>> i*8) & 0xff;
//   for (var i=0; i<4; i++) counterBlock[i+4] = (nonce/0x100000000 >>> i*8) & 0xff; 
//   // generate key schedule - an expansion of the key into distinct Key Rounds for each round
// 
//   var keySchedule = KeyExpansion(key);
//   var blockCount = Math.ceil(plaintext.length/blockSize);
//   var ciphertext = new Array(blockCount);  // ciphertext as array of strings
// 
//   
//   for (var b=0; b<blockCount; b++) {
//     // set counter (block #) in last 8 bytes of counter block (leaving nonce in 1st 8 bytes)
// 
//     // again done in two stages for 32-bit ops
// 
//     for (var c=0; c<4; c++) counterBlock[15-c] = (b >>> c*8) & 0xff;
//     for (var c=0; c<4; c++) counterBlock[15-c-4] = (b/0x100000000 >>> c*8)
//     var cipherCntr = Cipher(counterBlock, keySchedule);  // -- encrypt counter block --
// 
//     
//     // calculate length of final block:
// 
//     var blockLength = b<blockCount-1 ? blockSize : (plaintext.length-1)%blockSize+1;
//     var ct = '';
//     for (var i=0; i<blockLength; i++) {  // -- xor plaintext with ciphered counter byte-by-byte --
// 
//       var plaintextByte = plaintext.charCodeAt(b*blockSize+i);
//       var cipherByte = plaintextByte ^ cipherCntr[i];
//       ct += String.fromCharCode(cipherByte);
//     }
//     // ct is now ciphertext for this block
// 
//     ciphertext[b] = escCtrlChars(ct);  // escape troublesome characters in ciphertext
// 
//   }
//   // convert the nonce to a string to go on the front of the ciphertext
// 
//   var ctrTxt = '';
//   for (var i=0; i<8; i++) ctrTxt += String.fromCharCode(counterBlock[i]);
//   ctrTxt = escCtrlChars(ctrTxt);
//   // use '-' to separate blocks, use Array.join to concatenate arrays of strings for efficiency
// 
//   return ctrTxt + '-' + ciphertext.join('-');
// }
// /* 
// 
// function AESDecryptCtr(ciphertext, password, nBits) {
//   if (!(nBits==128 || nBits==192 || nBits==256)) return '';  // standard allows 128/192/256 bit keys
// 
//   var nBytes = nBits/8;  // no bytes in key
// 
//   var pwBytes = new Array(nBytes);
//   for (var i=0; i<nBytes; i++) pwBytes[i] = password.charCodeAt(i) & 0xff;
//   var pwKeySchedule = KeyExpansion(pwBytes);
//   var key = Cipher(pwBytes, pwKeySchedule);
//   key = key.concat(key.slice(0, nBytes-16));  // key is now 16/24/32 bytes long
// 
//   var keySchedule = KeyExpansion(key);
//   ciphertext = ciphertext.split('-');  // split ciphertext into array of block-length strings 
// 
//   // recover nonce from 1st element of ciphertext
// 
//   var blockSize = 16;  // block size fixed at 16 bytes / 128 bits (Nb=4) for AES
// 
//   var counterBlock = new Array(blockSize);
//   var ctrTxt = unescCtrlChars(ciphertext[0]);
//   for (var i=0; i<8; i++) counterBlock[i] = ctrTxt.charCodeAt(i);
//   var plaintext = new Array(ciphertext.length-1);
//   for (var b=1; b<ciphertext.length; b++) {
//     // set counter (block #) in last 8 bytes of counter block (leaving nonce in 1st 8 bytes)
// 
//     for (var c=0; c<4; c++) counterBlock[15-c] = ((b-1) >>> c*8) & 0xff;
//     for (var c=0; c<4; c++) counterBlock[15-c-4] = ((b/0x100000000-1) >>> c*8) & 0xff;
//     var cipherCntr = Cipher(counterBlock, keySchedule);  // encrypt counter block
// 
//     ciphertext[b] = unescCtrlChars(ciphertext[b]);
//     var pt = '';
//     for (var i=0; i<ciphertext[b].length; i++) {
//       // -- xor plaintext with ciphered counter byte-by-byte --
// 
//       var ciphertextByte = ciphertext[b].charCodeAt(i);
//       var plaintextByte = ciphertextByte ^ cipherCntr[i];
//       pt += String.fromCharCode(plaintextByte);
//     }
//     // pt is now plaintext for this block
// 
//     plaintext[b-1] = pt;  // b-1 'cos no initial nonce block in plaintext
// 
//   }
//   return plaintext.join('');
// }
// /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
// function escCtrlChars(str) {  // escape control chars which might cause problems handling ciphertext
// 
//   return str.replace(/[\0\t\n\v\f\r\xa0'"!-]/g, function(c) { return '!' + c.charCodeAt(0) + '!'; });
// }  // \xa0 to cater for bug in Firefox; include '-' to leave it free for use as a block marker
// 
// function unescCtrlChars(str) {  // unescape potentially problematic control characters
// 
//   return str.replace(/!\d\d?\d?!/g, function(c) { return String.fromCharCode(c.slice(1,-1)); });
// }
// /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
// /*
// 
// var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
// function encodeBase64(str) {  // http://tools.ietf.org/html/rfc4648
// 
//    var o1, o2, o3, h1, h2, h3, h4, bits, i=0, enc='';
//    
//    str = encodeUTF8(str);  // encode multi-byte chars into UTF-8 for byte-array
// 
//    do {  // pack three octets into four hexets
// 
//       o1 = str.charCodeAt(i++);
//       o2 = str.charCodeAt(i++);
//       o3 = str.charCodeAt(i++);
//       
//       bits = o1<<16 | o2<<8 | o3;
//       
//       h1 = bits>>18 & 0x3f;
//       h2 = bits>>12 & 0x3f;
//       h3 = bits>>6 & 0x3f;
//       h4 = bits & 0x3f;
//       
//       // end of string? index to '=' in b64
// 
//       if (isNaN(o3)) h4 = 64;
//       if (isNaN(o2)) h3 = 64;
//       
//       // use hexets to index into b64, and append result to encoded string
// 
//       enc += b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
//    } while (i < str.length);
//    
//    return enc;
// }
// function decodeBase64(str) {
//    var o1, o2, o3, h1, h2, h3, h4, bits, i=0, enc='';
//    do {  // unpack four hexets into three octets using index points in b64
// 
//       h1 = b64.indexOf(str.charAt(i++));
//       h2 = b64.indexOf(str.charAt(i++));
//       h3 = b64.indexOf(str.charAt(i++));
//       h4 = b64.indexOf(str.charAt(i++));
//       
//       bits = h1<<18 | h2<<12 | h3<<6 | h4;
//       
//       o1 = bits>>16 & 0xff;
//       o2 = bits>>8 & 0xff;
//       o3 = bits & 0xff;
//       
//       if (h3 == 64)      enc += String.fromCharCode(o1);
//       else if (h4 == 64) enc += String.fromCharCode(o1, o2);
//       else               enc += String.fromCharCode(o1, o2, o3);
//    } while (i < str.length);
//    return decodeUTF8(enc);  // decode UTF-8 byte-array back to Unicode
// 
// }
// function encodeUTF8(str) {  // encode multi-byte string into utf-8 multiple single-byte characters 
// 
//   str = str.replace(
//       /[\u0080-\u07ff]/g,  // U+0080 - U+07FF = 2-byte chars
// 
//       function(c) { 
//         var cc = c.charCodeAt(0);
//         return String.fromCharCode(0xc0 | cc>>6, 0x80 | cc&0x3f); }
//     );
//   str = str.replace(
//       /[\u0800-\uffff]/g,  // U+0800 - U+FFFF = 3-byte chars
// 
//       function(c) { 
//         var cc = c.charCodeAt(0); 
//         return String.fromCharCode(0xe0 | cc>>12, 0x80 | cc>>6&0x3F, 0x80 | cc&0x3f); }
//     );
//   return str;
// }
// function decodeUTF8(str) {  // decode utf-8 encoded string back into multi-byte characters
// 
//   str = str.replace(
//       /[\u00c0-\u00df][\u0080-\u00bf]/g,                 // 2-byte chars
// 
//       function(c) { 
//         var cc = (c.charCodeAt(0)&0x1f)<<6 | c.charCodeAt(1)&0x3f;
//         return String.fromCharCode(cc); }
//     );
//   str = str.replace(
//       /[\u00e0-\u00ef][\u0080-\u00bf][\u0080-\u00bf]/g,  // 3-byte chars
// 
//       function(c) { 
//         var cc = (c.charCodeAt(0)&0x0f)<<12 | (c.charCodeAt(1)&0x3f<<6) | c.charCodeAt(2)&0x3f; 
//         return String.fromCharCode(cc); }
//     );
//   return str;
// }
// function byteArrayToHexStr(b) {  // convert byte array to hex string for displaying test vectors
// 
//   var s = '';
//   for (var i=0; i<b.length; i++) s += b[i].toString(16) + ' ';
//   return s;
// }
// /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
// var plainText = "ROMEO: But, soft! what light through yonder window breaks?\n\
// var password = "O Romeo, Romeo! wherefore art thou Romeo?";
// var cipherText = AESEncryptCtr(plainText, password, 256);
// var decryptedText = AESDecryptCtr(cipherText, password, 256);
// if (decryptedText != plainText)
//     throw "ERROR: bad result: expected " + plainText + " but got " + decryptedText;
// 
  0:                 meta   12    6          // [no 'arguments'] [no 'eval']  // REWRITE
  1:         reg_var_decl  128               // var tmp128 .. tmp255;
// 
//   var Nb = 4;               // block size (in words): no of columns in state (fixed at 4 for AES)
// 
//   var Nr = w.length/Nb - 1; // no of rounds: 10/12/14 for 128/192/256-bit keys
// 
//   var state = [[],[],[],[]];  // initialise 4xNb byte-array 'state' with input [_3.4]
// 
//   for (var i=0; i<4*Nb; i++) state[i%4][Math.floor(i/4)] = input[i];
//   state = AddRoundKey(state, w, 0, Nb);
//   for (var round=1; round<Nr; round++) {
//     state = SubBytes(state, Nb);
//     state = ShiftRows(state, Nb);
//     state = MixColumns(state, Nb);
//     state = AddRoundKey(state, w, round, Nb);
//   }
//   state = SubBytes(state, Nb);
//   state = ShiftRows(state, Nb);
//   state = AddRoundKey(state, w, Nr, Nb);
//   var output = new Array(4*Nb);  // convert state to 1-d array before returning [_3.4]
// 
//   for (var i=0; i<4*Nb; i++) output[i] = state[i%4][Math.floor(i/4)];
//   return output;
// }
// function SubBytes(s, Nb) {    // apply SBox to state S [_5.1.1]
// 
//   for (var r=0; r<4; r++) {
//     for (var c=0; c<Nb; c++) s[r][c] = Sbox[s[r][c]];
//   }
//   return s;
// }
// function ShiftRows(s, Nb) {    // shift row r of state S left by r bytes [_5.1.2]
// 
//   var t = new Array(4);
//   for (var r=1; r<4; r++) {
//     for (var c=0; c<4; c++) t[c] = s[r][(c+r)%Nb];  // shift into temp copy
// 
//     for (var c=0; c<4; c++) s[r][c] = t[c];         // and copy back
// 
//   }          // note that this will work for Nb=4,5,6, but not 7,8 (always 4 for AES):
// 
//   return s;  // see fp.gladman.plus.com/cryptography_technology/rijndael/aes.spec.311.pdf 
// 
// }
// function MixColumns(s, Nb) {   // combine bytes of each col of state S [_5.1.3]
// 
//   for (var c=0; c<4; c++) {
//     var a = new Array(4);  // 'a' is a copy of the current column from 's'
// 
//     var b = new Array(4);  // 'b' is a_{02} in GF(2^8)
// 
//     for (var i=0; i<4; i++) {
//       a[i] = s[i][c];
//       b[i] = s[i][c]&0x80 ? s[i][c]<<1 ^ 0x011b : s[i][c]<<1;
//     }
//     // a[n] ^ b[n] is a_{03} in GF(2^8)
// 
//     s[0][c] = b[0] ^ a[1] ^ b[1] ^ a[2] ^ a[3]; // 2*a0 + 3*a1 + a2 + a3
// 
//     s[1][c] = a[0] ^ b[1] ^ a[2] ^ b[2] ^ a[3]; // a0 * 2*a1 + 3*a2 + a3
// 
//     s[2][c] = a[0] ^ a[1] ^ b[2] ^ a[3] ^ b[3]; // a0 + a1 + 2*a2 + 3*a3
// 
//     s[3][c] = a[0] ^ b[0] ^ a[1] ^ a[2] ^ b[3]; // 3*a0 + a1 + a2 + 2*a3
// 
//   }
//   return s;
// }
// function AddRoundKey(state, w, rnd, Nb) {  // xor Round Key into state S [_5.1.4]
// 
//   for (var r=0; r<4; r++) {
//     for (var c=0; c<Nb; c++) state[r][c] ^= w[rnd*4+c][r];
//   }
//   return state;
// }
// function KeyExpansion(key) {  // generate Key Schedule (byte-array Nr+1 x Nb) from Key [_5.2]
// 
//   var Nb = 4;            // block size (in words): no of columns in state (fixed at 4 for AES)
// 
//   var Nk = key.length/4  // key length (in words): 4/6/8 for 128/192/256-bit keys
// 
//   var Nr = Nk + 6;       // no of rounds: 10/12/14 for 128/192/256-bit keys
// 
//   var w = new Array(Nb*(Nr+1));
//   var temp = new Array(4);
//   for (var i=0; i<Nk; i++) {
//     var r = [key[4*i], key[4*i+1], key[4*i+2], key[4*i+3]];
//     w[i] = r;
//   }
//   for (var i=Nk; i<(Nb*(Nr+1)); i++) {
//     w[i] = new Array(4);
//     for (var t=0; t<4; t++) temp[t] = w[i-1][t];
//     if (i % Nk == 0) {
//       temp = SubWord(RotWord(temp));
//       for (var t=0; t<4; t++) temp[t] ^= Rcon[i/Nk][t];
//     } else if (Nk > 6 && i%Nk == 4) {
//       temp = SubWord(temp);
//     }
//     for (var t=0; t<4; t++) w[i][t] = w[i-Nk][t] ^ temp[t];
//   }
//   return w;
// }
// function SubWord(w) {    // apply SBox to 4-byte word w
// 
//   for (var i=0; i<4; i++) w[i] = Sbox[w[i]];
//   return w;
// }
// function RotWord(w) {    // rotate 4-byte word w left by one byte
// 
//   w[4] = w[0];
//   for (var i=0; i<4; i++) w[i] = w[i+1];
//   return w;
// }
// // Sbox is pre-computed multiplicative inverse in GF(2^8) used in SubBytes and KeyExpansion [_5.1.1]
// 
// var Sbox =  [0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,
  2:             var_decl                    // var Sbox;
//              0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,
//              0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,
//              0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,
//              0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,
//              0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,
//              0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,
//              0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,
//              0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,
//              0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,
//              0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,
//              0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,
//              0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,
//              0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,
//              0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,
//              0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16];
// // Rcon is Round Constant used for the Key Expansion [1st col is 2^(r-1) in GF(2^8)] [_5.2]
// 
// var Rcon = [ [0x00, 0x00, 0x00, 0x00],
  3:             var_decl                    // var Rcon;
//              [0x01, 0x00, 0x00, 0x00],
//              [0x02, 0x00, 0x00, 0x00],
//              [0x04, 0x00, 0x00, 0x00],
//              [0x08, 0x00, 0x00, 0x00],
//              [0x10, 0x00, 0x00, 0x00],
//              [0x20, 0x00, 0x00, 0x00],
//              [0x40, 0x00, 0x00, 0x00],
//              [0x80, 0x00, 0x00, 0x00],
//              [0x1b, 0x00, 0x00, 0x00],
//              [0x36, 0x00, 0x00, 0x00] ]; 
// /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
// /* 
// 
// function AESEncryptCtr(plaintext, password, nBits) {
//   if (!(nBits==128 || nBits==192 || nBits==256)) return '';  // standard allows 128/192/256 bit keys
// 
//   // for this example script, generate the key by applying Cipher to 1st 16/24/32 chars of password; 
// 
//   // for real-world applications, a more secure approach would be to hash the password e.g. with SHA-1
// 
//   var nBytes = nBits/8;  // no bytes in key
// 
//   var pwBytes = new Array(nBytes);
//   for (var i=0; i<nBytes; i++) pwBytes[i] = password.charCodeAt(i) & 0xff;
//   var key = Cipher(pwBytes, KeyExpansion(pwBytes));
//   key = key.concat(key.slice(0, nBytes-16));  // key is now 16/24/32 bytes long
// 
//   // initialise counter block (NIST SP800-38A _B.2): millisecond time-stamp for nonce in 1st 8 bytes,
// 
//   // block counter in 2nd 8 bytes
// 
//   var blockSize = 16;  // block size fixed at 16 bytes / 128 bits (Nb=4) for AES
// 
//   var counterBlock = new Array(blockSize);  // block size fixed at 16 bytes / 128 bits (Nb=4) for AES
// 
//   var nonce = (new Date()).getTime();  // milliseconds since 1-Jan-1970
// 
//   // encode nonce in two stages to cater for JavaScript 32-bit limit on bitwise ops
// 
//   for (var i=0; i<4; i++) counterBlock[i] = (nonce >>> i*8) & 0xff;
//   for (var i=0; i<4; i++) counterBlock[i+4] = (nonce/0x100000000 >>> i*8) & 0xff; 
//   // generate key schedule - an expansion of the key into distinct Key Rounds for each round
// 
//   var keySchedule = KeyExpansion(key);
//   var blockCount = Math.ceil(plaintext.length/blockSize);
//   var ciphertext = new Array(blockCount);  // ciphertext as array of strings
// 
//   
//   for (var b=0; b<blockCount; b++) {
//     // set counter (block #) in last 8 bytes of counter block (leaving nonce in 1st 8 bytes)
// 
//     // again done in two stages for 32-bit ops
// 
//     for (var c=0; c<4; c++) counterBlock[15-c] = (b >>> c*8) & 0xff;
//     for (var c=0; c<4; c++) counterBlock[15-c-4] = (b/0x100000000 >>> c*8)
//     var cipherCntr = Cipher(counterBlock, keySchedule);  // -- encrypt counter block --
// 
//     
//     // calculate length of final block:
// 
//     var blockLength = b<blockCount-1 ? blockSize : (plaintext.length-1)%blockSize+1;
//     var ct = '';
//     for (var i=0; i<blockLength; i++) {  // -- xor plaintext with ciphered counter byte-by-byte --
// 
//       var plaintextByte = plaintext.charCodeAt(b*blockSize+i);
//       var cipherByte = plaintextByte ^ cipherCntr[i];
//       ct += String.fromCharCode(cipherByte);
//     }
//     // ct is now ciphertext for this block
// 
//     ciphertext[b] = escCtrlChars(ct);  // escape troublesome characters in ciphertext
// 
//   }
//   // convert the nonce to a string to go on the front of the ciphertext
// 
//   var ctrTxt = '';
//   for (var i=0; i<8; i++) ctrTxt += String.fromCharCode(counterBlock[i]);
//   ctrTxt = escCtrlChars(ctrTxt);
//   // use '-' to separate blocks, use Array.join to concatenate arrays of strings for efficiency
// 
//   return ctrTxt + '-' + ciphertext.join('-');
// }
// /* 
// 
// function AESDecryptCtr(ciphertext, password, nBits) {
//   if (!(nBits==128 || nBits==192 || nBits==256)) return '';  // standard allows 128/192/256 bit keys
// 
//   var nBytes = nBits/8;  // no bytes in key
// 
//   var pwBytes = new Array(nBytes);
//   for (var i=0; i<nBytes; i++) pwBytes[i] = password.charCodeAt(i) & 0xff;
//   var pwKeySchedule = KeyExpansion(pwBytes);
//   var key = Cipher(pwBytes, pwKeySchedule);
//   key = key.concat(key.slice(0, nBytes-16));  // key is now 16/24/32 bytes long
// 
//   var keySchedule = KeyExpansion(key);
//   ciphertext = ciphertext.split('-');  // split ciphertext into array of block-length strings 
// 
//   // recover nonce from 1st element of ciphertext
// 
//   var blockSize = 16;  // block size fixed at 16 bytes / 128 bits (Nb=4) for AES
// 
//   var counterBlock = new Array(blockSize);
//   var ctrTxt = unescCtrlChars(ciphertext[0]);
//   for (var i=0; i<8; i++) counterBlock[i] = ctrTxt.charCodeAt(i);
//   var plaintext = new Array(ciphertext.length-1);
//   for (var b=1; b<ciphertext.length; b++) {
//     // set counter (block #) in last 8 bytes of counter block (leaving nonce in 1st 8 bytes)
// 
//     for (var c=0; c<4; c++) counterBlock[15-c] = ((b-1) >>> c*8) & 0xff;
//     for (var c=0; c<4; c++) counterBlock[15-c-4] = ((b/0x100000000-1) >>> c*8) & 0xff;
//     var cipherCntr = Cipher(counterBlock, keySchedule);  // encrypt counter block
// 
//     ciphertext[b] = unescCtrlChars(ciphertext[b]);
//     var pt = '';
//     for (var i=0; i<ciphertext[b].length; i++) {
//       // -- xor plaintext with ciphered counter byte-by-byte --
// 
//       var ciphertextByte = ciphertext[b].charCodeAt(i);
//       var plaintextByte = ciphertextByte ^ cipherCntr[i];
//       pt += String.fromCharCode(plaintextByte);
//     }
//     // pt is now plaintext for this block
// 
//     plaintext[b-1] = pt;  // b-1 'cos no initial nonce block in plaintext
// 
//   }
//   return plaintext.join('');
// }
// /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
// function escCtrlChars(str) {  // escape control chars which might cause problems handling ciphertext
// 
//   return str.replace(/[\0\t\n\v\f\r\xa0'"!-]/g, function(c) { return '!' + c.charCodeAt(0) + '!'; });
// }  // \xa0 to cater for bug in Firefox; include '-' to leave it free for use as a block marker
// 
// function unescCtrlChars(str) {  // unescape potentially problematic control characters
// 
//   return str.replace(/!\d\d?\d?!/g, function(c) { return String.fromCharCode(c.slice(1,-1)); });
// }
// /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
// /*
// 
// var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  4:             var_decl                    // var b64;
// function encodeBase64(str) {  // http://tools.ietf.org/html/rfc4648
// 
//    var o1, o2, o3, h1, h2, h3, h4, bits, i=0, enc='';
//    
//    str = encodeUTF8(str);  // encode multi-byte chars into UTF-8 for byte-array
// 
//    do {  // pack three octets into four hexets
// 
//       o1 = str.charCodeAt(i++);
//       o2 = str.charCodeAt(i++);
//       o3 = str.charCodeAt(i++);
//       
//       bits = o1<<16 | o2<<8 | o3;
//       
//       h1 = bits>>18 & 0x3f;
//       h2 = bits>>12 & 0x3f;
//       h3 = bits>>6 & 0x3f;
//       h4 = bits & 0x3f;
//       
//       // end of string? index to '=' in b64
// 
//       if (isNaN(o3)) h4 = 64;
//       if (isNaN(o2)) h3 = 64;
//       
//       // use hexets to index into b64, and append result to encoded string
// 
//       enc += b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
//    } while (i < str.length);
//    
//    return enc;
// }
// function decodeBase64(str) {
//    var o1, o2, o3, h1, h2, h3, h4, bits, i=0, enc='';
//    do {  // unpack four hexets into three octets using index points in b64
// 
//       h1 = b64.indexOf(str.charAt(i++));
//       h2 = b64.indexOf(str.charAt(i++));
//       h3 = b64.indexOf(str.charAt(i++));
//       h4 = b64.indexOf(str.charAt(i++));
//       
//       bits = h1<<18 | h2<<12 | h3<<6 | h4;
//       
//       o1 = bits>>16 & 0xff;
//       o2 = bits>>8 & 0xff;
//       o3 = bits & 0xff;
//       
//       if (h3 == 64)      enc += String.fromCharCode(o1);
//       else if (h4 == 64) enc += String.fromCharCode(o1, o2);
//       else               enc += String.fromCharCode(o1, o2, o3);
//    } while (i < str.length);
//    return decodeUTF8(enc);  // decode UTF-8 byte-array back to Unicode
// 
// }
// function encodeUTF8(str) {  // encode multi-byte string into utf-8 multiple single-byte characters 
// 
//   str = str.replace(
//       /[\u0080-\u07ff]/g,  // U+0080 - U+07FF = 2-byte chars
// 
//       function(c) { 
//         var cc = c.charCodeAt(0);
//         return String.fromCharCode(0xc0 | cc>>6, 0x80 | cc&0x3f); }
//     );
//   str = str.replace(
//       /[\u0800-\uffff]/g,  // U+0800 - U+FFFF = 3-byte chars
// 
//       function(c) { 
//         var cc = c.charCodeAt(0); 
//         return String.fromCharCode(0xe0 | cc>>12, 0x80 | cc>>6&0x3F, 0x80 | cc&0x3f); }
//     );
//   return str;
// }
// function decodeUTF8(str) {  // decode utf-8 encoded string back into multi-byte characters
// 
//   str = str.replace(
//       /[\u00c0-\u00df][\u0080-\u00bf]/g,                 // 2-byte chars
// 
//       function(c) { 
//         var cc = (c.charCodeAt(0)&0x1f)<<6 | c.charCodeAt(1)&0x3f;
//         return String.fromCharCode(cc); }
//     );
//   str = str.replace(
//       /[\u00e0-\u00ef][\u0080-\u00bf][\u0080-\u00bf]/g,  // 3-byte chars
// 
//       function(c) { 
//         var cc = (c.charCodeAt(0)&0x0f)<<12 | (c.charCodeAt(1)&0x3f<<6) | c.charCodeAt(2)&0x3f; 
//         return String.fromCharCode(cc); }
//     );
//   return str;
// }
// function byteArrayToHexStr(b) {  // convert byte array to hex string for displaying test vectors
// 
//   var s = '';
//   for (var i=0; i<b.length; i++) s += b[i].toString(16) + ' ';
//   return s;
// }
// /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
// var plainText = "ROMEO: But, soft! what light through yonder window breaks?\n\
  5:             var_decl                    // var plainText;
// var password = "O Romeo, Romeo! wherefore art thou Romeo?";
  6:             var_decl                    // var password;
// var cipherText = AESEncryptCtr(plainText, password, 256);
  7:             var_decl                    // var cipherText;
// var decryptedText = AESDecryptCtr(cipherText, password, 256);
  8:             var_decl                    // var decryptedText;
// if (decryptedText != plainText)
//     throw "ERROR: bad result: expected " + plainText + " but got " + decryptedText;
// 
  0:          func_decl_n  254               // 
  1:                 meta    2  254          // 
  2:                 meta    2  254          // 
  0:          func_decl_n  254               //  // REWRITE
  3:                 meta    7  255          // function end: 65538;
// 
//   var Nb = 4;               // block size (in words): no of columns in state (fixed at 4 for AES)
  4:                 meta   12  255          // [to be rewritten]
// 
//   var Nr = w.length/Nb - 1; // no of rounds: 10/12/14 for 128/192/256-bit keys
// 
//   var state = [[],[],[],[]];  // initialise 4xNb byte-array 'state' with input [_3.4]
// 
//   for (var i=0; i<4*Nb; i++) state[i%4][Math.floor(i/4)] = input[i];
//   state = AddRoundKey(state, w, 0, Nb);
//   for (var round=1; round<Nr; round++) {
//     state = SubBytes(state, Nb);
//     state = ShiftRows(state, Nb);
//     state = MixColumns(state, Nb);
//     state = AddRoundKey(state, w, round, Nb);
//   }
//   state = SubBytes(state, Nb);
//   state = ShiftRows(state, Nb);
//   state = AddRoundKey(state, w, Nr, Nb);
//   var output = new Array(4*Nb);  // convert state to 1-d array before returning [_3.4]
// 
//   for (var i=0; i<4*Nb; i++) output[i] = state[i%4][Math.floor(i/4)];
//   return output;
// }
  4:                 meta   12    6          // [no 'arguments'] [no 'eval']  // REWRITE
  5:         reg_var_decl  128               // var tmp128 .. tmp255;
  6:             var_decl                    // var Nb;
// 
//   var Nr = w.length/Nb - 1; // no of rounds: 10/12/14 for 128/192/256-bit keys
  7:             var_decl                    // var Nr;
// 
//   var state = [[],[],[],[]];  // initialise 4xNb byte-array 'state' with input [_3.4]
  8:             var_decl                    // var state;
// 
//   for (var i=0; i<4*Nb; i++) state[i%4][Math.floor(i/4)] = input[i];
  9:             var_decl                    // var i;
//   state = AddRoundKey(state, w, 0, Nb);
//   for (var round=1; round<Nr; round++) {
 10:             var_decl                    // var round;
//     state = SubBytes(state, Nb);
//     state = ShiftRows(state, Nb);
//     state = MixColumns(state, Nb);
//     state = AddRoundKey(state, w, round, Nb);
//   }
//   state = SubBytes(state, Nb);
//   state = ShiftRows(state, Nb);
//   state = AddRoundKey(state, w, Nr, Nb);
//   var output = new Array(4*Nb);  // convert state to 1-d array before returning [_3.4]
 11:             var_decl                    // var output;
// 
//   for (var i=0; i<4*Nb; i++) output[i] = state[i%4][Math.floor(i/4)];
//   return output;
// }
 12:           assignment  130    1          // tmp130 = 4: SMALLINT;
 13:           assignment  254    6          // Nb = tmp130 : TYPEOF(tmp130);
// 
//   var Nr = w.length/Nb - 1; // no of rounds: 10/12/14 for 128/192/256-bit keys
 14:           assignment  130    5          // tmp130 = 'length': STRING;
 15:          prop_getter  131  254          // tmp131 = w[tmp130];
 16:             division  132  131          // tmp132 = tmp131 / Nb;
 17:           assignment  133    1          // tmp133 = 1: SMALLINT;
 18:         substraction  134  132          // tmp134 = tmp132 - tmp133;
 19:           assignment  254    6          // Nr = tmp134 : TYPEOF(tmp134);
// 
//   var state = [[],[],[],[]];  // initialise 4xNb byte-array 'state' with input [_3.4]
 20:           array_decl  255               // 
 21:           array_decl  255               // 
 21:           array_decl  130               // tmp130 = []; // REWRITE
 22:                 meta    2  130          // 
 23:           array_decl  255               // 
 23:           array_decl  130               // tmp130 = []; // REWRITE
 24:                 meta    2  130          // 
 25:           array_decl  255               // 
 25:           array_decl  130               // tmp130 = []; // REWRITE
 26:                 meta    2  130          // 
 27:           array_decl  255               // 
 27:           array_decl  130               // tmp130 = []; // REWRITE
 28:                 meta    2  130          // 
 20:           array_decl  130               //  // REWRITE
 29:           assignment  254    6          // state = tmp130 : TYPEOF(tmp130);
// 
//   for (var i=0; i<4*Nb; i++) state[i%4][Math.floor(i/4)] = input[i];
 30:           assignment  130    1          // tmp130 = 0: SMALLINT;
 31:           assignment  254    6          // i = tmp130 : TYPEOF(tmp130);
 32:             jmp_down  255               // goto 65567;
 33:           assignment  130    6          // tmp130 = i : TYPEOF(i);
 34:           assignment  131    1          // tmp131 = 4: SMALLINT;
 35:            remainder  132  130          // tmp132 = tmp130 %% tmp131;
 36:          prop_getter  133  254          // tmp133 = state[tmp132];
 37:           assignment  134    5          // tmp134 = 'floor': STRING;
 38:          prop_getter  135  254          // tmp135 = Math[tmp134];
 39:           assignment  136    6          // tmp136 = Math : TYPEOF(Math);
 40:               call_n  255  135          // 
 41:                 meta    1    1          // 
 42:           assignment  137    6          // tmp137 = i : TYPEOF(i);
 43:           assignment  138    1          // tmp138 = 4: SMALLINT;
 44:             division  139  137          // tmp139 = tmp137 / tmp138;
 45:                 meta    2  139          // 
 40:               call_n  137  135          //  // REWRITE
 46:          prop_getter  138  133          // tmp138 = tmp133[tmp137];
 46:          prop_getter  139  254          // tmp139 = input[i];
 47:          prop_setter  133  137          // tmp133[tmp137] = tmp139;
 48:            post_incr  140               // tmp140 = i++;
 32:             jmp_down    0               // goto 49; // REWRITE
 49:           assignment  141    6          // tmp141 = i : TYPEOF(i);
 50:           assignment  142    1          // tmp142 = 4: SMALLINT;
 51:       multiplication  143  142          // tmp143 = tmp142 * Nb;
 52:            less_than  144  141          // tmp144 = tmp141 < tmp143;
 53:       is_true_jmp_up  144    0          // if (tmp144) goto 33;
//   state = AddRoundKey(state, w, 0, Nb);
 54:               call_n  255  254          // 
 55:                 meta    2  254          // 
 56:                 meta    2  254          // 
 57:           assignment  130    1          // tmp130 = 0: SMALLINT;
 58:                 meta    2  130          // 
 59:                 meta    2  254          // 
 54:               call_n  130  254          //  // REWRITE
 60:           assignment  254    6          // state = tmp130 : TYPEOF(tmp130);
//   for (var round=1; round<Nr; round++) {
 61:           assignment  130    1          // tmp130 = 1: SMALLINT;
 62:           assignment  254    6          // round = tmp130 : TYPEOF(tmp130);
 63:             jmp_down  255               // goto 65598;
//     state = SubBytes(state, Nb);
 64:               call_n  255  254          // 
 65:                 meta    2  254          // 
 66:                 meta    2  254          // 
 64:               call_n  130  254          //  // REWRITE
 67:           assignment  254    6          // state = tmp130 : TYPEOF(tmp130);
//     state = ShiftRows(state, Nb);
 68:               call_n  255  254          // 
 69:                 meta    2  254          // 
 70:                 meta    2  254          // 
 68:               call_n  130  254          //  // REWRITE
 71:           assignment  254    6          // state = tmp130 : TYPEOF(tmp130);
//     state = MixColumns(state, Nb);
 72:               call_n  255  254          // 
 73:                 meta    2  254          // 
 74:                 meta    2  254          // 
 72:               call_n  130  254          //  // REWRITE
 75:           assignment  254    6          // state = tmp130 : TYPEOF(tmp130);
//     state = AddRoundKey(state, w, round, Nb);
 76:               call_n  255  254          // 
 77:                 meta    2  254          // 
 78:                 meta    2  254          // 
 79:                 meta    2  254          // 
 80:                 meta    2  254          // 
 76:               call_n  130  254          //  // REWRITE
 81:           assignment  254    6          // state = tmp130 : TYPEOF(tmp130);
//   }
 82:            post_incr  131               // tmp131 = round++;
 63:             jmp_down    0               // goto 83; // REWRITE
 83:           assignment  132    6          // tmp132 = round : TYPEOF(round);
 84:            less_than  133  132          // tmp133 = tmp132 < Nr;
 85:       is_true_jmp_up  133    0          // if (tmp133) goto 64;
//   state = SubBytes(state, Nb);
 86:               call_n  255  254          // 
 87:                 meta    2  254          // 
 88:                 meta    2  254          // 
 86:               call_n  130  254          //  // REWRITE
 89:           assignment  254    6          // state = tmp130 : TYPEOF(tmp130);
//   state = ShiftRows(state, Nb);
 90:               call_n  255  254          // 
 91:                 meta    2  254          // 
 92:                 meta    2  254          // 
 90:               call_n  130  254          //  // REWRITE
 93:           assignment  254    6          // state = tmp130 : TYPEOF(tmp130);
//   state = AddRoundKey(state, w, Nr, Nb);
 94:               call_n  255  254          // 
 95:                 meta    2  254          // 
 96:                 meta    2  254          // 
 97:                 meta    2  254          // 
 98:                 meta    2  254          // 
 94:               call_n  130  254          //  // REWRITE
 99:           assignment  254    6          // state = tmp130 : TYPEOF(tmp130);
//   var output = new Array(4*Nb);  // convert state to 1-d array before returning [_3.4]
100:          construct_n  255  254          // 
101:           assignment  130    1          // tmp130 = 4: SMALLINT;
102:       multiplication  131  130          // tmp131 = tmp130 * Nb;
103:                 meta    2  131          // 
100:          construct_n  130  254          //  // REWRITE
104:           assignment  254    6          // output = tmp130 : TYPEOF(tmp130);
// 
//   for (var i=0; i<4*Nb; i++) output[i] = state[i%4][Math.floor(i/4)];
105:           assignment  130    1          // tmp130 = 0: SMALLINT;
106:           assignment  254    6          // i = tmp130 : TYPEOF(tmp130);
107:             jmp_down  255               // goto 65642;
108:          prop_getter  130  254          // tmp130 = output[i];
108:           assignment  131    6          // tmp131 = i : TYPEOF(i);
109:           assignment  132    1          // tmp132 = 4: SMALLINT;
110:            remainder  133  131          // tmp133 = tmp131 %% tmp132;
111:          prop_getter  134  254          // tmp134 = state[tmp133];
112:           assignment  135    5          // tmp135 = 'floor': STRING;
113:          prop_getter  136  254          // tmp136 = Math[tmp135];
114:           assignment  137    6          // tmp137 = Math : TYPEOF(Math);
115:               call_n  255  136          // 
116:                 meta    1    1          // 
117:           assignment  138    6          // tmp138 = i : TYPEOF(i);
118:           assignment  139    1          // tmp139 = 4: SMALLINT;
119:             division  140  138          // tmp140 = tmp138 / tmp139;
120:                 meta    2  140          // 
115:               call_n  138  136          //  // REWRITE
121:          prop_getter  139  134          // tmp139 = tmp134[tmp138];
122:          prop_setter  254  254          // output[i] = tmp139;
123:            post_incr  140               // tmp140 = i++;
107:             jmp_down    0               // goto 124; // REWRITE
124:           assignment  141    6          // tmp141 = i : TYPEOF(i);
125:           assignment  142    1          // tmp142 = 4: SMALLINT;
126:       multiplication  143  142          // tmp143 = tmp142 * Nb;
127:            less_than  144  141          // tmp144 = tmp141 < tmp143;
128:       is_true_jmp_up  144    0          // if (tmp144) goto 108;
//   return output;
129:               retval                    // return output;
// }
  5:         reg_var_decl  128               // var tmp128 .. tmp144; // REWRITE
130:                  ret                    // ret;
  3:                 meta    7    0          // function end: 131; // REWRITE
// function SubBytes(s, Nb) {    // apply SBox to state S [_5.1.1]
  0:          func_decl_n  254               // 
  1:                 meta    2  254          // 
  2:                 meta    2  254          // 
  0:          func_decl_n  254               //  // REWRITE
  3:                 meta    7  255          // function end: 65538;
// 
//   for (var r=0; r<4; r++) {
  4:                 meta   12  255          // [to be rewritten]
//     for (var c=0; c<Nb; c++) s[r][c] = Sbox[s[r][c]];
//   }
//   return s;
// }
  4:                 meta   12    6          // [no 'arguments'] [no 'eval']  // REWRITE
  5:         reg_var_decl  128               // var tmp128 .. tmp255;
  6:             var_decl                    // var r;
//     for (var c=0; c<Nb; c++) s[r][c] = Sbox[s[r][c]];
  7:             var_decl                    // var c;
//   }
//   return s;
// }
  8:           assignment  130    1          // tmp130 = 0: SMALLINT;
  9:           assignment  254    6          // r = tmp130 : TYPEOF(tmp130);
 10:             jmp_down  255               // goto 65545;
//     for (var c=0; c<Nb; c++) s[r][c] = Sbox[s[r][c]];
 11:           assignment  130    1          // tmp130 = 0: SMALLINT;
 12:           assignment  254    6          // c = tmp130 : TYPEOF(tmp130);
 13:             jmp_down  255               // goto 65548;
 14:          prop_getter  130  254          // tmp130 = s[r];
 15:          prop_getter  131  130          // tmp131 = tmp130[c];
 15:          prop_getter  132  254          // tmp132 = s[r];
 16:          prop_getter  133  132          // tmp133 = tmp132[c];
 17:          prop_getter  134  254          // tmp134 = Sbox[tmp133];
 18:          prop_setter  130  254          // tmp130[c] = tmp134;
 19:            post_incr  135               // tmp135 = c++;
 13:             jmp_down    0               // goto 20; // REWRITE
 20:           assignment  136    6          // tmp136 = c : TYPEOF(c);
 21:            less_than  137  136          // tmp137 = tmp136 < Nb;
 22:       is_true_jmp_up  137    0          // if (tmp137) goto 14;
//   }
 23:            post_incr  138               // tmp138 = r++;
 10:             jmp_down    0               // goto 24; // REWRITE
 24:           assignment  139    6          // tmp139 = r : TYPEOF(r);
 25:           assignment  140    1          // tmp140 = 4: SMALLINT;
 26:            less_than  141  139          // tmp141 = tmp139 < tmp140;
 27:       is_true_jmp_up  141    0          // if (tmp141) goto 11;
//   return s;
 28:               retval                    // return s;
// }
  5:         reg_var_decl  128               // var tmp128 .. tmp141; // REWRITE
 29:                  ret                    // ret;
  3:                 meta    7    0          // function end: 30; // REWRITE
// function ShiftRows(s, Nb) {    // shift row r of state S left by r bytes [_5.1.2]
  0:          func_decl_n  254               // 
  1:                 meta    2  254          // 
  2:                 meta    2  254          // 
  0:          func_decl_n  254               //  // REWRITE
  3:                 meta    7  255          // function end: 65538;
// 
//   var t = new Array(4);
  4:                 meta   12  255          // [to be rewritten]
//   for (var r=1; r<4; r++) {
//     for (var c=0; c<4; c++) t[c] = s[r][(c+r)%Nb];  // shift into temp copy
// 
//     for (var c=0; c<4; c++) s[r][c] = t[c];         // and copy back
// 
//   }          // note that this will work for Nb=4,5,6, but not 7,8 (always 4 for AES):
// 
//   return s;  // see fp.gladman.plus.com/cryptography_technology/rijndael/aes.spec.311.pdf 
// 
// }
  4:                 meta   12    6          // [no 'arguments'] [no 'eval']  // REWRITE
  5:         reg_var_decl  128               // var tmp128 .. tmp255;
  6:             var_decl                    // var t;
//   for (var r=1; r<4; r++) {
  7:             var_decl                    // var r;
//     for (var c=0; c<4; c++) t[c] = s[r][(c+r)%Nb];  // shift into temp copy
  8:             var_decl                    // var c;
// 
//     for (var c=0; c<4; c++) s[r][c] = t[c];         // and copy back
// 
//   }          // note that this will work for Nb=4,5,6, but not 7,8 (always 4 for AES):
// 
//   return s;  // see fp.gladman.plus.com/cryptography_technology/rijndael/aes.spec.311.pdf 
// 
// }
  9:          construct_n  255  254          // 
 10:           assignment  130    1          // tmp130 = 4: SMALLINT;
 11:                 meta    2  130          // 
  9:          construct_n  130  254          //  // REWRITE
 12:           assignment  254    6          // t = tmp130 : TYPEOF(tmp130);
//   for (var r=1; r<4; r++) {
 13:           assignment  130    1          // tmp130 = 1: SMALLINT;
 14:           assignment  254    6          // r = tmp130 : TYPEOF(tmp130);
 15:             jmp_down  255               // goto 65550;
//     for (var c=0; c<4; c++) t[c] = s[r][(c+r)%Nb];  // shift into temp copy
 16:           assignment  130    1          // tmp130 = 0: SMALLINT;
 17:           assignment  254    6          // c = tmp130 : TYPEOF(tmp130);
 18:             jmp_down  255               // goto 65553;
 19:          prop_getter  130  254          // tmp130 = t[c];
 19:          prop_getter  131  254          // tmp131 = s[r];
 20:           assignment  132    6          // tmp132 = c : TYPEOF(c);
 21:             addition  133  132          // tmp133 = tmp132 + r;
 22:            remainder  134  133          // tmp134 = tmp133 %% Nb;
 23:          prop_getter  135  131          // tmp135 = tmp131[tmp134];
 24:          prop_setter  254  254          // t[c] = tmp135;
 25:            post_incr  136               // tmp136 = c++;
 18:             jmp_down    0               // goto 26; // REWRITE
 26:           assignment  137    6          // tmp137 = c : TYPEOF(c);
 27:           assignment  138    1          // tmp138 = 4: SMALLINT;
 28:            less_than  139  137          // tmp139 = tmp137 < tmp138;
 29:       is_true_jmp_up  139    0          // if (tmp139) goto 19;
// 
//     for (var c=0; c<4; c++) s[r][c] = t[c];         // and copy back
 30:           assignment  130    1          // tmp130 = 0: SMALLINT;
 31:           assignment  254    6          // c = tmp130 : TYPEOF(tmp130);
 32:             jmp_down  255               // goto 65567;
 33:          prop_getter  130  254          // tmp130 = s[r];
 34:          prop_getter  131  130          // tmp131 = tmp130[c];
 34:          prop_getter  132  254          // tmp132 = t[c];
 35:          prop_setter  130  254          // tmp130[c] = tmp132;
 36:            post_incr  133               // tmp133 = c++;
 32:             jmp_down    0               // goto 37; // REWRITE
 37:           assignment  134    6          // tmp134 = c : TYPEOF(c);
 38:           assignment  135    1          // tmp135 = 4: SMALLINT;
 39:            less_than  136  134          // tmp136 = tmp134 < tmp135;
 40:       is_true_jmp_up  136    0          // if (tmp136) goto 33;
// 
//   }          // note that this will work for Nb=4,5,6, but not 7,8 (always 4 for AES):
 41:            post_incr  137               // tmp137 = r++;
 15:             jmp_down    0               // goto 42; // REWRITE
 42:           assignment  138    6          // tmp138 = r : TYPEOF(r);
 43:           assignment  139    1          // tmp139 = 4: SMALLINT;
 44:            less_than  140  138          // tmp140 = tmp138 < tmp139;
 45:       is_true_jmp_up  140    0          // if (tmp140) goto 16;
// 
//   return s;  // see fp.gladman.plus.com/cryptography_technology/rijndael/aes.spec.311.pdf 
 46:               retval                    // return s;
// 
// }
  5:         reg_var_decl  128               // var tmp128 .. tmp140; // REWRITE
 47:                  ret                    // ret;
  3:                 meta    7    0          // function end: 48; // REWRITE
// function MixColumns(s, Nb) {   // combine bytes of each col of state S [_5.1.3]
  0:          func_decl_n  254               // 
  1:                 meta    2  254          // 
  2:                 meta    2  254          // 
  0:          func_decl_n  254               //  // REWRITE
  3:                 meta    7  255          // function end: 65538;
// 
//   for (var c=0; c<4; c++) {
  4:                 meta   12  255          // [to be rewritten]
//     var a = new Array(4);  // 'a' is a copy of the current column from 's'
// 
//     var b = new Array(4);  // 'b' is a_{02} in GF(2^8)
// 
//     for (var i=0; i<4; i++) {
//       a[i] = s[i][c];
//       b[i] = s[i][c]&0x80 ? s[i][c]<<1 ^ 0x011b : s[i][c]<<1;
//     }
//     // a[n] ^ b[n] is a_{03} in GF(2^8)
// 
//     s[0][c] = b[0] ^ a[1] ^ b[1] ^ a[2] ^ a[3]; // 2*a0 + 3*a1 + a2 + a3
// 
//     s[1][c] = a[0] ^ b[1] ^ a[2] ^ b[2] ^ a[3]; // a0 * 2*a1 + 3*a2 + a3
// 
//     s[2][c] = a[0] ^ a[1] ^ b[2] ^ a[3] ^ b[3]; // a0 + a1 + 2*a2 + 3*a3
// 
//     s[3][c] = a[0] ^ b[0] ^ a[1] ^ a[2] ^ b[3]; // 3*a0 + a1 + a2 + 2*a3
// 
//   }
//   return s;
// }
  4:                 meta   12    6          // [no 'arguments'] [no 'eval']  // REWRITE
  5:         reg_var_decl  128               // var tmp128 .. tmp255;
  6:             var_decl                    // var c;
//     var a = new Array(4);  // 'a' is a copy of the current column from 's'
  7:             var_decl                    // var a;
// 
//     var b = new Array(4);  // 'b' is a_{02} in GF(2^8)
  8:             var_decl                    // var b;
// 
//     for (var i=0; i<4; i++) {
  9:             var_decl                    // var i;
//       a[i] = s[i][c];
//       b[i] = s[i][c]&0x80 ? s[i][c]<<1 ^ 0x011b : s[i][c]<<1;
//     }
//     // a[n] ^ b[n] is a_{03} in GF(2^8)
// 
//     s[0][c] = b[0] ^ a[1] ^ b[1] ^ a[2] ^ a[3]; // 2*a0 + 3*a1 + a2 + a3
// 
//     s[1][c] = a[0] ^ b[1] ^ a[2] ^ b[2] ^ a[3]; // a0 * 2*a1 + 3*a2 + a3
// 
//     s[2][c] = a[0] ^ a[1] ^ b[2] ^ a[3] ^ b[3]; // a0 + a1 + 2*a2 + 3*a3
// 
//     s[3][c] = a[0] ^ b[0] ^ a[1] ^ a[2] ^ b[3]; // 3*a0 + a1 + a2 + 2*a3
// 
//   }
//   return s;
// }
 10:           assignment  130    1          // tmp130 = 0: SMALLINT;
 11:           assignment  254    6          // c = tmp130 : TYPEOF(tmp130);
 12:             jmp_down  255               // goto 65547;
//     var a = new Array(4);  // 'a' is a copy of the current column from 's'
 13:          construct_n  255  254          // 
 14:           assignment  130    1          // tmp130 = 4: SMALLINT;
 15:                 meta    2  130          // 
 13:          construct_n  130  254          //  // REWRITE
 16:           assignment  254    6          // a = tmp130 : TYPEOF(tmp130);
// 
//     var b = new Array(4);  // 'b' is a_{02} in GF(2^8)
 17:          construct_n  255  254          // 
 18:           assignment  130    1          // tmp130 = 4: SMALLINT;
 19:                 meta    2  130          // 
 17:          construct_n  130  254          //  // REWRITE
 20:           assignment  254    6          // b = tmp130 : TYPEOF(tmp130);
// 
//     for (var i=0; i<4; i++) {
 21:           assignment  130    1          // tmp130 = 0: SMALLINT;
 22:           assignment  254    6          // i = tmp130 : TYPEOF(tmp130);
 23:             jmp_down  255               // goto 65558;
//       a[i] = s[i][c];
 24:          prop_getter  130  254          // tmp130 = a[i];
 24:          prop_getter  131  254          // tmp131 = s[i];
 25:          prop_getter  132  131          // tmp132 = tmp131[c];
 26:          prop_setter  254  254          // a[i] = tmp132;
//       b[i] = s[i][c]&0x80 ? s[i][c]<<1 ^ 0x011b : s[i][c]<<1;
 27:          prop_getter  130  254          // tmp130 = b[i];
 27:          prop_getter  131  254          // tmp131 = s[i];
 28:          prop_getter  132  131          // tmp132 = tmp131[c];
 29:           assignment  133    1          // tmp133 = 128: SMALLINT;
 30:                b_and  134  132          // tmp134 = tmp132 & tmp133;
 31:    is_false_jmp_down  134  255          // if (tmp134 == false) goto 65566;
 32:          prop_getter  135  254          // tmp135 = s[i];
 33:          prop_getter  136  135          // tmp136 = tmp135[c];
 34:           assignment  137    1          // tmp137 = 1: SMALLINT;
 35:         b_shift_left  138  136          // tmp138 = tmp136 << tmp137;
 36:           assignment  139    3          // tmp139 = 283: NUMBER;
 37:                b_xor  140  138          // tmp140 = tmp138 ^ tmp139;
 38:           assignment  141    6          // tmp141 = tmp140 : TYPEOF(tmp140);
 39:             jmp_down  255               // goto 65574;
 31:    is_false_jmp_down  134    0          // if (tmp134 == false) goto 40; // REWRITE
 40:          prop_getter  142  254          // tmp142 = s[i];
 41:          prop_getter  143  142          // tmp143 = tmp142[c];
 42:           assignment  144    1          // tmp144 = 1: SMALLINT;
 43:         b_shift_left  145  143          // tmp145 = tmp143 << tmp144;
 44:           assignment  141    6          // tmp141 = tmp145 : TYPEOF(tmp145);
 39:             jmp_down    0               // goto 45; // REWRITE
 45:          prop_setter  254  254          // b[i] = tmp141;
//     }
 46:            post_incr  146               // tmp146 = i++;
 23:             jmp_down    0               // goto 47; // REWRITE
 47:           assignment  147    6          // tmp147 = i : TYPEOF(i);
 48:           assignment  148    1          // tmp148 = 4: SMALLINT;
 49:            less_than  149  147          // tmp149 = tmp147 < tmp148;
 50:       is_true_jmp_up  149    0          // if (tmp149) goto 24;
//     // a[n] ^ b[n] is a_{03} in GF(2^8)
// 
//     s[0][c] = b[0] ^ a[1] ^ b[1] ^ a[2] ^ a[3]; // 2*a0 + 3*a1 + a2 + a3
 51:           assignment  130    1          // tmp130 = 0: SMALLINT;
 52:          prop_getter  131  254          // tmp131 = s[tmp130];
 53:          prop_getter  132  131          // tmp132 = tmp131[c];
 53:           assignment  133    1          // tmp133 = 0: SMALLINT;
 54:          prop_getter  134  254          // tmp134 = b[tmp133];
 55:           assignment  135    1          // tmp135 = 1: SMALLINT;
 56:          prop_getter  136  254          // tmp136 = a[tmp135];
 57:                b_xor  137  134          // tmp137 = tmp134 ^ tmp136;
 58:           assignment  138    1          // tmp138 = 1: SMALLINT;
 59:          prop_getter  139  254          // tmp139 = b[tmp138];
 60:                b_xor  140  137          // tmp140 = tmp137 ^ tmp139;
 61:           assignment  141    1          // tmp141 = 2: SMALLINT;
 62:          prop_getter  142  254          // tmp142 = a[tmp141];
 63:                b_xor  143  140          // tmp143 = tmp140 ^ tmp142;
 64:           assignment  144    1          // tmp144 = 3: SMALLINT;
 65:          prop_getter  145  254          // tmp145 = a[tmp144];
 66:                b_xor  146  143          // tmp146 = tmp143 ^ tmp145;
 67:          prop_setter  131  254          // tmp131[c] = tmp146;
// 
//     s[1][c] = a[0] ^ b[1] ^ a[2] ^ b[2] ^ a[3]; // a0 * 2*a1 + 3*a2 + a3
 68:           assignment  130    1          // tmp130 = 1: SMALLINT;
 69:          prop_getter  131  254          // tmp131 = s[tmp130];
 70:          prop_getter  132  131          // tmp132 = tmp131[c];
 70:           assignment  133    1          // tmp133 = 0: SMALLINT;
 71:          prop_getter  134  254          // tmp134 = a[tmp133];
 72:           assignment  135    1          // tmp135 = 1: SMALLINT;
 73:          prop_getter  136  254          // tmp136 = b[tmp135];
 74:                b_xor  137  134          // tmp137 = tmp134 ^ tmp136;
 75:           assignment  138    1          // tmp138 = 2: SMALLINT;
 76:          prop_getter  139  254          // tmp139 = a[tmp138];
 77:                b_xor  140  137          // tmp140 = tmp137 ^ tmp139;
 78:           assignment  141    1          // tmp141 = 2: SMALLINT;
 79:          prop_getter  142  254          // tmp142 = b[tmp141];
 80:                b_xor  143  140          // tmp143 = tmp140 ^ tmp142;
 81:           assignment  144    1          // tmp144 = 3: SMALLINT;
 82:          prop_getter  145  254          // tmp145 = a[tmp144];
 83:                b_xor  146  143          // tmp146 = tmp143 ^ tmp145;
 84:          prop_setter  131  254          // tmp131[c] = tmp146;
// 
//     s[2][c] = a[0] ^ a[1] ^ b[2] ^ a[3] ^ b[3]; // a0 + a1 + 2*a2 + 3*a3
 85:           assignment  130    1          // tmp130 = 2: SMALLINT;
 86:          prop_getter  131  254          // tmp131 = s[tmp130];
 87:          prop_getter  132  131          // tmp132 = tmp131[c];
 87:           assignment  133    1          // tmp133 = 0: SMALLINT;
 88:          prop_getter  134  254          // tmp134 = a[tmp133];
 89:           assignment  135    1          // tmp135 = 1: SMALLINT;
 90:          prop_getter  136  254          // tmp136 = a[tmp135];
 91:                b_xor  137  134          // tmp137 = tmp134 ^ tmp136;
 92:           assignment  138    1          // tmp138 = 2: SMALLINT;
 93:          prop_getter  139  254          // tmp139 = b[tmp138];
 94:                b_xor  140  137          // tmp140 = tmp137 ^ tmp139;
 95:           assignment  141    1          // tmp141 = 3: SMALLINT;
 96:          prop_getter  142  254          // tmp142 = a[tmp141];
 97:                b_xor  143  140          // tmp143 = tmp140 ^ tmp142;
 98:           assignment  144    1          // tmp144 = 3: SMALLINT;
 99:          prop_getter  145  254          // tmp145 = b[tmp144];
100:                b_xor  146  143          // tmp146 = tmp143 ^ tmp145;
101:          prop_setter  131  254          // tmp131[c] = tmp146;
// 
//     s[3][c] = a[0] ^ b[0] ^ a[1] ^ a[2] ^ b[3]; // 3*a0 + a1 + a2 + 2*a3
102:           assignment  130    1          // tmp130 = 3: SMALLINT;
103:          prop_getter  131  254          // tmp131 = s[tmp130];
104:          prop_getter  132  131          // tmp132 = tmp131[c];
104:           assignment  133    1          // tmp133 = 0: SMALLINT;
105:          prop_getter  134  254          // tmp134 = a[tmp133];
106:           assignment  135    1          // tmp135 = 0: SMALLINT;
107:          prop_getter  136  254          // tmp136 = b[tmp135];
108:                b_xor  137  134          // tmp137 = tmp134 ^ tmp136;
109:           assignment  138    1          // tmp138 = 1: SMALLINT;
110:          prop_getter  139  254          // tmp139 = a[tmp138];
111:                b_xor  140  137          // tmp140 = tmp137 ^ tmp139;
112:           assignment  141    1          // tmp141 = 2: SMALLINT;
113:          prop_getter  142  254          // tmp142 = a[tmp141];
114:                b_xor  143  140          // tmp143 = tmp140 ^ tmp142;
115:           assignment  144    1          // tmp144 = 3: SMALLINT;
116:          prop_getter  145  254          // tmp145 = b[tmp144];
117:                b_xor  146  143          // tmp146 = tmp143 ^ tmp145;
118:          prop_setter  131  254          // tmp131[c] = tmp146;
// 
//   }
119:            post_incr  147               // tmp147 = c++;
 12:             jmp_down    0               // goto 120; // REWRITE
120:           assignment  148    6          // tmp148 = c : TYPEOF(c);
121:           assignment  149    1          // tmp149 = 4: SMALLINT;
122:            less_than  150  148          // tmp150 = tmp148 < tmp149;
123:       is_true_jmp_up  150    0          // if (tmp150) goto 13;
//   return s;
124:               retval                    // return s;
// }
  5:         reg_var_decl  128               // var tmp128 .. tmp150; // REWRITE
125:                  ret                    // ret;
  3:                 meta    7    0          // function end: 126; // REWRITE
// function AddRoundKey(state, w, rnd, Nb) {  // xor Round Key into state S [_5.1.4]
  0:          func_decl_n  254               // 
  1:                 meta    2  254          // 
  2:                 meta    2  254          // 
  3:                 meta    2  254          // 
  4:                 meta    2  254          // 
  0:          func_decl_n  254               //  // REWRITE
  5:                 meta    7  255          // function end: 65540;
// 
//   for (var r=0; r<4; r++) {
  6:                 meta   12  255          // [to be rewritten]
//     for (var c=0; c<Nb; c++) state[r][c] ^= w[rnd*4+c][r];
//   }
//   return state;
// }
  6:                 meta   12    6          // [no 'arguments'] [no 'eval']  // REWRITE
  7:         reg_var_decl  128               // var tmp128 .. tmp255;
  8:             var_decl                    // var r;
//     for (var c=0; c<Nb; c++) state[r][c] ^= w[rnd*4+c][r];
  9:             var_decl                    // var c;
//   }
//   return state;
// }
 10:           assignment  130    1          // tmp130 = 0: SMALLINT;
 11:           assignment  254    6          // r = tmp130 : TYPEOF(tmp130);
 12:             jmp_down  255               // goto 65547;
//     for (var c=0; c<Nb; c++) state[r][c] ^= w[rnd*4+c][r];
 13:           assignment  130    1          // tmp130 = 0: SMALLINT;
 14:           assignment  254    6          // c = tmp130 : TYPEOF(tmp130);
 15:             jmp_down  255               // goto 65550;
 16:          prop_getter  130  254          // tmp130 = state[r];
 17:          prop_getter  131  130          // tmp131 = tmp130[c];
 17:           assignment  132    6          // tmp132 = rnd : TYPEOF(rnd);
 18:           assignment  133    1          // tmp133 = 4: SMALLINT;
 19:       multiplication  134  132          // tmp134 = tmp132 * tmp133;
 20:             addition  135  134          // tmp135 = tmp134 + c;
 21:          prop_getter  136  254          // tmp136 = w[tmp135];
 22:          prop_getter  137  136          // tmp137 = tmp136[r];
 23:          prop_getter  138  130          // tmp138 = tmp130[c];
 24:                b_xor  138  138          // tmp138 = tmp138 ^ tmp137;
 25:          prop_setter  130  254          // tmp130[c] = tmp138;
 26:            post_incr  139               // tmp139 = c++;
 15:             jmp_down    0               // goto 27; // REWRITE
 27:           assignment  140    6          // tmp140 = c : TYPEOF(c);
 28:            less_than  141  140          // tmp141 = tmp140 < Nb;
 29:       is_true_jmp_up  141    0          // if (tmp141) goto 16;
//   }
 30:            post_incr  142               // tmp142 = r++;
 12:             jmp_down    0               // goto 31; // REWRITE
 31:           assignment  143    6          // tmp143 = r : TYPEOF(r);
 32:           assignment  144    1          // tmp144 = 4: SMALLINT;
 33:            less_than  145  143          // tmp145 = tmp143 < tmp144;
 34:       is_true_jmp_up  145    0          // if (tmp145) goto 13;
//   return state;
 35:               retval                    // return state;
// }
  7:         reg_var_decl  128               // var tmp128 .. tmp145; // REWRITE
 36:                  ret                    // ret;
  5:                 meta    7    0          // function end: 37; // REWRITE
// function KeyExpansion(key) {  // generate Key Schedule (byte-array Nr+1 x Nb) from Key [_5.2]
  0:          func_decl_n  254               // 
  1:                 meta    2  254          // 
  0:          func_decl_n  254               //  // REWRITE
  2:                 meta    7  255          // function end: 65537;
// 
//   var Nb = 4;            // block size (in words): no of columns in state (fixed at 4 for AES)
  3:                 meta   12  255          // [to be rewritten]
// 
//   var Nk = key.length/4  // key length (in words): 4/6/8 for 128/192/256-bit keys
// 
//   var Nr = Nk + 6;       // no of rounds: 10/12/14 for 128/192/256-bit keys
// 
//   var w = new Array(Nb*(Nr+1));
//   var temp = new Array(4);
//   for (var i=0; i<Nk; i++) {
//     var r = [key[4*i], key[4*i+1], key[4*i+2], key[4*i+3]];
//     w[i] = r;
//   }
//   for (var i=Nk; i<(Nb*(Nr+1)); i++) {
//     w[i] = new Array(4);
//     for (var t=0; t<4; t++) temp[t] = w[i-1][t];
//     if (i % Nk == 0) {
//       temp = SubWord(RotWord(temp));
//       for (var t=0; t<4; t++) temp[t] ^= Rcon[i/Nk][t];
//     } else if (Nk > 6 && i%Nk == 4) {
//       temp = SubWord(temp);
//     }
//     for (var t=0; t<4; t++) w[i][t] = w[i-Nk][t] ^ temp[t];
//   }
//   return w;
// }
  3:                 meta   12    6          // [no 'arguments'] [no 'eval']  // REWRITE
  4:         reg_var_decl  128               // var tmp128 .. tmp255;
  5:             var_decl                    // var Nb;
// 
//   var Nk = key.length/4  // key length (in words): 4/6/8 for 128/192/256-bit keys
  6:             var_decl                    // var Nk;
// 
//   var Nr = Nk + 6;       // no of rounds: 10/12/14 for 128/192/256-bit keys
  7:             var_decl                    // var Nr;
// 
//   var w = new Array(Nb*(Nr+1));
  8:             var_decl                    // var w;
//   var temp = new Array(4);
  9:             var_decl                    // var temp;
//   for (var i=0; i<Nk; i++) {
 10:             var_decl                    // var i;
//     var r = [key[4*i], key[4*i+1], key[4*i+2], key[4*i+3]];
 11:             var_decl                    // var r;
//     w[i] = r;
//   }
//   for (var i=Nk; i<(Nb*(Nr+1)); i++) {
//     w[i] = new Array(4);
//     for (var t=0; t<4; t++) temp[t] = w[i-1][t];
 12:             var_decl                    // var t;
//     if (i % Nk == 0) {
//       temp = SubWord(RotWord(temp));
//       for (var t=0; t<4; t++) temp[t] ^= Rcon[i/Nk][t];
//     } else if (Nk > 6 && i%Nk == 4) {
//       temp = SubWord(temp);
//     }
//     for (var t=0; t<4; t++) w[i][t] = w[i-Nk][t] ^ temp[t];
//   }
//   return w;
// }
 13:           assignment  130    1          // tmp130 = 4: SMALLINT;
 14:           assignment  254    6          // Nb = tmp130 : TYPEOF(tmp130);
// 
//   var Nk = key.length/4  // key length (in words): 4/6/8 for 128/192/256-bit keys
 15:           assignment  130    5          // tmp130 = 'length': STRING;
 16:          prop_getter  131  254          // tmp131 = key[tmp130];
 17:           assignment  132    1          // tmp132 = 4: SMALLINT;
// 
//   var Nr = Nk + 6;       // no of rounds: 10/12/14 for 128/192/256-bit keys
 18:             division  133  131          // tmp133 = tmp131 / tmp132;
 19:           assignment  254    6          // Nk = tmp133 : TYPEOF(tmp133);
 20:           assignment  130    6          // tmp130 = Nk : TYPEOF(Nk);
 21:           assignment  131    1          // tmp131 = 6: SMALLINT;
 22:             addition  132  130          // tmp132 = tmp130 + tmp131;
 23:           assignment  254    6          // Nr = tmp132 : TYPEOF(tmp132);
// 
//   var w = new Array(Nb*(Nr+1));
 24:          construct_n  255  254          // 
 25:           assignment  130    6          // tmp130 = Nb : TYPEOF(Nb);
 26:           assignment  131    6          // tmp131 = Nr : TYPEOF(Nr);
 27:           assignment  132    1          // tmp132 = 1: SMALLINT;
 28:             addition  133  131          // tmp133 = tmp131 + tmp132;
 29:       multiplication  134  130          // tmp134 = tmp130 * tmp133;
 30:                 meta    2  134          // 
 24:          construct_n  130  254          //  // REWRITE
 31:           assignment  254    6          // w = tmp130 : TYPEOF(tmp130);
//   var temp = new Array(4);
 32:          construct_n  255  254          // 
 33:           assignment  130    1          // tmp130 = 4: SMALLINT;
 34:                 meta    2  130          // 
 32:          construct_n  130  254          //  // REWRITE
 35:           assignment  254    6          // temp = tmp130 : TYPEOF(tmp130);
//   for (var i=0; i<Nk; i++) {
 36:           assignment  130    1          // tmp130 = 0: SMALLINT;
 37:           assignment  254    6          // i = tmp130 : TYPEOF(tmp130);
 38:             jmp_down  255               // goto 65573;
//     var r = [key[4*i], key[4*i+1], key[4*i+2], key[4*i+3]];
 39:           array_decl  255               // 
 40:           assignment  130    1          // tmp130 = 4: SMALLINT;
 41:       multiplication  131  130          // tmp131 = tmp130 * i;
 42:          prop_getter  132  254          // tmp132 = key[tmp131];
 43:                 meta    2  132          // 
 44:           assignment  130    1          // tmp130 = 4: SMALLINT;
 45:       multiplication  131  130          // tmp131 = tmp130 * i;
 46:           assignment  132    1          // tmp132 = 1: SMALLINT;
 47:             addition  133  131          // tmp133 = tmp131 + tmp132;
 48:          prop_getter  134  254          // tmp134 = key[tmp133];
 49:                 meta    2  134          // 
 50:           assignment  130    1          // tmp130 = 4: SMALLINT;
 51:       multiplication  131  130          // tmp131 = tmp130 * i;
 52:           assignment  132    1          // tmp132 = 2: SMALLINT;
 53:             addition  133  131          // tmp133 = tmp131 + tmp132;
 54:          prop_getter  134  254          // tmp134 = key[tmp133];
 55:                 meta    2  134          // 
 56:           assignment  130    1          // tmp130 = 4: SMALLINT;
 57:       multiplication  131  130          // tmp131 = tmp130 * i;
 58:           assignment  132    1          // tmp132 = 3: SMALLINT;
 59:             addition  133  131          // tmp133 = tmp131 + tmp132;
 60:          prop_getter  134  254          // tmp134 = key[tmp133];
 61:                 meta    2  134          // 
 39:           array_decl  130               //  // REWRITE
 62:           assignment  254    6          // r = tmp130 : TYPEOF(tmp130);
//     w[i] = r;
 63:          prop_getter  130  254          // tmp130 = w[i];
 63:          prop_setter  254  254          // w[i] = r;
 64:           assignment  131    6          // tmp131 = r : TYPEOF(r);
//   }
 65:            post_incr  132               // tmp132 = i++;
 38:             jmp_down    0               // goto 66; // REWRITE
 66:           assignment  133    6          // tmp133 = i : TYPEOF(i);
 67:            less_than  134  133          // tmp134 = tmp133 < Nk;
 68:       is_true_jmp_up  134    0          // if (tmp134) goto 39;
//   for (var i=Nk; i<(Nb*(Nr+1)); i++) {
 69:           assignment  254    6          // i = Nk : TYPEOF(Nk);
 70:             jmp_down  255               // goto 65605;
//     w[i] = new Array(4);
 71:          prop_getter  130  254          // tmp130 = w[i];
 71:          construct_n  255  254          // 
 72:           assignment  131    1          // tmp131 = 4: SMALLINT;
 73:                 meta    2  131          // 
 71:          construct_n  131  254          //  // REWRITE
 74:          prop_setter  254  254          // w[i] = tmp131;
//     for (var t=0; t<4; t++) temp[t] = w[i-1][t];
 75:           assignment  130    1          // tmp130 = 0: SMALLINT;
 76:           assignment  254    6          // t = tmp130 : TYPEOF(tmp130);
 77:             jmp_down  255               // goto 65612;
 78:          prop_getter  130  254          // tmp130 = temp[t];
 78:           assignment  131    6          // tmp131 = i : TYPEOF(i);
 79:           assignment  132    1          // tmp132 = 1: SMALLINT;
 80:         substraction  133  131          // tmp133 = tmp131 - tmp132;
 81:          prop_getter  134  254          // tmp134 = w[tmp133];
 82:          prop_getter  135  134          // tmp135 = tmp134[t];
 83:          prop_setter  254  254          // temp[t] = tmp135;
 84:            post_incr  136               // tmp136 = t++;
 77:             jmp_down    0               // goto 85; // REWRITE
 85:           assignment  137    6          // tmp137 = t : TYPEOF(t);
 86:           assignment  138    1          // tmp138 = 4: SMALLINT;
 87:            less_than  139  137          // tmp139 = tmp137 < tmp138;
 88:       is_true_jmp_up  139    0          // if (tmp139) goto 78;
//     if (i % Nk == 0) {
 89:           assignment  130    6          // tmp130 = i : TYPEOF(i);
 90:            remainder  131  130          // tmp131 = tmp130 %% Nk;
 91:           assignment  132    1          // tmp132 = 0: SMALLINT;
 92:          equal_value  133  131          // tmp133 = tmp131 == tmp132;
 93:    is_false_jmp_down  133  255          // if (tmp133 == false) goto 65628;
//       temp = SubWord(RotWord(temp));
 94:               call_n  255  254          // 
 95:               call_n  255  254          // 
 96:                 meta    2  254          // 
 95:               call_n  130  254          //  // REWRITE
 97:                 meta    2  130          // tmp130 = hz (hz, tmp130);
 94:               call_n  130  254          //  // REWRITE
 98:           assignment  254    6          // temp = tmp130 : TYPEOF(tmp130);
//       for (var t=0; t<4; t++) temp[t] ^= Rcon[i/Nk][t];
 99:           assignment  130    1          // tmp130 = 0: SMALLINT;
100:           assignment  254    6          // t = tmp130 : TYPEOF(tmp130);
101:             jmp_down  255               // goto 65636;
102:          prop_getter  130  254          // tmp130 = temp[t];
102:           assignment  131    6          // tmp131 = i : TYPEOF(i);
103:             division  132  131          // tmp132 = tmp131 / Nk;
104:          prop_getter  133  254          // tmp133 = Rcon[tmp132];
105:          prop_getter  134  133          // tmp134 = tmp133[t];
106:          prop_getter  135  254          // tmp135 = temp[t];
107:                b_xor  135  135          // tmp135 = tmp135 ^ tmp134;
108:          prop_setter  254  254          // temp[t] = tmp135;
109:            post_incr  136               // tmp136 = t++;
101:             jmp_down    0               // goto 110; // REWRITE
110:           assignment  137    6          // tmp137 = t : TYPEOF(t);
111:           assignment  138    1          // tmp138 = 4: SMALLINT;
112:            less_than  139  137          // tmp139 = tmp137 < tmp138;
113:       is_true_jmp_up  139    0          // if (tmp139) goto 102;
//     } else if (Nk > 6 && i%Nk == 4) {
114:             jmp_down  255               // goto 65649;
 93:    is_false_jmp_down  133    0          // if (tmp133 == false) goto 115; // REWRITE
115:           assignment  130    6          // tmp130 = Nk : TYPEOF(Nk);
116:           assignment  131    1          // tmp131 = 6: SMALLINT;
117:         greater_than  132  130          // tmp132 = tmp130 > tmp131;
118:           assignment  133    6          // tmp133 = tmp132 : TYPEOF(tmp132);
119:    is_false_jmp_down  133  255          // if (tmp133 == false) goto 65654;
120:           assignment  134    6          // tmp134 = i : TYPEOF(i);
121:            remainder  135  134          // tmp135 = tmp134 %% Nk;
122:           assignment  136    1          // tmp136 = 4: SMALLINT;
123:          equal_value  137  135          // tmp137 = tmp135 == tmp136;
124:           assignment  133    6          // tmp133 = tmp137 : TYPEOF(tmp137);
119:    is_false_jmp_down  133    0          // if (tmp133 == false) goto 125; // REWRITE
125:    is_false_jmp_down  133  255          // if (tmp133 == false) goto 65660;
//       temp = SubWord(temp);
126:               call_n  255  254          // 
127:                 meta    2  254          // 
126:               call_n  130  254          //  // REWRITE
128:           assignment  254    6          // temp = tmp130 : TYPEOF(tmp130);
//     }
//     for (var t=0; t<4; t++) w[i][t] = w[i-Nk][t] ^ temp[t];
125:    is_false_jmp_down  133    0          // if (tmp133 == false) goto 129; // REWRITE
114:             jmp_down    0               // goto 129; // REWRITE
129:           assignment  130    1          // tmp130 = 0: SMALLINT;
130:           assignment  254    6          // t = tmp130 : TYPEOF(tmp130);
131:             jmp_down  255               // goto 65666;
132:          prop_getter  130  254          // tmp130 = w[i];
133:          prop_getter  131  130          // tmp131 = tmp130[t];
133:           assignment  132    6          // tmp132 = i : TYPEOF(i);
134:         substraction  133  132          // tmp133 = tmp132 - Nk;
135:          prop_getter  134  254          // tmp134 = w[tmp133];
136:          prop_getter  135  134          // tmp135 = tmp134[t];
137:          prop_getter  136  254          // tmp136 = temp[t];
138:                b_xor  137  135          // tmp137 = tmp135 ^ tmp136;
139:          prop_setter  130  254          // tmp130[t] = tmp137;
140:            post_incr  138               // tmp138 = t++;
131:             jmp_down    0               // goto 141; // REWRITE
141:           assignment  139    6          // tmp139 = t : TYPEOF(t);
142:           assignment  140    1          // tmp140 = 4: SMALLINT;
143:            less_than  141  139          // tmp141 = tmp139 < tmp140;
144:       is_true_jmp_up  141    0          // if (tmp141) goto 132;
//   }
145:            post_incr  142               // tmp142 = i++;
 70:             jmp_down    0               // goto 146; // REWRITE
146:           assignment  143    6          // tmp143 = i : TYPEOF(i);
147:           assignment  144    6          // tmp144 = Nb : TYPEOF(Nb);
148:           assignment  145    6          // tmp145 = Nr : TYPEOF(Nr);
149:           assignment  146    1          // tmp146 = 1: SMALLINT;
150:             addition  147  145          // tmp147 = tmp145 + tmp146;
151:       multiplication  148  144          // tmp148 = tmp144 * tmp147;
152:            less_than  149  143          // tmp149 = tmp143 < tmp148;
153:       is_true_jmp_up  149    0          // if (tmp149) goto 71;
//   return w;
154:               retval                    // return w;
// }
  4:         reg_var_decl  128               // var tmp128 .. tmp149; // REWRITE
155:                  ret                    // ret;
  2:                 meta    7    0          // function end: 156; // REWRITE
// function SubWord(w) {    // apply SBox to 4-byte word w
  0:          func_decl_n  254               // 
  1:                 meta    2  254          // 
  0:          func_decl_n  254               //  // REWRITE
  2:                 meta    7  255          // function end: 65537;
// 
//   for (var i=0; i<4; i++) w[i] = Sbox[w[i]];
  3:                 meta   12  255          // [to be rewritten]
//   return w;
// }
  3:                 meta   12    6          // [no 'arguments'] [no 'eval']  // REWRITE
  4:         reg_var_decl  128               // var tmp128 .. tmp255;
  5:             var_decl                    // var i;
//   return w;
// }
  6:           assignment  130    1          // tmp130 = 0: SMALLINT;
  7:           assignment  254    6          // i = tmp130 : TYPEOF(tmp130);
  8:             jmp_down  255               // goto 65543;
  9:          prop_getter  130  254          // tmp130 = w[i];
  9:          prop_getter  131  254          // tmp131 = w[i];
 10:          prop_getter  132  254          // tmp132 = Sbox[tmp131];
 11:          prop_setter  254  254          // w[i] = tmp132;
 12:            post_incr  133               // tmp133 = i++;
  8:             jmp_down    0               // goto 13; // REWRITE
 13:           assignment  134    6          // tmp134 = i : TYPEOF(i);
 14:           assignment  135    1          // tmp135 = 4: SMALLINT;
 15:            less_than  136  134          // tmp136 = tmp134 < tmp135;
 16:       is_true_jmp_up  136    0          // if (tmp136) goto 9;
//   return w;
 17:               retval                    // return w;
// }
  4:         reg_var_decl  128               // var tmp128 .. tmp136; // REWRITE
 18:                  ret                    // ret;
  2:                 meta    7    0          // function end: 19; // REWRITE
// function RotWord(w) {    // rotate 4-byte word w left by one byte
  0:          func_decl_n  254               // 
  1:                 meta    2  254          // 
  0:          func_decl_n  254               //  // REWRITE
  2:                 meta    7  255          // function end: 65537;
// 
//   w[4] = w[0];
  3:                 meta   12  255          // [to be rewritten]
//   for (var i=0; i<4; i++) w[i] = w[i+1];
//   return w;
// }
  3:                 meta   12    6          // [no 'arguments'] [no 'eval']  // REWRITE
  4:         reg_var_decl  128               // var tmp128 .. tmp255;
//   for (var i=0; i<4; i++) w[i] = w[i+1];
  5:             var_decl                    // var i;
//   return w;
// }
  6:           assignment  130    1          // tmp130 = 4: SMALLINT;
  7:          prop_getter  131  254          // tmp131 = w[tmp130];
  7:           assignment  132    1          // tmp132 = 0: SMALLINT;
  8:          prop_getter  133  254          // tmp133 = w[tmp132];
  9:          prop_setter  254  130          // w[tmp130] = tmp133;
//   for (var i=0; i<4; i++) w[i] = w[i+1];
 10:           assignment  130    1          // tmp130 = 0: SMALLINT;
 11:           assignment  254    6          // i = tmp130 : TYPEOF(tmp130);
 12:             jmp_down  255               // goto 65547;
 13:          prop_getter  130  254          // tmp130 = w[i];
 13:           assignment  131    6          // tmp131 = i : TYPEOF(i);
 14:           assignment  132    1          // tmp132 = 1: SMALLINT;
 15:             addition  133  131          // tmp133 = tmp131 + tmp132;
 16:          prop_getter  134  254          // tmp134 = w[tmp133];
 17:          prop_setter  254  254          // w[i] = tmp134;
 18:            post_incr  135               // tmp135 = i++;
 12:             jmp_down    0               // goto 19; // REWRITE
 19:           assignment  136    6          // tmp136 = i : TYPEOF(i);
 20:           assignment  137    1          // tmp137 = 4: SMALLINT;
 21:            less_than  138  136          // tmp138 = tmp136 < tmp137;
 22:       is_true_jmp_up  138    0          // if (tmp138) goto 13;
//   return w;
 23:               retval                    // return w;
// }
  4:         reg_var_decl  128               // var tmp128 .. tmp138; // REWRITE
 24:                  ret                    // ret;
  2:                 meta    7    0          // function end: 25; // REWRITE
// // Sbox is pre-computed multiplicative inverse in GF(2^8) used in SubBytes and KeyExpansion [_5.1.1]
// 
// var Sbox =  [0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,
  9:           array_decl  255               // 
 10:           assignment  130    1          // tmp130 = 99: SMALLINT;
 11:                 meta    2  130          // 
 12:           assignment  130    1          // tmp130 = 124: SMALLINT;
 13:                 meta    2  130          // 
 14:           assignment  130    1          // tmp130 = 119: SMALLINT;
 15:                 meta    2  130          // 
 16:           assignment  130    1          // tmp130 = 123: SMALLINT;
 17:                 meta    2  130          // 
 18:           assignment  130    1          // tmp130 = 242: SMALLINT;
 19:                 meta    2  130          // 
 20:           assignment  130    1          // tmp130 = 107: SMALLINT;
 21:                 meta    2  130          // 
 22:           assignment  130    1          // tmp130 = 111: SMALLINT;
 23:                 meta    2  130          // 
 24:           assignment  130    1          // tmp130 = 197: SMALLINT;
 25:                 meta    2  130          // 
 26:           assignment  130    1          // tmp130 = 48: SMALLINT;
 27:                 meta    2  130          // 
 28:           assignment  130    1          // tmp130 = 1: SMALLINT;
 29:                 meta    2  130          // 
 30:           assignment  130    1          // tmp130 = 103: SMALLINT;
 31:                 meta    2  130          // 
 32:           assignment  130    1          // tmp130 = 43: SMALLINT;
 33:                 meta    2  130          // 
 34:           assignment  130    1          // tmp130 = 254: SMALLINT;
 35:                 meta    2  130          // 
 36:           assignment  130    1          // tmp130 = 215: SMALLINT;
 37:                 meta    2  130          // 
 38:           assignment  130    1          // tmp130 = 171: SMALLINT;
 39:                 meta    2  130          // 
 40:           assignment  130    1          // tmp130 = 118: SMALLINT;
 41:                 meta    2  130          // 
//              0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,
 42:           assignment  130    1          // tmp130 = 202: SMALLINT;
 43:                 meta    2  130          // 
 44:           assignment  130    1          // tmp130 = 130: SMALLINT;
 45:                 meta    2  130          // 
 46:           assignment  130    1          // tmp130 = 201: SMALLINT;
 47:                 meta    2  130          // 
 48:           assignment  130    1          // tmp130 = 125: SMALLINT;
 49:                 meta    2  130          // 
 50:           assignment  130    1          // tmp130 = 250: SMALLINT;
 51:                 meta    2  130          // 
 52:           assignment  130    1          // tmp130 = 89: SMALLINT;
 53:                 meta    2  130          // 
 54:           assignment  130    1          // tmp130 = 71: SMALLINT;
 55:                 meta    2  130          // 
 56:           assignment  130    1          // tmp130 = 240: SMALLINT;
 57:                 meta    2  130          // 
 58:           assignment  130    1          // tmp130 = 173: SMALLINT;
 59:                 meta    2  130          // 
 60:           assignment  130    1          // tmp130 = 212: SMALLINT;
 61:                 meta    2  130          // 
 62:           assignment  130    1          // tmp130 = 162: SMALLINT;
 63:                 meta    2  130          // 
 64:           assignment  130    1          // tmp130 = 175: SMALLINT;
 65:                 meta    2  130          // 
 66:           assignment  130    1          // tmp130 = 156: SMALLINT;
 67:                 meta    2  130          // 
 68:           assignment  130    1          // tmp130 = 164: SMALLINT;
 69:                 meta    2  130          // 
 70:           assignment  130    1          // tmp130 = 114: SMALLINT;
 71:                 meta    2  130          // 
 72:           assignment  130    1          // tmp130 = 192: SMALLINT;
 73:                 meta    2  130          // 
//              0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,
 74:           assignment  130    1          // tmp130 = 183: SMALLINT;
 75:                 meta    2  130          // 
 76:           assignment  130    1          // tmp130 = 253: SMALLINT;
 77:                 meta    2  130          // 
 78:           assignment  130    1          // tmp130 = 147: SMALLINT;
 79:                 meta    2  130          // 
 80:           assignment  130    1          // tmp130 = 38: SMALLINT;
 81:                 meta    2  130          // 
 82:           assignment  130    1          // tmp130 = 54: SMALLINT;
 83:                 meta    2  130          // 
 84:           assignment  130    1          // tmp130 = 63: SMALLINT;
 85:                 meta    2  130          // 
 86:           assignment  130    1          // tmp130 = 247: SMALLINT;
 87:                 meta    2  130          // 
 88:           assignment  130    1          // tmp130 = 204: SMALLINT;
 89:                 meta    2  130          // 
 90:           assignment  130    1          // tmp130 = 52: SMALLINT;
 91:                 meta    2  130          // 
 92:           assignment  130    1          // tmp130 = 165: SMALLINT;
 93:                 meta    2  130          // 
 94:           assignment  130    1          // tmp130 = 229: SMALLINT;
 95:                 meta    2  130          // 
 96:           assignment  130    1          // tmp130 = 241: SMALLINT;
 97:                 meta    2  130          // 
 98:           assignment  130    1          // tmp130 = 113: SMALLINT;
 99:                 meta    2  130          // 
100:           assignment  130    1          // tmp130 = 216: SMALLINT;
101:                 meta    2  130          // 
102:           assignment  130    1          // tmp130 = 49: SMALLINT;
103:                 meta    2  130          // 
104:           assignment  130    1          // tmp130 = 21: SMALLINT;
105:                 meta    2  130          // 
//              0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,
106:           assignment  130    1          // tmp130 = 4: SMALLINT;
107:                 meta    2  130          // 
108:           assignment  130    1          // tmp130 = 199: SMALLINT;
109:                 meta    2  130          // 
110:           assignment  130    1          // tmp130 = 35: SMALLINT;
111:                 meta    2  130          // 
112:           assignment  130    1          // tmp130 = 195: SMALLINT;
113:                 meta    2  130          // 
114:           assignment  130    1          // tmp130 = 24: SMALLINT;
115:                 meta    2  130          // 
116:           assignment  130    1          // tmp130 = 150: SMALLINT;
117:                 meta    2  130          // 
118:           assignment  130    1          // tmp130 = 5: SMALLINT;
119:                 meta    2  130          // 
120:           assignment  130    1          // tmp130 = 154: SMALLINT;
121:                 meta    2  130          // 
122:           assignment  130    1          // tmp130 = 7: SMALLINT;
123:                 meta    2  130          // 
124:           assignment  130    1          // tmp130 = 18: SMALLINT;
125:                 meta    2  130          // 
126:           assignment  130    1          // tmp130 = 128: SMALLINT;
127:                 meta    2  130          // 
128:           assignment  130    1          // tmp130 = 226: SMALLINT;
129:                 meta    2  130          // 
130:           assignment  130    1          // tmp130 = 235: SMALLINT;
131:                 meta    2  130          // 
132:           assignment  130    1          // tmp130 = 39: SMALLINT;
133:                 meta    2  130          // 
134:           assignment  130    1          // tmp130 = 178: SMALLINT;
135:                 meta    2  130          // 
136:           assignment  130    1          // tmp130 = 117: SMALLINT;
137:                 meta    2  130          // 
//              0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,
138:           assignment  130    1          // tmp130 = 9: SMALLINT;
139:                 meta    2  130          // 
140:           assignment  130    1          // tmp130 = 131: SMALLINT;
141:                 meta    2  130          // 
142:           assignment  130    1          // tmp130 = 44: SMALLINT;
143:                 meta    2  130          // 
144:           assignment  130    1          // tmp130 = 26: SMALLINT;
145:                 meta    2  130          // 
146:           assignment  130    1          // tmp130 = 27: SMALLINT;
147:                 meta    2  130          // 
148:           assignment  130    1          // tmp130 = 110: SMALLINT;
149:                 meta    2  130          // 
150:           assignment  130    1          // tmp130 = 90: SMALLINT;
151:                 meta    2  130          // 
152:           assignment  130    1          // tmp130 = 160: SMALLINT;
153:                 meta    2  130          // 
154:           assignment  130    1          // tmp130 = 82: SMALLINT;
155:                 meta    2  130          // 
156:           assignment  130    1          // tmp130 = 59: SMALLINT;
157:                 meta    2  130          // 
158:           assignment  130    1          // tmp130 = 214: SMALLINT;
159:                 meta    2  130          // 
160:           assignment  130    1          // tmp130 = 179: SMALLINT;
161:                 meta    2  130          // 
162:           assignment  130    1          // tmp130 = 41: SMALLINT;
163:                 meta    2  130          // 
164:           assignment  130    1          // tmp130 = 227: SMALLINT;
165:                 meta    2  130          // 
166:           assignment  130    1          // tmp130 = 47: SMALLINT;
167:                 meta    2  130          // 
168:           assignment  130    1          // tmp130 = 132: SMALLINT;
169:                 meta    2  130          // 
//              0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,
170:           assignment  130    1          // tmp130 = 83: SMALLINT;
171:                 meta    2  130          // 
172:           assignment  130    1          // tmp130 = 209: SMALLINT;
173:                 meta    2  130          // 
174:           assignment  130    1          // tmp130 = 0: SMALLINT;
175:                 meta    2  130          // 
176:           assignment  130    1          // tmp130 = 237: SMALLINT;
177:                 meta    2  130          // 
178:           assignment  130    1          // tmp130 = 32: SMALLINT;
179:                 meta    2  130          // 
180:           assignment  130    1          // tmp130 = 252: SMALLINT;
181:                 meta    2  130          // 
182:           assignment  130    1          // tmp130 = 177: SMALLINT;
183:                 meta    2  130          // 
184:           assignment  130    1          // tmp130 = 91: SMALLINT;
185:                 meta    2  130          // 
186:           assignment  130    1          // tmp130 = 106: SMALLINT;
187:                 meta    2  130          // 
188:           assignment  130    1          // tmp130 = 203: SMALLINT;
189:                 meta    2  130          // 
190:           assignment  130    1          // tmp130 = 190: SMALLINT;
191:                 meta    2  130          // 
192:           assignment  130    1          // tmp130 = 57: SMALLINT;
193:                 meta    2  130          // 
194:           assignment  130    1          // tmp130 = 74: SMALLINT;
195:                 meta    2  130          // 
196:           assignment  130    1          // tmp130 = 76: SMALLINT;
197:                 meta    2  130          // 
198:           assignment  130    1          // tmp130 = 88: SMALLINT;
199:                 meta    2  130          // 
200:           assignment  130    1          // tmp130 = 207: SMALLINT;
201:                 meta    2  130          // 
//              0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,
202:           assignment  130    1          // tmp130 = 208: SMALLINT;
203:                 meta    2  130          // 
204:           assignment  130    1          // tmp130 = 239: SMALLINT;
205:                 meta    2  130          // 
206:           assignment  130    1          // tmp130 = 170: SMALLINT;
207:                 meta    2  130          // 
208:           assignment  130    1          // tmp130 = 251: SMALLINT;
209:                 meta    2  130          // 
210:           assignment  130    1          // tmp130 = 67: SMALLINT;
211:                 meta    2  130          // 
212:           assignment  130    1          // tmp130 = 77: SMALLINT;
213:                 meta    2  130          // 
214:           assignment  130    1          // tmp130 = 51: SMALLINT;
215:                 meta    2  130          // 
216:           assignment  130    1          // tmp130 = 133: SMALLINT;
217:                 meta    2  130          // 
218:           assignment  130    1          // tmp130 = 69: SMALLINT;
219:                 meta    2  130          // 
220:           assignment  130    1          // tmp130 = 249: SMALLINT;
221:                 meta    2  130          // 
222:           assignment  130    1          // tmp130 = 2: SMALLINT;
223:                 meta    2  130          // 
224:           assignment  130    1          // tmp130 = 127: SMALLINT;
225:                 meta    2  130          // 
226:           assignment  130    1          // tmp130 = 80: SMALLINT;
227:                 meta    2  130          // 
228:           assignment  130    1          // tmp130 = 60: SMALLINT;
229:                 meta    2  130          // 
230:           assignment  130    1          // tmp130 = 159: SMALLINT;
231:                 meta    2  130          // 
232:           assignment  130    1          // tmp130 = 168: SMALLINT;
233:                 meta    2  130          // 
//              0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,
234:           assignment  130    1          // tmp130 = 81: SMALLINT;
235:                 meta    2  130          // 
236:           assignment  130    1          // tmp130 = 163: SMALLINT;
237:                 meta    2  130          // 
238:           assignment  130    1          // tmp130 = 64: SMALLINT;
239:                 meta    2  130          // 
240:           assignment  130    1          // tmp130 = 143: SMALLINT;
241:                 meta    2  130          // 
242:           assignment  130    1          // tmp130 = 146: SMALLINT;
243:                 meta    2  130          // 
244:           assignment  130    1          // tmp130 = 157: SMALLINT;
245:                 meta    2  130          // 
246:           assignment  130    1          // tmp130 = 56: SMALLINT;
247:                 meta    2  130          // 
248:           assignment  130    1          // tmp130 = 245: SMALLINT;
249:                 meta    2  130          // 
250:           assignment  130    1          // tmp130 = 188: SMALLINT;
251:                 meta    2  130          // 
252:           assignment  130    1          // tmp130 = 182: SMALLINT;
253:                 meta    2  130          // 
254:           assignment  130    1          // tmp130 = 218: SMALLINT;
255:                 meta    2  130          // 
256:           assignment  130    1          // tmp130 = 33: SMALLINT;
257:                 meta    2  130          // 
258:           assignment  130    1          // tmp130 = 16: SMALLINT;
259:                 meta    2  130          // 
260:           assignment  130    1          // tmp130 = 255: SMALLINT;
261:                 meta    2  130          // 
262:           assignment  130    1          // tmp130 = 243: SMALLINT;
263:                 meta    2  130          // 
264:           assignment  130    1          // tmp130 = 210: SMALLINT;
265:                 meta    2  130          // 
//              0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,
266:           assignment  130    1          // tmp130 = 205: SMALLINT;
267:                 meta    2  130          // 
268:           assignment  130    1          // tmp130 = 12: SMALLINT;
269:                 meta    2  130          // 
270:           assignment  130    1          // tmp130 = 19: SMALLINT;
271:                 meta    2  130          // 
272:           assignment  130    1          // tmp130 = 236: SMALLINT;
273:                 meta    2  130          // 
274:           assignment  130    1          // tmp130 = 95: SMALLINT;
275:                 meta    2  130          // 
276:           assignment  130    1          // tmp130 = 151: SMALLINT;
277:                 meta    2  130          // 
278:           assignment  130    1          // tmp130 = 68: SMALLINT;
279:                 meta    2  130          // 
280:           assignment  130    1          // tmp130 = 23: SMALLINT;
281:                 meta    2  130          // 
282:           assignment  130    1          // tmp130 = 196: SMALLINT;
283:                 meta    2  130          // 
284:           assignment  130    1          // tmp130 = 167: SMALLINT;
285:                 meta    2  130          // 
286:           assignment  130    1          // tmp130 = 126: SMALLINT;
287:                 meta    2  130          // 
288:           assignment  130    1          // tmp130 = 61: SMALLINT;
289:                 meta    2  130          // 
290:           assignment  130    1          // tmp130 = 100: SMALLINT;
291:                 meta    2  130          // 
292:           assignment  130    1          // tmp130 = 93: SMALLINT;
293:                 meta    2  130          // 
294:           assignment  130    1          // tmp130 = 25: SMALLINT;
295:                 meta    2  130          // 
296:           assignment  130    1          // tmp130 = 115: SMALLINT;
297:                 meta    2  130          // 
//              0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,
298:           assignment  130    1          // tmp130 = 96: SMALLINT;
299:                 meta    2  130          // 
300:           assignment  130    1          // tmp130 = 129: SMALLINT;
301:                 meta    2  130          // 
302:           assignment  130    1          // tmp130 = 79: SMALLINT;
303:                 meta    2  130          // 
304:           assignment  130    1          // tmp130 = 220: SMALLINT;
305:                 meta    2  130          // 
306:           assignment  130    1          // tmp130 = 34: SMALLINT;
307:                 meta    2  130          // 
308:           assignment  130    1          // tmp130 = 42: SMALLINT;
309:                 meta    2  130          // 
310:           assignment  130    1          // tmp130 = 144: SMALLINT;
311:                 meta    2  130          // 
312:           assignment  130    1          // tmp130 = 136: SMALLINT;
313:                 meta    2  130          // 
314:           assignment  130    1          // tmp130 = 70: SMALLINT;
315:                 meta    2  130          // 
316:           assignment  130    1          // tmp130 = 238: SMALLINT;
317:                 meta    2  130          // 
318:           assignment  130    1          // tmp130 = 184: SMALLINT;
319:                 meta    2  130          // 
320:           assignment  130    1          // tmp130 = 20: SMALLINT;
321:                 meta    2  130          // 
322:           assignment  130    1          // tmp130 = 222: SMALLINT;
323:                 meta    2  130          // 
324:           assignment  130    1          // tmp130 = 94: SMALLINT;
325:                 meta    2  130          // 
326:           assignment  130    1          // tmp130 = 11: SMALLINT;
327:                 meta    2  130          // 
328:           assignment  130    1          // tmp130 = 219: SMALLINT;
329:                 meta    2  130          // 
//              0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,
330:           assignment  130    1          // tmp130 = 224: SMALLINT;
331:                 meta    2  130          // 
332:           assignment  130    1          // tmp130 = 50: SMALLINT;
333:                 meta    2  130          // 
334:           assignment  130    1          // tmp130 = 58: SMALLINT;
335:                 meta    2  130          // 
336:           assignment  130    1          // tmp130 = 10: SMALLINT;
337:                 meta    2  130          // 
338:           assignment  130    1          // tmp130 = 73: SMALLINT;
339:                 meta    2  130          // 
340:           assignment  130    1          // tmp130 = 6: SMALLINT;
341:                 meta    2  130          // 
342:           assignment  130    1          // tmp130 = 36: SMALLINT;
343:                 meta    2  130          // 
344:           assignment  130    1          // tmp130 = 92: SMALLINT;
345:                 meta    2  130          // 
346:           assignment  130    1          // tmp130 = 194: SMALLINT;
347:                 meta    2  130          // 
348:           assignment  130    1          // tmp130 = 211: SMALLINT;
349:                 meta    2  130          // 
350:           assignment  130    1          // tmp130 = 172: SMALLINT;
351:                 meta    2  130          // 
352:           assignment  130    1          // tmp130 = 98: SMALLINT;
353:                 meta    2  130          // 
354:           assignment  130    1          // tmp130 = 145: SMALLINT;
355:                 meta    2  130          // 
356:           assignment  130    1          // tmp130 = 149: SMALLINT;
357:                 meta    2  130          // 
358:           assignment  130    1          // tmp130 = 228: SMALLINT;
359:                 meta    2  130          // 
360:           assignment  130    1          // tmp130 = 121: SMALLINT;
361:                 meta    2  130          // 
//              0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,
362:           assignment  130    1          // tmp130 = 231: SMALLINT;
363:                 meta    2  130          // 
364:           assignment  130    1          // tmp130 = 200: SMALLINT;
365:                 meta    2  130          // 
366:           assignment  130    1          // tmp130 = 55: SMALLINT;
367:                 meta    2  130          // 
368:           assignment  130    1          // tmp130 = 109: SMALLINT;
369:                 meta    2  130          // 
370:           assignment  130    1          // tmp130 = 141: SMALLINT;
371:                 meta    2  130          // 
372:           assignment  130    1          // tmp130 = 213: SMALLINT;
373:                 meta    2  130          // 
374:           assignment  130    1          // tmp130 = 78: SMALLINT;
375:                 meta    2  130          // 
376:           assignment  130    1          // tmp130 = 169: SMALLINT;
377:                 meta    2  130          // 
378:           assignment  130    1          // tmp130 = 108: SMALLINT;
379:                 meta    2  130          // 
380:           assignment  130    1          // tmp130 = 86: SMALLINT;
381:                 meta    2  130          // 
382:           assignment  130    1          // tmp130 = 244: SMALLINT;
383:                 meta    2  130          // 
384:           assignment  130    1          // tmp130 = 234: SMALLINT;
385:                 meta    2  130          // 
386:           assignment  130    1          // tmp130 = 101: SMALLINT;
387:                 meta    2  130          // 
388:           assignment  130    1          // tmp130 = 122: SMALLINT;
389:                 meta    2  130          // 
390:           assignment  130    1          // tmp130 = 174: SMALLINT;
391:                 meta    2  130          // 
392:           assignment  130    1          // tmp130 = 8: SMALLINT;
393:                 meta    2  130          // 
//              0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,
394:           assignment  130    1          // tmp130 = 186: SMALLINT;
395:                 meta    2  130          // 
396:           assignment  130    1          // tmp130 = 120: SMALLINT;
397:                 meta    2  130          // 
398:           assignment  130    1          // tmp130 = 37: SMALLINT;
399:                 meta    2  130          // 
400:           assignment  130    1          // tmp130 = 46: SMALLINT;
401:                 meta    2  130          // 
402:           assignment  130    1          // tmp130 = 28: SMALLINT;
403:                 meta    2  130          // 
404:           assignment  130    1          // tmp130 = 166: SMALLINT;
405:                 meta    2  130          // 
406:           assignment  130    1          // tmp130 = 180: SMALLINT;
407:                 meta    2  130          // 
408:           assignment  130    1          // tmp130 = 198: SMALLINT;
409:                 meta    2  130          // 
410:           assignment  130    1          // tmp130 = 232: SMALLINT;
411:                 meta    2  130          // 
412:           assignment  130    1          // tmp130 = 221: SMALLINT;
413:                 meta    2  130          // 
414:           assignment  130    1          // tmp130 = 116: SMALLINT;
415:                 meta    2  130          // 
416:           assignment  130    1          // tmp130 = 31: SMALLINT;
417:                 meta    2  130          // 
418:           assignment  130    1          // tmp130 = 75: SMALLINT;
419:                 meta    2  130          // 
420:           assignment  130    1          // tmp130 = 189: SMALLINT;
421:                 meta    2  130          // 
422:           assignment  130    1          // tmp130 = 139: SMALLINT;
423:                 meta    2  130          // 
424:           assignment  130    1          // tmp130 = 138: SMALLINT;
425:                 meta    2  130          // 
//              0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,
426:           assignment  130    1          // tmp130 = 112: SMALLINT;
427:                 meta    2  130          // 
428:           assignment  130    1          // tmp130 = 62: SMALLINT;
429:                 meta    2  130          // 
430:           assignment  130    1          // tmp130 = 181: SMALLINT;
431:                 meta    2  130          // 
432:           assignment  130    1          // tmp130 = 102: SMALLINT;
433:                 meta    2  130          // 
434:           assignment  130    1          // tmp130 = 72: SMALLINT;
435:                 meta    2  130          // 
436:           assignment  130    1          // tmp130 = 3: SMALLINT;
437:                 meta    2  130          // 
438:           assignment  130    1          // tmp130 = 246: SMALLINT;
439:                 meta    2  130          // 
440:           assignment  130    1          // tmp130 = 14: SMALLINT;
441:                 meta    2  130          // 
442:           assignment  130    1          // tmp130 = 97: SMALLINT;
443:                 meta    2  130          // 
444:           assignment  130    1          // tmp130 = 53: SMALLINT;
445:                 meta    2  130          // 
446:           assignment  130    1          // tmp130 = 87: SMALLINT;
447:                 meta    2  130          // 
448:           assignment  130    1          // tmp130 = 185: SMALLINT;
449:                 meta    2  130          // 
450:           assignment  130    1          // tmp130 = 134: SMALLINT;
451:                 meta    2  130          // 
452:           assignment  130    1          // tmp130 = 193: SMALLINT;
453:                 meta    2  130          // 
454:           assignment  130    1          // tmp130 = 29: SMALLINT;
455:                 meta    2  130          // 
456:           assignment  130    1          // tmp130 = 158: SMALLINT;
457:                 meta    2  130          // 
//              0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,
458:           assignment  130    1          // tmp130 = 225: SMALLINT;
459:                 meta    2  130          // 
460:           assignment  130    1          // tmp130 = 248: SMALLINT;
461:                 meta    2  130          // 
462:           assignment  130    1          // tmp130 = 152: SMALLINT;
463:                 meta    2  130          // 
464:           assignment  130    1          // tmp130 = 17: SMALLINT;
465:                 meta    2  130          // 
466:           assignment  130    1          // tmp130 = 105: SMALLINT;
467:                 meta    2  130          // 
468:           assignment  130    1          // tmp130 = 217: SMALLINT;
469:                 meta    2  130          // 
470:           assignment  130    1          // tmp130 = 142: SMALLINT;
471:                 meta    2  130          // 
472:           assignment  130    1          // tmp130 = 148: SMALLINT;
473:                 meta    2  130          // 
474:           assignment  130    1          // tmp130 = 155: SMALLINT;
475:                 meta    2  130          // 
476:           assignment  130    1          // tmp130 = 30: SMALLINT;
477:                 meta    2  130          // 
478:           assignment  130    1          // tmp130 = 135: SMALLINT;
479:                 meta    2  130          // 
480:           assignment  130    1          // tmp130 = 233: SMALLINT;
481:                 meta    2  130          // 
482:           assignment  130    1          // tmp130 = 206: SMALLINT;
483:                 meta    2  130          // 
484:           assignment  130    1          // tmp130 = 85: SMALLINT;
485:                 meta    2  130          // 
486:           assignment  130    1          // tmp130 = 40: SMALLINT;
487:                 meta    2  130          // 
488:           assignment  130    1          // tmp130 = 223: SMALLINT;
489:                 meta    2  130          // 
//              0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16];
490:           assignment  130    1          // tmp130 = 140: SMALLINT;
491:                 meta    2  130          // 
492:           assignment  130    1          // tmp130 = 161: SMALLINT;
493:                 meta    2  130          // 
494:           assignment  130    1          // tmp130 = 137: SMALLINT;
495:                 meta    2  130          // 
496:           assignment  130    1          // tmp130 = 13: SMALLINT;
497:                 meta    2  130          // 
498:           assignment  130    1          // tmp130 = 191: SMALLINT;
499:                 meta    2  130          // 
500:           assignment  130    1          // tmp130 = 230: SMALLINT;
501:                 meta    2  130          // 
502:           assignment  130    1          // tmp130 = 66: SMALLINT;
503:                 meta    2  130          // 
504:           assignment  130    1          // tmp130 = 104: SMALLINT;
505:                 meta    2  130          // 
506:           assignment  130    1          // tmp130 = 65: SMALLINT;
507:                 meta    2  130          // 
508:           assignment  130    1          // tmp130 = 153: SMALLINT;
509:                 meta    2  130          // 
510:           assignment  130    1          // tmp130 = 45: SMALLINT;
511:                 meta    2  130          // 
512:           assignment  130    1          // tmp130 = 15: SMALLINT;
513:                 meta    2  130          // 
514:           assignment  130    1          // tmp130 = 176: SMALLINT;
515:                 meta    2  130          // 
516:           assignment  130    1          // tmp130 = 84: SMALLINT;
517:                 meta    2  130          // 
518:           assignment  130    1          // tmp130 = 187: SMALLINT;
519:                 meta    2  130          // tmp255 = [tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130, tmp130];
520:           assignment  130    1          // tmp130 = 22: SMALLINT;
521:                 meta    2  130          // 
  9:           array_decl  130               // tmp130 = []; // REWRITE
522:           assignment  254    6          // Sbox = tmp130 : TYPEOF(tmp130);
// // Rcon is Round Constant used for the Key Expansion [1st col is 2^(r-1) in GF(2^8)] [_5.2]
// 
// var Rcon = [ [0x00, 0x00, 0x00, 0x00],
523:           array_decl  255               // 
524:           array_decl  255               // 
525:           assignment  130    1          // tmp130 = 0: SMALLINT;
526:                 meta    2  130          // 
527:           assignment  130    1          // tmp130 = 0: SMALLINT;
528:                 meta    2  130          // 
529:           assignment  130    1          // tmp130 = 0: SMALLINT;
530:                 meta    2  130          // 
531:           assignment  130    1          // tmp130 = 0: SMALLINT;
532:                 meta    2  130          // 
524:           array_decl  130               //  // REWRITE
533:                 meta    2  130          // 
//              [0x01, 0x00, 0x00, 0x00],
534:           array_decl  255               // 
535:           assignment  130    1          // tmp130 = 1: SMALLINT;
536:                 meta    2  130          // 
537:           assignment  130    1          // tmp130 = 0: SMALLINT;
538:                 meta    2  130          // 
539:           assignment  130    1          // tmp130 = 0: SMALLINT;
540:                 meta    2  130          // 
541:           assignment  130    1          // tmp130 = 0: SMALLINT;
542:                 meta    2  130          // 
534:           array_decl  130               //  // REWRITE
543:                 meta    2  130          // 
//              [0x02, 0x00, 0x00, 0x00],
544:           array_decl  255               // 
545:           assignment  130    1          // tmp130 = 2: SMALLINT;
546:                 meta    2  130          // 
547:           assignment  130    1          // tmp130 = 0: SMALLINT;
548:                 meta    2  130          // 
549:           assignment  130    1          // tmp130 = 0: SMALLINT;
550:                 meta    2  130          // 
551:           assignment  130    1          // tmp130 = 0: SMALLINT;
552:                 meta    2  130          // 
544:           array_decl  130               //  // REWRITE
553:                 meta    2  130          // 
//              [0x04, 0x00, 0x00, 0x00],
554:           array_decl  255               // 
555:           assignment  130    1          // tmp130 = 4: SMALLINT;
556:                 meta    2  130          // 
557:           assignment  130    1          // tmp130 = 0: SMALLINT;
558:                 meta    2  130          // 
559:           assignment  130    1          // tmp130 = 0: SMALLINT;
560:                 meta    2  130          // 
561:           assignment  130    1          // tmp130 = 0: SMALLINT;
562:                 meta    2  130          // 
554:           array_decl  130               //  // REWRITE
563:                 meta    2  130          // 
//              [0x08, 0x00, 0x00, 0x00],
564:           array_decl  255               // 
565:           assignment  130    1          // tmp130 = 8: SMALLINT;
566:                 meta    2  130          // 
567:           assignment  130    1          // tmp130 = 0: SMALLINT;
568:                 meta    2  130          // 
569:           assignment  130    1          // tmp130 = 0: SMALLINT;
570:                 meta    2  130          // 
571:           assignment  130    1          // tmp130 = 0: SMALLINT;
572:                 meta    2  130          // 
564:           array_decl  130               //  // REWRITE
573:                 meta    2  130          // 
//              [0x10, 0x00, 0x00, 0x00],
574:           array_decl  255               // 
575:           assignment  130    1          // tmp130 = 16: SMALLINT;
576:                 meta    2  130          // 
577:           assignment  130    1          // tmp130 = 0: SMALLINT;
578:                 meta    2  130          // 
579:           assignment  130    1          // tmp130 = 0: SMALLINT;
580:                 meta    2  130          // 
581:           assignment  130    1          // tmp130 = 0: SMALLINT;
582:                 meta    2  130          // 
574:           array_decl  130               //  // REWRITE
583:                 meta    2  130          // 
//              [0x20, 0x00, 0x00, 0x00],
584:           array_decl  255               // 
585:           assignment  130    1          // tmp130 = 32: SMALLINT;
586:                 meta    2  130          // 
587:           assignment  130    1          // tmp130 = 0: SMALLINT;
588:                 meta    2  130          // 
589:           assignment  130    1          // tmp130 = 0: SMALLINT;
590:                 meta    2  130          // 
591:           assignment  130    1          // tmp130 = 0: SMALLINT;
592:                 meta    2  130          // 
584:           array_decl  130               //  // REWRITE
593:                 meta    2  130          // 
//              [0x40, 0x00, 0x00, 0x00],
594:           array_decl  255               // 
595:           assignment  130    1          // tmp130 = 64: SMALLINT;
596:                 meta    2  130          // 
597:           assignment  130    1          // tmp130 = 0: SMALLINT;
598:                 meta    2  130          // 
599:           assignment  130    1          // tmp130 = 0: SMALLINT;
600:                 meta    2  130          // 
601:           assignment  130    1          // tmp130 = 0: SMALLINT;
602:                 meta    2  130          // 
594:           array_decl  130               //  // REWRITE
603:                 meta    2  130          // 
//              [0x80, 0x00, 0x00, 0x00],
604:           array_decl  255               // 
605:           assignment  130    1          // tmp130 = 128: SMALLINT;
606:                 meta    2  130          // 
607:           assignment  130    1          // tmp130 = 0: SMALLINT;
608:                 meta    2  130          // 
609:           assignment  130    1          // tmp130 = 0: SMALLINT;
610:                 meta    2  130          // 
611:           assignment  130    1          // tmp130 = 0: SMALLINT;
612:                 meta    2  130          // 
604:           array_decl  130               //  // REWRITE
613:                 meta    2  130          // 
//              [0x1b, 0x00, 0x00, 0x00],
614:           array_decl  255               // 
615:           assignment  130    1          // tmp130 = 27: SMALLINT;
616:                 meta    2  130          // 
617:           assignment  130    1          // tmp130 = 0: SMALLINT;
618:                 meta    2  130          // 
619:           assignment  130    1          // tmp130 = 0: SMALLINT;
620:                 meta    2  130          // 
621:           assignment  130    1          // tmp130 = 0: SMALLINT;
622:                 meta    2  130          // 
614:           array_decl  130               //  // REWRITE
623:                 meta    2  130          // 
//              [0x36, 0x00, 0x00, 0x00] ]; 
624:           array_decl  255               // 
625:           assignment  130    1          // tmp130 = 54: SMALLINT;
626:                 meta    2  130          // 
627:           assignment  130    1          // tmp130 = 0: SMALLINT;
628:                 meta    2  130          // 
629:           assignment  130    1          // tmp130 = 0: SMALLINT;
630:                 meta    2  130          // 
631:           assignment  130    1          // tmp130 = 0: SMALLINT;
632:                 meta    2  130          // 
624:           array_decl  130               //  // REWRITE
633:                 meta    2  130          // 
523:           array_decl  130               //  // REWRITE
634:           assignment  254    6          // Rcon = tmp130 : TYPEOF(tmp130);
// /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
// /* 
// 
// function AESEncryptCtr(plaintext, password, nBits) {
  0:          func_decl_n  254               // 
  1:                 meta    2  254          // 
  2:                 meta    2  254          // 
  3:                 meta    2  254          // 
  0:          func_decl_n  254               //  // REWRITE
  4:                 meta    7  255          // function end: 65539;
//   if (!(nBits==128 || nBits==192 || nBits==256)) return '';  // standard allows 128/192/256 bit keys
  5:                 meta   12  255          // [to be rewritten]
// 
//   // for this example script, generate the key by applying Cipher to 1st 16/24/32 chars of password; 
// 
//   // for real-world applications, a more secure approach would be to hash the password e.g. with SHA-1
// 
//   var nBytes = nBits/8;  // no bytes in key
// 
//   var pwBytes = new Array(nBytes);
//   for (var i=0; i<nBytes; i++) pwBytes[i] = password.charCodeAt(i) & 0xff;
//   var key = Cipher(pwBytes, KeyExpansion(pwBytes));
//   key = key.concat(key.slice(0, nBytes-16));  // key is now 16/24/32 bytes long
// 
//   // initialise counter block (NIST SP800-38A _B.2): millisecond time-stamp for nonce in 1st 8 bytes,
// 
//   // block counter in 2nd 8 bytes
// 
//   var blockSize = 16;  // block size fixed at 16 bytes / 128 bits (Nb=4) for AES
// 
//   var counterBlock = new Array(blockSize);  // block size fixed at 16 bytes / 128 bits (Nb=4) for AES
// 
//   var nonce = (new Date()).getTime();  // milliseconds since 1-Jan-1970
// 
//   // encode nonce in two stages to cater for JavaScript 32-bit limit on bitwise ops
// 
//   for (var i=0; i<4; i++) counterBlock[i] = (nonce >>> i*8) & 0xff;
//   for (var i=0; i<4; i++) counterBlock[i+4] = (nonce/0x100000000 >>> i*8) & 0xff; 
//   // generate key schedule - an expansion of the key into distinct Key Rounds for each round
// 
//   var keySchedule = KeyExpansion(key);
//   var blockCount = Math.ceil(plaintext.length/blockSize);
//   var ciphertext = new Array(blockCount);  // ciphertext as array of strings
// 
//   
//   for (var b=0; b<blockCount; b++) {
//     // set counter (block #) in last 8 bytes of counter block (leaving nonce in 1st 8 bytes)
// 
//     // again done in two stages for 32-bit ops
// 
//     for (var c=0; c<4; c++) counterBlock[15-c] = (b >>> c*8) & 0xff;
//     for (var c=0; c<4; c++) counterBlock[15-c-4] = (b/0x100000000 >>> c*8)
//     var cipherCntr = Cipher(counterBlock, keySchedule);  // -- encrypt counter block --
// 
//     
//     // calculate length of final block:
// 
//     var blockLength = b<blockCount-1 ? blockSize : (plaintext.length-1)%blockSize+1;
//     var ct = '';
//     for (var i=0; i<blockLength; i++) {  // -- xor plaintext with ciphered counter byte-by-byte --
// 
//       var plaintextByte = plaintext.charCodeAt(b*blockSize+i);
//       var cipherByte = plaintextByte ^ cipherCntr[i];
//       ct += String.fromCharCode(cipherByte);
//     }
//     // ct is now ciphertext for this block
// 
//     ciphertext[b] = escCtrlChars(ct);  // escape troublesome characters in ciphertext
// 
//   }
//   // convert the nonce to a string to go on the front of the ciphertext
// 
//   var ctrTxt = '';
//   for (var i=0; i<8; i++) ctrTxt += String.fromCharCode(counterBlock[i]);
//   ctrTxt = escCtrlChars(ctrTxt);
//   // use '-' to separate blocks, use Array.join to concatenate arrays of strings for efficiency
// 
//   return ctrTxt + '-' + ciphertext.join('-');
// }
  5:                 meta   12    6          // [no 'arguments'] [no 'eval']  // REWRITE
  6:         reg_var_decl  128               // var tmp128 .. tmp255;
// 
//   // for this example script, generate the key by applying Cipher to 1st 16/24/32 chars of password; 
// 
//   // for real-world applications, a more secure approach would be to hash the password e.g. with SHA-1
// 
//   var nBytes = nBits/8;  // no bytes in key
  7:             var_decl                    // var nBytes;
// 
//   var pwBytes = new Array(nBytes);
  8:             var_decl                    // var pwBytes;
//   for (var i=0; i<nBytes; i++) pwBytes[i] = password.charCodeAt(i) & 0xff;
  9:             var_decl                    // var i;
//   var key = Cipher(pwBytes, KeyExpansion(pwBytes));
 10:             var_decl                    // var key;
//   key = key.concat(key.slice(0, nBytes-16));  // key is now 16/24/32 bytes long
// 
//   // initialise counter block (NIST SP800-38A _B.2): millisecond time-stamp for nonce in 1st 8 bytes,
// 
//   // block counter in 2nd 8 bytes
// 
//   var blockSize = 16;  // block size fixed at 16 bytes / 128 bits (Nb=4) for AES
 11:             var_decl                    // var blockSize;
// 
//   var counterBlock = new Array(blockSize);  // block size fixed at 16 bytes / 128 bits (Nb=4) for AES
 12:             var_decl                    // var counterBlock;
// 
//   var nonce = (new Date()).getTime();  // milliseconds since 1-Jan-1970
 13:             var_decl                    // var nonce;
// 
//   // encode nonce in two stages to cater for JavaScript 32-bit limit on bitwise ops
// 
//   for (var i=0; i<4; i++) counterBlock[i] = (nonce >>> i*8) & 0xff;
//   for (var i=0; i<4; i++) counterBlock[i+4] = (nonce/0x100000000 >>> i*8) & 0xff; 
//   // generate key schedule - an expansion of the key into distinct Key Rounds for each round
// 
//   var keySchedule = KeyExpansion(key);
 14:             var_decl                    // var keySchedule;
//   var blockCount = Math.ceil(plaintext.length/blockSize);
 15:             var_decl                    // var blockCount;
//   var ciphertext = new Array(blockCount);  // ciphertext as array of strings
 16:             var_decl                    // var ciphertext;
// 
//   
//   for (var b=0; b<blockCount; b++) {
 17:             var_decl                    // var b;
//     // set counter (block #) in last 8 bytes of counter block (leaving nonce in 1st 8 bytes)
// 
//     // again done in two stages for 32-bit ops
// 
//     for (var c=0; c<4; c++) counterBlock[15-c] = (b >>> c*8) & 0xff;
 18:             var_decl                    // var c;
//     for (var c=0; c<4; c++) counterBlock[15-c-4] = (b/0x100000000 >>> c*8)
//     var cipherCntr = Cipher(counterBlock, keySchedule);  // -- encrypt counter block --
 19:             var_decl                    // var cipherCntr;
// 
//     
//     // calculate length of final block:
// 
//     var blockLength = b<blockCount-1 ? blockSize : (plaintext.length-1)%blockSize+1;
 20:             var_decl                    // var blockLength;
//     var ct = '';
 21:             var_decl                    // var ct;
//     for (var i=0; i<blockLength; i++) {  // -- xor plaintext with ciphered counter byte-by-byte --
// 
//       var plaintextByte = plaintext.charCodeAt(b*blockSize+i);
 22:             var_decl                    // var plaintextByte;
//       var cipherByte = plaintextByte ^ cipherCntr[i];
 23:             var_decl                    // var cipherByte;
//       ct += String.fromCharCode(cipherByte);
//     }
//     // ct is now ciphertext for this block
// 
//     ciphertext[b] = escCtrlChars(ct);  // escape troublesome characters in ciphertext
// 
//   }
//   // convert the nonce to a string to go on the front of the ciphertext
// 
//   var ctrTxt = '';
 24:             var_decl                    // var ctrTxt;
//   for (var i=0; i<8; i++) ctrTxt += String.fromCharCode(counterBlock[i]);
//   ctrTxt = escCtrlChars(ctrTxt);
//   // use '-' to separate blocks, use Array.join to concatenate arrays of strings for efficiency
// 
//   return ctrTxt + '-' + ciphertext.join('-');
// }
 25:           assignment  130    6          // tmp130 = nBits : TYPEOF(nBits);
 26:           assignment  131    1          // tmp131 = 128: SMALLINT;
 27:          equal_value  132  130          // tmp132 = tmp130 == tmp131;
 28:           assignment  133    6          // tmp133 = tmp132 : TYPEOF(tmp132);
 29:     is_true_jmp_down  133  255          // if (tmp133) goto 65564;
 30:           assignment  134    6          // tmp134 = nBits : TYPEOF(nBits);
 31:           assignment  135    1          // tmp135 = 192: SMALLINT;
 32:          equal_value  136  134          // tmp136 = tmp134 == tmp135;
 33:           assignment  133    6          // tmp133 = tmp136 : TYPEOF(tmp136);
 34:     is_true_jmp_down  133  255          // if (tmp133) goto 65569;
 35:           assignment  137    6          // tmp137 = nBits : TYPEOF(nBits);
 36:           assignment  138    3          // tmp138 = 256: NUMBER;
 37:          equal_value  139  137          // tmp139 = tmp137 == tmp138;
 38:           assignment  133    6          // tmp133 = tmp139 : TYPEOF(tmp139);
 29:     is_true_jmp_down  133    0          // if (tmp133) goto 39; // REWRITE
 34:     is_true_jmp_down  133    0          // if (tmp133) goto 39; // REWRITE
 39:          logical_not  140               // tmp140 = ! tmp133;
 40:    is_false_jmp_down  140  255          // if (tmp140 == false) goto 65575;
 41:           assignment  130    5          // tmp130 = '': STRING;
 42:               retval                    // return tmp130;
// 
//   // for this example script, generate the key by applying Cipher to 1st 16/24/32 chars of password; 
// 
//   // for real-world applications, a more secure approach would be to hash the password e.g. with SHA-1
// 
//   var nBytes = nBits/8;  // no bytes in key
 40:    is_false_jmp_down  140    0          // if (tmp140 == false) goto 43; // REWRITE
 43:           assignment  130    6          // tmp130 = nBits : TYPEOF(nBits);
 44:           assignment  131    1          // tmp131 = 8: SMALLINT;
 45:             division  132  130          // tmp132 = tmp130 / tmp131;
 46:           assignment  254    6          // nBytes = tmp132 : TYPEOF(tmp132);
// 
//   var pwBytes = new Array(nBytes);
 47:          construct_n  255  254          // 
 48:                 meta    2  254          // 
 47:          construct_n  130  254          //  // REWRITE
 49:           assignment  254    6          // pwBytes = tmp130 : TYPEOF(tmp130);
//   for (var i=0; i<nBytes; i++) pwBytes[i] = password.charCodeAt(i) & 0xff;
 50:           assignment  130    1          // tmp130 = 0: SMALLINT;
 51:           assignment  254    6          // i = tmp130 : TYPEOF(tmp130);
 52:             jmp_down  255               // goto 65587;
 53:          prop_getter  130  254          // tmp130 = pwBytes[i];
 53:           assignment  131    5          // tmp131 = 'charCodeAt': STRING;
 54:          prop_getter  132  254          // tmp132 = password[tmp131];
 55:           assignment  133    6          // tmp133 = password : TYPEOF(password);
 56:               call_n  255  132          // 
 57:                 meta    1    1          // 
 58:                 meta    2  254          // 
 56:               call_n  134  132          //  // REWRITE
 59:           assignment  135    1          // tmp135 = 255: SMALLINT;
 60:                b_and  136  134          // tmp136 = tmp134 & tmp135;
 61:          prop_setter  254  254          // pwBytes[i] = tmp136;
 62:            post_incr  137               // tmp137 = i++;
 52:             jmp_down    0               // goto 63; // REWRITE
 63:           assignment  138    6          // tmp138 = i : TYPEOF(i);
 64:            less_than  139  138          // tmp139 = tmp138 < nBytes;
 65:       is_true_jmp_up  139    0          // if (tmp139) goto 53;
//   var key = Cipher(pwBytes, KeyExpansion(pwBytes));
 66:               call_n  255  254          // 
 67:                 meta    2  254          // 
 68:               call_n  255  254          // 
 69:                 meta    2  254          // 
 68:               call_n  130  254          //  // REWRITE
 70:                 meta    2  130          // tmp130 = hz (hz, tmp130);
 66:               call_n  130  254          //  // REWRITE
 71:           assignment  254    6          // key = tmp130 : TYPEOF(tmp130);
//   key = key.concat(key.slice(0, nBytes-16));  // key is now 16/24/32 bytes long
 72:           assignment  130    5          // tmp130 = 'concat': STRING;
 73:          prop_getter  131  254          // tmp131 = key[tmp130];
 74:           assignment  132    6          // tmp132 = key : TYPEOF(key);
 75:               call_n  255  131          // 
 76:                 meta    1    1          // 
 77:           assignment  133    5          // tmp133 = 'slice': STRING;
 78:          prop_getter  134  254          // tmp134 = key[tmp133];
 79:           assignment  135    6          // tmp135 = key : TYPEOF(key);
 80:               call_n  255  134          // 
 81:                 meta    1    1          // 
 82:           assignment  136    1          // tmp136 = 0: SMALLINT;
 83:                 meta    2  136          // 
 84:           assignment  136    6          // tmp136 = nBytes : TYPEOF(nBytes);
 85:           assignment  137    1          // tmp137 = 16: SMALLINT;
 86:         substraction  138  136          // tmp138 = tmp136 - tmp137;
 87:                 meta    2  138          // 
 80:               call_n  136  134          //  // REWRITE
 88:                 meta    2  136          // 
 75:               call_n  133  131          //  // REWRITE
 89:           assignment  254    6          // key = tmp133 : TYPEOF(tmp133);
// 
//   // initialise counter block (NIST SP800-38A _B.2): millisecond time-stamp for nonce in 1st 8 bytes,
// 
//   // block counter in 2nd 8 bytes
// 
//   var blockSize = 16;  // block size fixed at 16 bytes / 128 bits (Nb=4) for AES
 90:           assignment  130    1          // tmp130 = 16: SMALLINT;
 91:           assignment  254    6          // blockSize = tmp130 : TYPEOF(tmp130);
// 
//   var counterBlock = new Array(blockSize);  // block size fixed at 16 bytes / 128 bits (Nb=4) for AES
 92:          construct_n  255  254          // 
 93:                 meta    2  254          // 
 92:          construct_n  130  254          //  // REWRITE
 94:           assignment  254    6          // counterBlock = tmp130 : TYPEOF(tmp130);
// 
//   var nonce = (new Date()).getTime();  // milliseconds since 1-Jan-1970
 95:          construct_n  255  254          // 
 95:          construct_n  130  254          // tmp130 = new Date; // REWRITE
 96:           assignment  131    5          // tmp131 = 'getTime': STRING;
 97:          prop_getter  132  130          // tmp132 = tmp130[tmp131];
 98:               call_n  255  132          // 
 99:                 meta    1    1          // 
 98:               call_n  133  132          //  // REWRITE
100:           assignment  254    6          // nonce = tmp133 : TYPEOF(tmp133);
// 
//   // encode nonce in two stages to cater for JavaScript 32-bit limit on bitwise ops
// 
//   for (var i=0; i<4; i++) counterBlock[i] = (nonce >>> i*8) & 0xff;
101:           assignment  130    1          // tmp130 = 0: SMALLINT;
102:           assignment  254    6          // i = tmp130 : TYPEOF(tmp130);
103:             jmp_down  255               // goto 65638;
104:          prop_getter  130  254          // tmp130 = counterBlock[i];
104:           assignment  131    6          // tmp131 = nonce : TYPEOF(nonce);
105:           assignment  132    6          // tmp132 = i : TYPEOF(i);
106:           assignment  133    1          // tmp133 = 8: SMALLINT;
107:       multiplication  134  132          // tmp134 = tmp132 * tmp133;
108:       b_shift_uright  135  131          // tmp135 = tmp131 >>> tmp134;
109:           assignment  136    1          // tmp136 = 255: SMALLINT;
110:                b_and  137  135          // tmp137 = tmp135 & tmp136;
111:          prop_setter  254  254          // counterBlock[i] = tmp137;
112:            post_incr  138               // tmp138 = i++;
103:             jmp_down    0               // goto 113; // REWRITE
113:           assignment  139    6          // tmp139 = i : TYPEOF(i);
114:           assignment  140    1          // tmp140 = 4: SMALLINT;
115:            less_than  141  139          // tmp141 = tmp139 < tmp140;
116:       is_true_jmp_up  141    0          // if (tmp141) goto 104;
//   for (var i=0; i<4; i++) counterBlock[i+4] = (nonce/0x100000000 >>> i*8) & 0xff; 
117:           assignment  130    1          // tmp130 = 0: SMALLINT;
118:           assignment  254    6          // i = tmp130 : TYPEOF(tmp130);
119:             jmp_down  255               // goto 65654;
120:           assignment  130    6          // tmp130 = i : TYPEOF(i);
121:           assignment  131    1          // tmp131 = 4: SMALLINT;
122:             addition  132  130          // tmp132 = tmp130 + tmp131;
123:          prop_getter  133  254          // tmp133 = counterBlock[tmp132];
123:           assignment  134    6          // tmp134 = nonce : TYPEOF(nonce);
124:           assignment  135    3          // tmp135 = 4294967296: NUMBER;
125:             division  136  134          // tmp136 = tmp134 / tmp135;
126:           assignment  137    6          // tmp137 = i : TYPEOF(i);
127:           assignment  138    1          // tmp138 = 8: SMALLINT;
128:       multiplication  139  137          // tmp139 = tmp137 * tmp138;
129:       b_shift_uright  140  136          // tmp140 = tmp136 >>> tmp139;
130:           assignment  141    1          // tmp141 = 255: SMALLINT;
131:                b_and  142  140          // tmp142 = tmp140 & tmp141;
132:          prop_setter  254  132          // counterBlock[tmp132] = tmp142;
133:            post_incr  143               // tmp143 = i++;
119:             jmp_down    0               // goto 134; // REWRITE
134:           assignment  144    6          // tmp144 = i : TYPEOF(i);
135:           assignment  145    1          // tmp145 = 4: SMALLINT;
136:            less_than  146  144          // tmp146 = tmp144 < tmp145;
137:       is_true_jmp_up  146    0          // if (tmp146) goto 120;
//   // generate key schedule - an expansion of the key into distinct Key Rounds for each round
// 
//   var keySchedule = KeyExpansion(key);
138:               call_n  255  254          // 
139:                 meta    2  254          // 
138:               call_n  130  254          //  // REWRITE
140:           assignment  254    6          // keySchedule = tmp130 : TYPEOF(tmp130);
//   var blockCount = Math.ceil(plaintext.length/blockSize);
141:           assignment  130    5          // tmp130 = 'ceil': STRING;
142:          prop_getter  131  254          // tmp131 = Math[tmp130];
143:           assignment  132    6          // tmp132 = Math : TYPEOF(Math);
144:               call_n  255  131          // 
145:                 meta    1    1          // 
146:           assignment  133    5          // tmp133 = 'length': STRING;
147:          prop_getter  134  254          // tmp134 = plaintext[tmp133];
148:             division  135  134          // tmp135 = tmp134 / blockSize;
149:                 meta    2  135          // 
144:               call_n  133  131          //  // REWRITE
150:           assignment  254    6          // blockCount = tmp133 : TYPEOF(tmp133);
//   var ciphertext = new Array(blockCount);  // ciphertext as array of strings
151:          construct_n  255  254          // 
152:                 meta    2  254          // 
151:          construct_n  130  254          //  // REWRITE
153:           assignment  254    6          // ciphertext = tmp130 : TYPEOF(tmp130);
// 
//   
//   for (var b=0; b<blockCount; b++) {
154:           assignment  130    1          // tmp130 = 0: SMALLINT;
155:           assignment  254    6          // b = tmp130 : TYPEOF(tmp130);
156:             jmp_down  255               // goto 65691;
//     // set counter (block #) in last 8 bytes of counter block (leaving nonce in 1st 8 bytes)
// 
//     // again done in two stages for 32-bit ops
// 
//     for (var c=0; c<4; c++) counterBlock[15-c] = (b >>> c*8) & 0xff;
157:           assignment  130    1          // tmp130 = 0: SMALLINT;
158:           assignment  254    6          // c = tmp130 : TYPEOF(tmp130);
159:             jmp_down  255               // goto 65694;
160:           assignment  130    1          // tmp130 = 15: SMALLINT;
161:         substraction  131  130          // tmp131 = tmp130 - c;
162:          prop_getter  132  254          // tmp132 = counterBlock[tmp131];
162:           assignment  133    6          // tmp133 = b : TYPEOF(b);
163:           assignment  134    6          // tmp134 = c : TYPEOF(c);
164:           assignment  135    1          // tmp135 = 8: SMALLINT;
165:       multiplication  136  134          // tmp136 = tmp134 * tmp135;
166:       b_shift_uright  137  133          // tmp137 = tmp133 >>> tmp136;
167:           assignment  138    1          // tmp138 = 255: SMALLINT;
168:                b_and  139  137          // tmp139 = tmp137 & tmp138;
169:          prop_setter  254  131          // counterBlock[tmp131] = tmp139;
170:            post_incr  140               // tmp140 = c++;
159:             jmp_down    0               // goto 171; // REWRITE
171:           assignment  141    6          // tmp141 = c : TYPEOF(c);
172:           assignment  142    1          // tmp142 = 4: SMALLINT;
173:            less_than  143  141          // tmp143 = tmp141 < tmp142;
174:       is_true_jmp_up  143    0          // if (tmp143) goto 160;
//     for (var c=0; c<4; c++) counterBlock[15-c-4] = (b/0x100000000 >>> c*8)
175:           assignment  130    1          // tmp130 = 0: SMALLINT;
176:           assignment  254    6          // c = tmp130 : TYPEOF(tmp130);
177:             jmp_down  255               // goto 65712;
178:           assignment  130    1          // tmp130 = 15: SMALLINT;
179:         substraction  131  130          // tmp131 = tmp130 - c;
180:           assignment  132    1          // tmp132 = 4: SMALLINT;
181:         substraction  133  131          // tmp133 = tmp131 - tmp132;
182:          prop_getter  134  254          // tmp134 = counterBlock[tmp133];
182:           assignment  135    6          // tmp135 = b : TYPEOF(b);
183:           assignment  136    3          // tmp136 = 4294967296: NUMBER;
184:             division  137  135          // tmp137 = tmp135 / tmp136;
185:           assignment  138    6          // tmp138 = c : TYPEOF(c);
186:           assignment  139    1          // tmp139 = 8: SMALLINT;
187:       multiplication  140  138          // tmp140 = tmp138 * tmp139;
188:       b_shift_uright  141  137          // tmp141 = tmp137 >>> tmp140;
//     var cipherCntr = Cipher(counterBlock, keySchedule);  // -- encrypt counter block --
189:          prop_setter  254  133          // counterBlock[tmp133] = tmp141;
190:            post_incr  142               // tmp142 = c++;
177:             jmp_down    0               // goto 191; // REWRITE
191:           assignment  143    6          // tmp143 = c : TYPEOF(c);
192:           assignment  144    1          // tmp144 = 4: SMALLINT;
193:            less_than  145  143          // tmp145 = tmp143 < tmp144;
194:       is_true_jmp_up  145    0          // if (tmp145) goto 178;
195:               call_n  255  254          // 
196:                 meta    2  254          // 
197:                 meta    2  254          // 
195:               call_n  130  254          //  // REWRITE
198:           assignment  254    6          // cipherCntr = tmp130 : TYPEOF(tmp130);
// 
//     
//     // calculate length of final block:
// 
//     var blockLength = b<blockCount-1 ? blockSize : (plaintext.length-1)%blockSize+1;
199:           assignment  130    6          // tmp130 = b : TYPEOF(b);
200:           assignment  131    6          // tmp131 = blockCount : TYPEOF(blockCount);
201:           assignment  132    1          // tmp132 = 1: SMALLINT;
202:         substraction  133  131          // tmp133 = tmp131 - tmp132;
203:            less_than  134  130          // tmp134 = tmp130 < tmp133;
204:    is_false_jmp_down  134  255          // if (tmp134 == false) goto 65739;
205:           assignment  135    6          // tmp135 = blockSize : TYPEOF(blockSize);
206:             jmp_down  255               // goto 65741;
204:    is_false_jmp_down  134    0          // if (tmp134 == false) goto 207; // REWRITE
207:           assignment  136    5          // tmp136 = 'length': STRING;
208:          prop_getter  137  254          // tmp137 = plaintext[tmp136];
209:           assignment  138    1          // tmp138 = 1: SMALLINT;
210:         substraction  139  137          // tmp139 = tmp137 - tmp138;
211:            remainder  140  139          // tmp140 = tmp139 %% blockSize;
212:           assignment  141    1          // tmp141 = 1: SMALLINT;
213:             addition  142  140          // tmp142 = tmp140 + tmp141;
214:           assignment  135    6          // tmp135 = tmp142 : TYPEOF(tmp142);
206:             jmp_down    0               // goto 215; // REWRITE
215:           assignment  254    6          // blockLength = tmp135 : TYPEOF(tmp135);
//     var ct = '';
216:           assignment  130    5          // tmp130 = '': STRING;
217:           assignment  254    6          // ct = tmp130 : TYPEOF(tmp130);
//     for (var i=0; i<blockLength; i++) {  // -- xor plaintext with ciphered counter byte-by-byte --
218:           assignment  130    1          // tmp130 = 0: SMALLINT;
219:           assignment  254    6          // i = tmp130 : TYPEOF(tmp130);
220:             jmp_down  255               // goto 65755;
// 
//       var plaintextByte = plaintext.charCodeAt(b*blockSize+i);
221:           assignment  130    5          // tmp130 = 'charCodeAt': STRING;
222:          prop_getter  131  254          // tmp131 = plaintext[tmp130];
223:           assignment  132    6          // tmp132 = plaintext : TYPEOF(plaintext);
224:               call_n  255  131          // 
225:                 meta    1    1          // 
226:           assignment  133    6          // tmp133 = b : TYPEOF(b);
227:       multiplication  134  133          // tmp134 = tmp133 * blockSize;
228:             addition  135  134          // tmp135 = tmp134 + i;
229:                 meta    2  135          // 
224:               call_n  133  131          //  // REWRITE
230:           assignment  254    6          // plaintextByte = tmp133 : TYPEOF(tmp133);
//       var cipherByte = plaintextByte ^ cipherCntr[i];
231:           assignment  130    6          // tmp130 = plaintextByte : TYPEOF(plaintextByte);
232:          prop_getter  131  254          // tmp131 = cipherCntr[i];
233:                b_xor  132  130          // tmp132 = tmp130 ^ tmp131;
234:           assignment  254    6          // cipherByte = tmp132 : TYPEOF(tmp132);
//       ct += String.fromCharCode(cipherByte);
235:           assignment  130    5          // tmp130 = 'fromCharCode': STRING;
236:          prop_getter  131  254          // tmp131 = String[tmp130];
237:           assignment  132    6          // tmp132 = String : TYPEOF(String);
238:               call_n  255  131          // 
239:                 meta    1    1          // 
240:                 meta    2  254          // 
238:               call_n  133  131          //  // REWRITE
241:             addition  254  254          // ct = ct + tmp133;
242:           assignment  134    6          // tmp134 = ct : TYPEOF(ct);
//     }
243:            post_incr  135               // tmp135 = i++;
220:             jmp_down    0               // goto 244; // REWRITE
244:           assignment  136    6          // tmp136 = i : TYPEOF(i);
245:            less_than  137  136          // tmp137 = tmp136 < blockLength;
246:       is_true_jmp_up  137    0          // if (tmp137) goto 221;
//     // ct is now ciphertext for this block
// 
//     ciphertext[b] = escCtrlChars(ct);  // escape troublesome characters in ciphertext
247:          prop_getter  130  254          // tmp130 = ciphertext[b];
247:               call_n  255  254          // 
248:                 meta    2  254          // 
247:               call_n  131  254          //  // REWRITE
249:          prop_setter  254  254          // ciphertext[b] = tmp131;
// 
//   }
250:            post_incr  132               // tmp132 = b++;
156:             jmp_down    0               // goto 251; // REWRITE
251:           assignment  133    6          // tmp133 = b : TYPEOF(b);
252:            less_than  134  133          // tmp134 = tmp133 < blockCount;
253:       is_true_jmp_up  134    0          // if (tmp134) goto 157;
//   // convert the nonce to a string to go on the front of the ciphertext
// 
//   var ctrTxt = '';
254:           assignment  130    5          // tmp130 = '': STRING;
255:           assignment  254    6          // ctrTxt = tmp130 : TYPEOF(tmp130);
//   for (var i=0; i<8; i++) ctrTxt += String.fromCharCode(counterBlock[i]);
256:           assignment  130    1          // tmp130 = 0: SMALLINT;
257:           assignment  254    6          // i = tmp130 : TYPEOF(tmp130);
258:             jmp_down  255               // goto 65793;
259:           assignment  130    5          // tmp130 = 'fromCharCode': STRING;
260:          prop_getter  131  254          // tmp131 = String[tmp130];
261:           assignment  132    6          // tmp132 = String : TYPEOF(String);
262:               call_n  255  131          // 
263:                 meta    1    1          // 
264:          prop_getter  133  254          // tmp133 = counterBlock[i];
265:                 meta    2  133          // 
262:               call_n  133  131          //  // REWRITE
266:             addition  254  254          // ctrTxt = ctrTxt + tmp133;
267:           assignment  134    6          // tmp134 = ctrTxt : TYPEOF(ctrTxt);
268:            post_incr  135               // tmp135 = i++;
258:             jmp_down    0               // goto 269; // REWRITE
269:           assignment  136    6          // tmp136 = i : TYPEOF(i);
270:           assignment  137    1          // tmp137 = 8: SMALLINT;
271:            less_than  138  136          // tmp138 = tmp136 < tmp137;
272:       is_true_jmp_up  138    0          // if (tmp138) goto 259;
//   ctrTxt = escCtrlChars(ctrTxt);
273:               call_n  255  254          // 
274:                 meta    2  254          // 
273:               call_n  130  254          //  // REWRITE
275:           assignment  254    6          // ctrTxt = tmp130 : TYPEOF(tmp130);
//   // use '-' to separate blocks, use Array.join to concatenate arrays of strings for efficiency
// 
//   return ctrTxt + '-' + ciphertext.join('-');
276:           assignment  130    6          // tmp130 = ctrTxt : TYPEOF(ctrTxt);
277:           assignment  131    5          // tmp131 = '-': STRING;
278:             addition  132  130          // tmp132 = tmp130 + tmp131;
279:           assignment  133    5          // tmp133 = 'join': STRING;
280:          prop_getter  134  254          // tmp134 = ciphertext[tmp133];
281:           assignment  135    6          // tmp135 = ciphertext : TYPEOF(ciphertext);
282:               call_n  255  134          // 
283:                 meta    1    1          // 
284:           assignment  136    5          // tmp136 = '-': STRING;
285:                 meta    2  136          // 
282:               call_n  136  134          //  // REWRITE
286:             addition  137  132          // tmp137 = tmp132 + tmp136;
287:               retval                    // return tmp137;
// }
  6:         reg_var_decl  128               // var tmp128 .. tmp146; // REWRITE
288:                  ret                    // ret;
  4:                 meta    7    1          // function end: 289; // REWRITE
// /* 
// 
// function AESDecryptCtr(ciphertext, password, nBits) {
  0:          func_decl_n  254               // 
  1:                 meta    2  254          // 
  2:                 meta    2  254          // 
  3:                 meta    2  254          // 
  0:          func_decl_n  254               //  // REWRITE
  4:                 meta    7  255          // function end: 65539;
//   if (!(nBits==128 || nBits==192 || nBits==256)) return '';  // standard allows 128/192/256 bit keys
  5:                 meta   12  255          // [to be rewritten]
// 
//   var nBytes = nBits/8;  // no bytes in key
// 
//   var pwBytes = new Array(nBytes);
//   for (var i=0; i<nBytes; i++) pwBytes[i] = password.charCodeAt(i) & 0xff;
//   var pwKeySchedule = KeyExpansion(pwBytes);
//   var key = Cipher(pwBytes, pwKeySchedule);
//   key = key.concat(key.slice(0, nBytes-16));  // key is now 16/24/32 bytes long
// 
//   var keySchedule = KeyExpansion(key);
//   ciphertext = ciphertext.split('-');  // split ciphertext into array of block-length strings 
// 
//   // recover nonce from 1st element of ciphertext
// 
//   var blockSize = 16;  // block size fixed at 16 bytes / 128 bits (Nb=4) for AES
// 
//   var counterBlock = new Array(blockSize);
//   var ctrTxt = unescCtrlChars(ciphertext[0]);
//   for (var i=0; i<8; i++) counterBlock[i] = ctrTxt.charCodeAt(i);
//   var plaintext = new Array(ciphertext.length-1);
//   for (var b=1; b<ciphertext.length; b++) {
//     // set counter (block #) in last 8 bytes of counter block (leaving nonce in 1st 8 bytes)
// 
//     for (var c=0; c<4; c++) counterBlock[15-c] = ((b-1) >>> c*8) & 0xff;
//     for (var c=0; c<4; c++) counterBlock[15-c-4] = ((b/0x100000000-1) >>> c*8) & 0xff;
//     var cipherCntr = Cipher(counterBlock, keySchedule);  // encrypt counter block
// 
//     ciphertext[b] = unescCtrlChars(ciphertext[b]);
//     var pt = '';
//     for (var i=0; i<ciphertext[b].length; i++) {
//       // -- xor plaintext with ciphered counter byte-by-byte --
// 
//       var ciphertextByte = ciphertext[b].charCodeAt(i);
//       var plaintextByte = ciphertextByte ^ cipherCntr[i];
//       pt += String.fromCharCode(plaintextByte);
//     }
//     // pt is now plaintext for this block
// 
//     plaintext[b-1] = pt;  // b-1 'cos no initial nonce block in plaintext
// 
//   }
//   return plaintext.join('');
// }
  5:                 meta   12    6          // [no 'arguments'] [no 'eval']  // REWRITE
  6:         reg_var_decl  128               // var tmp128 .. tmp255;
// 
//   var nBytes = nBits/8;  // no bytes in key
  7:             var_decl                    // var nBytes;
// 
//   var pwBytes = new Array(nBytes);
  8:             var_decl                    // var pwBytes;
//   for (var i=0; i<nBytes; i++) pwBytes[i] = password.charCodeAt(i) & 0xff;
  9:             var_decl                    // var i;
//   var pwKeySchedule = KeyExpansion(pwBytes);
 10:             var_decl                    // var pwKeySchedule;
//   var key = Cipher(pwBytes, pwKeySchedule);
 11:             var_decl                    // var key;
//   key = key.concat(key.slice(0, nBytes-16));  // key is now 16/24/32 bytes long
// 
//   var keySchedule = KeyExpansion(key);
 12:             var_decl                    // var keySchedule;
//   ciphertext = ciphertext.split('-');  // split ciphertext into array of block-length strings 
// 
//   // recover nonce from 1st element of ciphertext
// 
//   var blockSize = 16;  // block size fixed at 16 bytes / 128 bits (Nb=4) for AES
 13:             var_decl                    // var blockSize;
// 
//   var counterBlock = new Array(blockSize);
 14:             var_decl                    // var counterBlock;
//   var ctrTxt = unescCtrlChars(ciphertext[0]);
 15:             var_decl                    // var ctrTxt;
//   for (var i=0; i<8; i++) counterBlock[i] = ctrTxt.charCodeAt(i);
//   var plaintext = new Array(ciphertext.length-1);
 16:             var_decl                    // var plaintext;
//   for (var b=1; b<ciphertext.length; b++) {
 17:             var_decl                    // var b;
//     // set counter (block #) in last 8 bytes of counter block (leaving nonce in 1st 8 bytes)
// 
//     for (var c=0; c<4; c++) counterBlock[15-c] = ((b-1) >>> c*8) & 0xff;
 18:             var_decl                    // var c;
//     for (var c=0; c<4; c++) counterBlock[15-c-4] = ((b/0x100000000-1) >>> c*8) & 0xff;
//     var cipherCntr = Cipher(counterBlock, keySchedule);  // encrypt counter block
 19:             var_decl                    // var cipherCntr;
// 
//     ciphertext[b] = unescCtrlChars(ciphertext[b]);
//     var pt = '';
 20:             var_decl                    // var pt;
//     for (var i=0; i<ciphertext[b].length; i++) {
//       // -- xor plaintext with ciphered counter byte-by-byte --
// 
//       var ciphertextByte = ciphertext[b].charCodeAt(i);
 21:             var_decl                    // var ciphertextByte;
//       var plaintextByte = ciphertextByte ^ cipherCntr[i];
 22:             var_decl                    // var plaintextByte;
//       pt += String.fromCharCode(plaintextByte);
//     }
//     // pt is now plaintext for this block
// 
//     plaintext[b-1] = pt;  // b-1 'cos no initial nonce block in plaintext
// 
//   }
//   return plaintext.join('');
// }
 23:           assignment  130    6          // tmp130 = nBits : TYPEOF(nBits);
 24:           assignment  131    1          // tmp131 = 128: SMALLINT;
 25:          equal_value  132  130          // tmp132 = tmp130 == tmp131;
 26:           assignment  133    6          // tmp133 = tmp132 : TYPEOF(tmp132);
 27:     is_true_jmp_down  133  255          // if (tmp133) goto 65562;
 28:           assignment  134    6          // tmp134 = nBits : TYPEOF(nBits);
 29:           assignment  135    1          // tmp135 = 192: SMALLINT;
 30:          equal_value  136  134          // tmp136 = tmp134 == tmp135;
 31:           assignment  133    6          // tmp133 = tmp136 : TYPEOF(tmp136);
 32:     is_true_jmp_down  133  255          // if (tmp133) goto 65567;
 33:           assignment  137    6          // tmp137 = nBits : TYPEOF(nBits);
 34:           assignment  138    3          // tmp138 = 256: NUMBER;
 35:          equal_value  139  137          // tmp139 = tmp137 == tmp138;
 36:           assignment  133    6          // tmp133 = tmp139 : TYPEOF(tmp139);
 27:     is_true_jmp_down  133    0          // if (tmp133) goto 37; // REWRITE
 32:     is_true_jmp_down  133    0          // if (tmp133) goto 37; // REWRITE
 37:          logical_not  140               // tmp140 = ! tmp133;
 38:    is_false_jmp_down  140  255          // if (tmp140 == false) goto 65573;
 39:           assignment  130    5          // tmp130 = '': STRING;
 40:               retval                    // return tmp130;
// 
//   var nBytes = nBits/8;  // no bytes in key
 38:    is_false_jmp_down  140    0          // if (tmp140 == false) goto 41; // REWRITE
 41:           assignment  130    6          // tmp130 = nBits : TYPEOF(nBits);
 42:           assignment  131    1          // tmp131 = 8: SMALLINT;
 43:             division  132  130          // tmp132 = tmp130 / tmp131;
 44:           assignment  254    6          // nBytes = tmp132 : TYPEOF(tmp132);
// 
//   var pwBytes = new Array(nBytes);
 45:          construct_n  255  254          // 
 46:                 meta    2  254          // 
 45:          construct_n  130  254          //  // REWRITE
 47:           assignment  254    6          // pwBytes = tmp130 : TYPEOF(tmp130);
//   for (var i=0; i<nBytes; i++) pwBytes[i] = password.charCodeAt(i) & 0xff;
 48:           assignment  130    1          // tmp130 = 0: SMALLINT;
 49:           assignment  254    6          // i = tmp130 : TYPEOF(tmp130);
 50:             jmp_down  255               // goto 65585;
 51:          prop_getter  130  254          // tmp130 = pwBytes[i];
 51:           assignment  131    5          // tmp131 = 'charCodeAt': STRING;
 52:          prop_getter  132  254          // tmp132 = password[tmp131];
 53:           assignment  133    6          // tmp133 = password : TYPEOF(password);
 54:               call_n  255  132          // 
 55:                 meta    1    1          // 
 56:                 meta    2  254          // 
 54:               call_n  134  132          //  // REWRITE
 57:           assignment  135    1          // tmp135 = 255: SMALLINT;
 58:                b_and  136  134          // tmp136 = tmp134 & tmp135;
 59:          prop_setter  254  254          // pwBytes[i] = tmp136;
 60:            post_incr  137               // tmp137 = i++;
 50:             jmp_down    0               // goto 61; // REWRITE
 61:           assignment  138    6          // tmp138 = i : TYPEOF(i);
 62:            less_than  139  138          // tmp139 = tmp138 < nBytes;
 63:       is_true_jmp_up  139    0          // if (tmp139) goto 51;
//   var pwKeySchedule = KeyExpansion(pwBytes);
 64:               call_n  255  254          // 
 65:                 meta    2  254          // 
 64:               call_n  130  254          //  // REWRITE
 66:           assignment  254    6          // pwKeySchedule = tmp130 : TYPEOF(tmp130);
//   var key = Cipher(pwBytes, pwKeySchedule);
 67:               call_n  255  254          // 
 68:                 meta    2  254          // 
 69:                 meta    2  254          // 
 67:               call_n  130  254          //  // REWRITE
 70:           assignment  254    6          // key = tmp130 : TYPEOF(tmp130);
//   key = key.concat(key.slice(0, nBytes-16));  // key is now 16/24/32 bytes long
 71:           assignment  130    5          // tmp130 = 'concat': STRING;
 72:          prop_getter  131  254          // tmp131 = key[tmp130];
 73:           assignment  132    6          // tmp132 = key : TYPEOF(key);
 74:               call_n  255  131          // 
 75:                 meta    1    1          // 
 76:           assignment  133    5          // tmp133 = 'slice': STRING;
 77:          prop_getter  134  254          // tmp134 = key[tmp133];
 78:           assignment  135    6          // tmp135 = key : TYPEOF(key);
 79:               call_n  255  134          // 
 80:                 meta    1    1          // 
 81:           assignment  136    1          // tmp136 = 0: SMALLINT;
 82:                 meta    2  136          // 
 83:           assignment  136    6          // tmp136 = nBytes : TYPEOF(nBytes);
 84:           assignment  137    1          // tmp137 = 16: SMALLINT;
 85:         substraction  138  136          // tmp138 = tmp136 - tmp137;
 86:                 meta    2  138          // 
 79:               call_n  136  134          //  // REWRITE
 87:                 meta    2  136          // 
 74:               call_n  133  131          //  // REWRITE
 88:           assignment  254    6          // key = tmp133 : TYPEOF(tmp133);
// 
//   var keySchedule = KeyExpansion(key);
 89:               call_n  255  254          // 
 90:                 meta    2  254          // 
 89:               call_n  130  254          //  // REWRITE
 91:           assignment  254    6          // keySchedule = tmp130 : TYPEOF(tmp130);
//   ciphertext = ciphertext.split('-');  // split ciphertext into array of block-length strings 
 92:           assignment  130    5          // tmp130 = 'split': STRING;
 93:          prop_getter  131  254          // tmp131 = ciphertext[tmp130];
 94:           assignment  132    6          // tmp132 = ciphertext : TYPEOF(ciphertext);
 95:               call_n  255  131          // 
 96:                 meta    1    1          // 
 97:           assignment  133    5          // tmp133 = '-': STRING;
 98:                 meta    2  133          // 
 95:               call_n  133  131          //  // REWRITE
 99:           assignment  254    6          // ciphertext = tmp133 : TYPEOF(tmp133);
// 
//   // recover nonce from 1st element of ciphertext
// 
//   var blockSize = 16;  // block size fixed at 16 bytes / 128 bits (Nb=4) for AES
100:           assignment  130    1          // tmp130 = 16: SMALLINT;
101:           assignment  254    6          // blockSize = tmp130 : TYPEOF(tmp130);
// 
//   var counterBlock = new Array(blockSize);
102:          construct_n  255  254          // 
103:                 meta    2  254          // 
102:          construct_n  130  254          //  // REWRITE
104:           assignment  254    6          // counterBlock = tmp130 : TYPEOF(tmp130);
//   var ctrTxt = unescCtrlChars(ciphertext[0]);
105:               call_n  255  254          // 
106:           assignment  130    1          // tmp130 = 0: SMALLINT;
107:          prop_getter  131  254          // tmp131 = ciphertext[tmp130];
108:                 meta    2  131          // 
105:               call_n  130  254          //  // REWRITE
109:           assignment  254    6          // ctrTxt = tmp130 : TYPEOF(tmp130);
//   for (var i=0; i<8; i++) counterBlock[i] = ctrTxt.charCodeAt(i);
110:           assignment  130    1          // tmp130 = 0: SMALLINT;
111:           assignment  254    6          // i = tmp130 : TYPEOF(tmp130);
112:             jmp_down  255               // goto 65647;
113:          prop_getter  130  254          // tmp130 = counterBlock[i];
113:           assignment  131    5          // tmp131 = 'charCodeAt': STRING;
114:          prop_getter  132  254          // tmp132 = ctrTxt[tmp131];
115:           assignment  133    6          // tmp133 = ctrTxt : TYPEOF(ctrTxt);
116:               call_n  255  132          // 
117:                 meta    1    1          // 
118:                 meta    2  254          // 
116:               call_n  134  132          //  // REWRITE
119:          prop_setter  254  254          // counterBlock[i] = tmp134;
120:            post_incr  135               // tmp135 = i++;
112:             jmp_down    0               // goto 121; // REWRITE
121:           assignment  136    6          // tmp136 = i : TYPEOF(i);
122:           assignment  137    1          // tmp137 = 8: SMALLINT;
123:            less_than  138  136          // tmp138 = tmp136 < tmp137;
124:       is_true_jmp_up  138    0          // if (tmp138) goto 113;
//   var plaintext = new Array(ciphertext.length-1);
125:          construct_n  255  254          // 
126:           assignment  130    5          // tmp130 = 'length': STRING;
127:          prop_getter  131  254          // tmp131 = ciphertext[tmp130];
128:           assignment  132    1          // tmp132 = 1: SMALLINT;
129:         substraction  133  131          // tmp133 = tmp131 - tmp132;
130:                 meta    2  133          // 
125:          construct_n  130  254          //  // REWRITE
131:           assignment  254    6          // plaintext = tmp130 : TYPEOF(tmp130);
//   for (var b=1; b<ciphertext.length; b++) {
132:           assignment  130    1          // tmp130 = 1: SMALLINT;
133:           assignment  254    6          // b = tmp130 : TYPEOF(tmp130);
134:             jmp_down  255               // goto 65669;
//     // set counter (block #) in last 8 bytes of counter block (leaving nonce in 1st 8 bytes)
// 
//     for (var c=0; c<4; c++) counterBlock[15-c] = ((b-1) >>> c*8) & 0xff;
135:           assignment  130    1          // tmp130 = 0: SMALLINT;
136:           assignment  254    6          // c = tmp130 : TYPEOF(tmp130);
137:             jmp_down  255               // goto 65672;
138:           assignment  130    1          // tmp130 = 15: SMALLINT;
139:         substraction  131  130          // tmp131 = tmp130 - c;
140:          prop_getter  132  254          // tmp132 = counterBlock[tmp131];
140:           assignment  133    6          // tmp133 = b : TYPEOF(b);
141:           assignment  134    1          // tmp134 = 1: SMALLINT;
142:         substraction  135  133          // tmp135 = tmp133 - tmp134;
143:           assignment  136    6          // tmp136 = c : TYPEOF(c);
144:           assignment  137    1          // tmp137 = 8: SMALLINT;
145:       multiplication  138  136          // tmp138 = tmp136 * tmp137;
146:       b_shift_uright  139  135          // tmp139 = tmp135 >>> tmp138;
147:           assignment  140    1          // tmp140 = 255: SMALLINT;
148:                b_and  141  139          // tmp141 = tmp139 & tmp140;
149:          prop_setter  254  131          // counterBlock[tmp131] = tmp141;
150:            post_incr  142               // tmp142 = c++;
137:             jmp_down    0               // goto 151; // REWRITE
151:           assignment  143    6          // tmp143 = c : TYPEOF(c);
152:           assignment  144    1          // tmp144 = 4: SMALLINT;
153:            less_than  145  143          // tmp145 = tmp143 < tmp144;
154:       is_true_jmp_up  145    0          // if (tmp145) goto 138;
//     for (var c=0; c<4; c++) counterBlock[15-c-4] = ((b/0x100000000-1) >>> c*8) & 0xff;
155:           assignment  130    1          // tmp130 = 0: SMALLINT;
156:           assignment  254    6          // c = tmp130 : TYPEOF(tmp130);
157:             jmp_down  255               // goto 65692;
158:           assignment  130    1          // tmp130 = 15: SMALLINT;
159:         substraction  131  130          // tmp131 = tmp130 - c;
160:           assignment  132    1          // tmp132 = 4: SMALLINT;
161:         substraction  133  131          // tmp133 = tmp131 - tmp132;
162:          prop_getter  134  254          // tmp134 = counterBlock[tmp133];
162:           assignment  135    6          // tmp135 = b : TYPEOF(b);
163:           assignment  136    3          // tmp136 = 4294967296: NUMBER;
164:             division  137  135          // tmp137 = tmp135 / tmp136;
165:           assignment  138    1          // tmp138 = 1: SMALLINT;
166:         substraction  139  137          // tmp139 = tmp137 - tmp138;
167:           assignment  140    6          // tmp140 = c : TYPEOF(c);
168:           assignment  141    1          // tmp141 = 8: SMALLINT;
169:       multiplication  142  140          // tmp142 = tmp140 * tmp141;
170:       b_shift_uright  143  139          // tmp143 = tmp139 >>> tmp142;
171:           assignment  144    1          // tmp144 = 255: SMALLINT;
172:                b_and  145  143          // tmp145 = tmp143 & tmp144;
173:          prop_setter  254  133          // counterBlock[tmp133] = tmp145;
174:            post_incr  146               // tmp146 = c++;
157:             jmp_down    0               // goto 175; // REWRITE
175:           assignment  147    6          // tmp147 = c : TYPEOF(c);
176:           assignment  148    1          // tmp148 = 4: SMALLINT;
177:            less_than  149  147          // tmp149 = tmp147 < tmp148;
178:       is_true_jmp_up  149    0          // if (tmp149) goto 158;
//     var cipherCntr = Cipher(counterBlock, keySchedule);  // encrypt counter block
179:               call_n  255  254          // 
180:                 meta    2  254          // 
181:                 meta    2  254          // 
179:               call_n  130  254          //  // REWRITE
182:           assignment  254    6          // cipherCntr = tmp130 : TYPEOF(tmp130);
// 
//     ciphertext[b] = unescCtrlChars(ciphertext[b]);
183:          prop_getter  130  254          // tmp130 = ciphertext[b];
183:               call_n  255  254          // 
184:          prop_getter  131  254          // tmp131 = ciphertext[b];
185:                 meta    2  131          // 
183:               call_n  131  254          //  // REWRITE
186:          prop_setter  254  254          // ciphertext[b] = tmp131;
//     var pt = '';
187:           assignment  130    5          // tmp130 = '': STRING;
188:           assignment  254    6          // pt = tmp130 : TYPEOF(tmp130);
//     for (var i=0; i<ciphertext[b].length; i++) {
189:           assignment  130    1          // tmp130 = 0: SMALLINT;
190:           assignment  254    6          // i = tmp130 : TYPEOF(tmp130);
191:             jmp_down  255               // goto 65726;
//       // -- xor plaintext with ciphered counter byte-by-byte --
// 
//       var ciphertextByte = ciphertext[b].charCodeAt(i);
192:          prop_getter  130  254          // tmp130 = ciphertext[b];
193:           assignment  131    5          // tmp131 = 'charCodeAt': STRING;
194:          prop_getter  132  130          // tmp132 = tmp130[tmp131];
195:               call_n  255  132          // 
196:                 meta    1    1          // 
197:                 meta    2  254          // 
195:               call_n  133  132          //  // REWRITE
198:           assignment  254    6          // ciphertextByte = tmp133 : TYPEOF(tmp133);
//       var plaintextByte = ciphertextByte ^ cipherCntr[i];
199:           assignment  130    6          // tmp130 = ciphertextByte : TYPEOF(ciphertextByte);
200:          prop_getter  131  254          // tmp131 = cipherCntr[i];
201:                b_xor  132  130          // tmp132 = tmp130 ^ tmp131;
202:           assignment  254    6          // plaintextByte = tmp132 : TYPEOF(tmp132);
//       pt += String.fromCharCode(plaintextByte);
203:           assignment  130    5          // tmp130 = 'fromCharCode': STRING;
204:          prop_getter  131  254          // tmp131 = String[tmp130];
205:           assignment  132    6          // tmp132 = String : TYPEOF(String);
206:               call_n  255  131          // 
207:                 meta    1    1          // 
208:                 meta    2  254          // 
206:               call_n  133  131          //  // REWRITE
209:             addition  254  254          // pt = pt + tmp133;
210:           assignment  134    6          // tmp134 = pt : TYPEOF(pt);
//     }
211:            post_incr  135               // tmp135 = i++;
191:             jmp_down    0               // goto 212; // REWRITE
212:           assignment  136    6          // tmp136 = i : TYPEOF(i);
213:          prop_getter  137  254          // tmp137 = ciphertext[b];
214:           assignment  138    5          // tmp138 = 'length': STRING;
215:          prop_getter  139  137          // tmp139 = tmp137[tmp138];
216:            less_than  140  136          // tmp140 = tmp136 < tmp139;
217:       is_true_jmp_up  140    0          // if (tmp140) goto 192;
//     // pt is now plaintext for this block
// 
//     plaintext[b-1] = pt;  // b-1 'cos no initial nonce block in plaintext
218:           assignment  130    6          // tmp130 = b : TYPEOF(b);
219:           assignment  131    1          // tmp131 = 1: SMALLINT;
220:         substraction  132  130          // tmp132 = tmp130 - tmp131;
221:          prop_getter  133  254          // tmp133 = plaintext[tmp132];
221:          prop_setter  254  132          // plaintext[tmp132] = pt;
222:           assignment  134    6          // tmp134 = pt : TYPEOF(pt);
// 
//   }
223:            post_incr  135               // tmp135 = b++;
134:             jmp_down    0               // goto 224; // REWRITE
224:           assignment  136    6          // tmp136 = b : TYPEOF(b);
225:           assignment  137    5          // tmp137 = 'length': STRING;
226:          prop_getter  138  254          // tmp138 = ciphertext[tmp137];
227:            less_than  139  136          // tmp139 = tmp136 < tmp138;
228:       is_true_jmp_up  139    0          // if (tmp139) goto 135;
//   return plaintext.join('');
229:           assignment  130    5          // tmp130 = 'join': STRING;
230:          prop_getter  131  254          // tmp131 = plaintext[tmp130];
231:           assignment  132    6          // tmp132 = plaintext : TYPEOF(plaintext);
232:               call_n  255  131          // 
233:                 meta    1    1          // 
234:           assignment  133    5          // tmp133 = '': STRING;
235:                 meta    2  133          // 
232:               call_n  133  131          //  // REWRITE
236:               retval                    // return tmp133;
// }
  6:         reg_var_decl  128               // var tmp128 .. tmp149; // REWRITE
237:                  ret                    // ret;
  4:                 meta    7    0          // function end: 238; // REWRITE
// /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
// function escCtrlChars(str) {  // escape control chars which might cause problems handling ciphertext
  0:          func_decl_n  254               // 
  1:                 meta    2  254          // 
  0:          func_decl_n  254               //  // REWRITE
  2:                 meta    7  255          // function end: 65537;
// 
//   return str.replace(/[\0\t\n\v\f\r\xa0'"!-]/g, function(c) { return '!' + c.charCodeAt(0) + '!'; });
  3:                 meta   12  255          // [to be rewritten]
// }  // \xa0 to cater for bug in Firefox; include '-' to leave it free for use as a block marker
  3:                 meta   12    6          // [no 'arguments'] [no 'eval']  // REWRITE
  4:         reg_var_decl  128               // var tmp128 .. tmp255;
// }  // \xa0 to cater for bug in Firefox; include '-' to leave it free for use as a block marker
  5:           assignment  130    5          // tmp130 = 'replace': STRING;
  6:          prop_getter  131  254          // tmp131 = str[tmp130];
  7:           assignment  132    6          // tmp132 = str : TYPEOF(str);
  8:               call_n  255  131          // 
  9:                 meta    1    1          // 
 10:           assignment  133    7          // tmp133 = 
 11:                 meta    2  133          // 
 12:          func_expr_n  255  255          // 
 13:                 meta    2  254          // 
 12:          func_expr_n  133  255          //  // REWRITE
 14:                 meta    7  255          // function end: 65549;
 15:                 meta   12  255          // [to be rewritten]
 15:                 meta   12    6          // [no 'arguments'] [no 'eval']  // REWRITE
 16:         reg_var_decl  128               // var tmp128 .. tmp255;
 17:           assignment  130    5          // tmp130 = '!': STRING;
 18:           assignment  131    5          // tmp131 = 'charCodeAt': STRING;
 19:          prop_getter  132  254          // tmp132 = c[tmp131];
 20:           assignment  133    6          // tmp133 = c : TYPEOF(c);
 21:               call_n  255  132          // 
 22:                 meta    1    1          // 
 23:           assignment  134    1          // tmp134 = 0: SMALLINT;
 24:                 meta    2  134          // 
 21:               call_n  134  132          //  // REWRITE
 25:             addition  135  130          // tmp135 = tmp130 + tmp134;
 26:           assignment  136    5          // tmp136 = '!': STRING;
 27:             addition  137  135          // tmp137 = tmp135 + tmp136;
 28:               retval                    // return tmp137;
 16:         reg_var_decl  128               // var tmp128 .. tmp137; // REWRITE
 29:                  ret                    // ret;
 14:                 meta    7    0          // function end: 30; // REWRITE
 30:                 meta    2  133          // tmp134 = tmp132 (this_arg = tmp133, tmp134, tmp133);
  8:               call_n  133  131          //  // REWRITE
 31:               retval                    // return tmp133;
// }  // \xa0 to cater for bug in Firefox; include '-' to leave it free for use as a block marker
  4:         reg_var_decl  128               // var tmp128 .. tmp133; // REWRITE
 32:                  ret                    // ret;
  2:                 meta    7    0          // function end: 33; // REWRITE
// 
// function unescCtrlChars(str) {  // unescape potentially problematic control characters
  0:          func_decl_n  254               // 
  1:                 meta    2  254          // 
  0:          func_decl_n  254               //  // REWRITE
  2:                 meta    7  255          // function end: 65537;
// 
//   return str.replace(/!\d\d?\d?!/g, function(c) { return String.fromCharCode(c.slice(1,-1)); });
  3:                 meta   12  255          // [to be rewritten]
// }
  3:                 meta   12    6          // [no 'arguments'] [no 'eval']  // REWRITE
  4:         reg_var_decl  128               // var tmp128 .. tmp255;
// }
  5:           assignment  130    5          // tmp130 = 'replace': STRING;
  6:          prop_getter  131  254          // tmp131 = str[tmp130];
  7:           assignment  132    6          // tmp132 = str : TYPEOF(str);
  8:               call_n  255  131          // 
  9:                 meta    1    1          // 
 10:           assignment  133    7          // tmp133 = 
 11:                 meta    2  133          // 
 12:          func_expr_n  255  255          // 
 13:                 meta    2  254          // 
 12:          func_expr_n  133  255          //  // REWRITE
 14:                 meta    7  255          // function end: 65549;
 15:                 meta   12  255          // [to be rewritten]
 15:                 meta   12    6          // [no 'arguments'] [no 'eval']  // REWRITE
 16:         reg_var_decl  128               // var tmp128 .. tmp255;
 17:           assignment  130    5          // tmp130 = 'fromCharCode': STRING;
 18:          prop_getter  131  254          // tmp131 = String[tmp130];
 19:           assignment  132    6          // tmp132 = String : TYPEOF(String);
 20:               call_n  255  131          // 
 21:                 meta    1    1          // 
 22:           assignment  133    5          // tmp133 = 'slice': STRING;
 23:          prop_getter  134  254          // tmp134 = c[tmp133];
 24:           assignment  135    6          // tmp135 = c : TYPEOF(c);
 25:               call_n  255  134          // 
 26:                 meta    1    1          // 
 27:           assignment  136    1          // tmp136 = 1: SMALLINT;
 28:                 meta    2  136          // 
 29:           assignment  136    1          // tmp136 = 1: SMALLINT;
 30:          unary_minus  137               // tmp137 = -tmp136;
 31:                 meta    2  137          // 
 25:               call_n  136  134          //  // REWRITE
 32:                 meta    2  136          // 
 20:               call_n  133  131          //  // REWRITE
 33:               retval                    // return tmp133;
 16:         reg_var_decl  128               // var tmp128 .. tmp137; // REWRITE
 34:                  ret                    // ret;
 14:                 meta    7    0          // function end: 35; // REWRITE
 35:                 meta    2  133          // tmp136 = tmp134 (this_arg = tmp135, tmp136, tmp137, tmp136, tmp133);
  8:               call_n  133  131          //  // REWRITE
 36:               retval                    // return tmp133;
// }
  4:         reg_var_decl  128               // var tmp128 .. tmp133; // REWRITE
 37:                  ret                    // ret;
  2:                 meta    7    0          // function end: 38; // REWRITE
// /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
// /*
// 
// var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
635:           assignment  130    5          // tmp130 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/': STRING;
636:           assignment  254    6          // b64 = tmp130 : TYPEOF(tmp130);
// function encodeBase64(str) {  // http://tools.ietf.org/html/rfc4648
  0:          func_decl_n  254               // 
  1:                 meta    2  254          // 
  0:          func_decl_n  254               //  // REWRITE
  2:                 meta    7  255          // function end: 65537;
// 
//    var o1, o2, o3, h1, h2, h3, h4, bits, i=0, enc='';
  3:                 meta   12  255          // [to be rewritten]
//    
//    str = encodeUTF8(str);  // encode multi-byte chars into UTF-8 for byte-array
// 
//    do {  // pack three octets into four hexets
// 
//       o1 = str.charCodeAt(i++);
//       o2 = str.charCodeAt(i++);
//       o3 = str.charCodeAt(i++);
//       
//       bits = o1<<16 | o2<<8 | o3;
//       
//       h1 = bits>>18 & 0x3f;
//       h2 = bits>>12 & 0x3f;
//       h3 = bits>>6 & 0x3f;
//       h4 = bits & 0x3f;
//       
//       // end of string? index to '=' in b64
// 
//       if (isNaN(o3)) h4 = 64;
//       if (isNaN(o2)) h3 = 64;
//       
//       // use hexets to index into b64, and append result to encoded string
// 
//       enc += b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
//    } while (i < str.length);
//    
//    return enc;
// }
  3:                 meta   12    6          // [no 'arguments'] [no 'eval']  // REWRITE
  4:         reg_var_decl  128               // var tmp128 .. tmp255;
  5:             var_decl                    // var o1;
  6:             var_decl                    // var o2;
  7:             var_decl                    // var o3;
  8:             var_decl                    // var h1;
  9:             var_decl                    // var h2;
 10:             var_decl                    // var h3;
 11:             var_decl                    // var h4;
 12:             var_decl                    // var bits;
 13:             var_decl                    // var i;
 14:             var_decl                    // var enc;
//    
//    str = encodeUTF8(str);  // encode multi-byte chars into UTF-8 for byte-array
// 
//    do {  // pack three octets into four hexets
// 
//       o1 = str.charCodeAt(i++);
//       o2 = str.charCodeAt(i++);
//       o3 = str.charCodeAt(i++);
//       
//       bits = o1<<16 | o2<<8 | o3;
//       
//       h1 = bits>>18 & 0x3f;
//       h2 = bits>>12 & 0x3f;
//       h3 = bits>>6 & 0x3f;
//       h4 = bits & 0x3f;
//       
//       // end of string? index to '=' in b64
// 
//       if (isNaN(o3)) h4 = 64;
//       if (isNaN(o2)) h3 = 64;
//       
//       // use hexets to index into b64, and append result to encoded string
// 
//       enc += b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
//    } while (i < str.length);
//    
//    return enc;
// }
 15:           assignment  130    1          // tmp130 = 0: SMALLINT;
 16:           assignment  254    6          // i = tmp130 : TYPEOF(tmp130);
 17:           assignment  131    5          // tmp131 = '': STRING;
 18:           assignment  254    6          // enc = tmp131 : TYPEOF(tmp131);
//    
//    str = encodeUTF8(str);  // encode multi-byte chars into UTF-8 for byte-array
 19:               call_n  255  254          // 
 20:                 meta    2  254          // 
 19:               call_n  130  254          //  // REWRITE
 21:           assignment  254    6          // str = tmp130 : TYPEOF(tmp130);
// 
//    do {  // pack three octets into four hexets
// 
//       o1 = str.charCodeAt(i++);
 22:           assignment  130    5          // tmp130 = 'charCodeAt': STRING;
 23:          prop_getter  131  254          // tmp131 = str[tmp130];
 24:           assignment  132    6          // tmp132 = str : TYPEOF(str);
 25:               call_n  255  131          // 
 26:                 meta    1    1          // 
 27:            post_incr  133               // tmp133 = i++;
 28:                 meta    2  133          // 
 25:               call_n  133  131          //  // REWRITE
 29:           assignment  254    6          // o1 = tmp133 : TYPEOF(tmp133);
//       o2 = str.charCodeAt(i++);
 30:           assignment  130    5          // tmp130 = 'charCodeAt': STRING;
 31:          prop_getter  131  254          // tmp131 = str[tmp130];
 32:           assignment  132    6          // tmp132 = str : TYPEOF(str);
 33:               call_n  255  131          // 
 34:                 meta    1    1          // 
 35:            post_incr  133               // tmp133 = i++;
 36:                 meta    2  133          // 
 33:               call_n  133  131          //  // REWRITE
 37:           assignment  254    6          // o2 = tmp133 : TYPEOF(tmp133);
//       o3 = str.charCodeAt(i++);
 38:           assignment  130    5          // tmp130 = 'charCodeAt': STRING;
 39:          prop_getter  131  254          // tmp131 = str[tmp130];
 40:           assignment  132    6          // tmp132 = str : TYPEOF(str);
 41:               call_n  255  131          // 
 42:                 meta    1    1          // 
 43:            post_incr  133               // tmp133 = i++;
 44:                 meta    2  133          // 
 41:               call_n  133  131          //  // REWRITE
 45:           assignment  254    6          // o3 = tmp133 : TYPEOF(tmp133);
//       
//       bits = o1<<16 | o2<<8 | o3;
 46:           assignment  130    6          // tmp130 = o1 : TYPEOF(o1);
 47:           assignment  131    1          // tmp131 = 16: SMALLINT;
 48:         b_shift_left  132  130          // tmp132 = tmp130 << tmp131;
 49:           assignment  133    6          // tmp133 = o2 : TYPEOF(o2);
 50:           assignment  134    1          // tmp134 = 8: SMALLINT;
 51:         b_shift_left  135  133          // tmp135 = tmp133 << tmp134;
 52:                 b_or  136  132          // tmp136 = tmp132 | tmp135;
 53:                 b_or  137  136          // tmp137 = tmp136 | o3;
 54:           assignment  254    6          // bits = tmp137 : TYPEOF(tmp137);
//       
//       h1 = bits>>18 & 0x3f;
 55:           assignment  130    6          // tmp130 = bits : TYPEOF(bits);
 56:           assignment  131    1          // tmp131 = 18: SMALLINT;
 57:        b_shift_right  132  130          // tmp132 = tmp130 >> tmp131;
 58:           assignment  133    1          // tmp133 = 63: SMALLINT;
 59:                b_and  134  132          // tmp134 = tmp132 & tmp133;
 60:           assignment  254    6          // h1 = tmp134 : TYPEOF(tmp134);
//       h2 = bits>>12 & 0x3f;
 61:           assignment  130    6          // tmp130 = bits : TYPEOF(bits);
 62:           assignment  131    1          // tmp131 = 12: SMALLINT;
 63:        b_shift_right  132  130          // tmp132 = tmp130 >> tmp131;
 64:           assignment  133    1          // tmp133 = 63: SMALLINT;
 65:                b_and  134  132          // tmp134 = tmp132 & tmp133;
 66:           assignment  254    6          // h2 = tmp134 : TYPEOF(tmp134);
//       h3 = bits>>6 & 0x3f;
 67:           assignment  130    6          // tmp130 = bits : TYPEOF(bits);
 68:           assignment  131    1          // tmp131 = 6: SMALLINT;
 69:        b_shift_right  132  130          // tmp132 = tmp130 >> tmp131;
 70:           assignment  133    1          // tmp133 = 63: SMALLINT;
 71:                b_and  134  132          // tmp134 = tmp132 & tmp133;
 72:           assignment  254    6          // h3 = tmp134 : TYPEOF(tmp134);
//       h4 = bits & 0x3f;
 73:           assignment  130    6          // tmp130 = bits : TYPEOF(bits);
 74:           assignment  131    1          // tmp131 = 63: SMALLINT;
 75:                b_and  132  130          // tmp132 = tmp130 & tmp131;
 76:           assignment  254    6          // h4 = tmp132 : TYPEOF(tmp132);
//       
//       // end of string? index to '=' in b64
// 
//       if (isNaN(o3)) h4 = 64;
 77:               call_n  255  254          // 
 78:                 meta    2  254          // 
 77:               call_n  130  254          //  // REWRITE
 79:    is_false_jmp_down  130  255          // if (tmp130 == false) goto 65614;
 80:           assignment  130    1          // tmp130 = 64: SMALLINT;
 81:           assignment  254    6          // h4 = tmp130 : TYPEOF(tmp130);
//       if (isNaN(o2)) h3 = 64;
 79:    is_false_jmp_down  130    0          // if (tmp130 == false) goto 82; // REWRITE
 82:               call_n  255  254          // 
 83:                 meta    2  254          // 
 82:               call_n  130  254          //  // REWRITE
 84:    is_false_jmp_down  130  255          // if (tmp130 == false) goto 65619;
 85:           assignment  130    1          // tmp130 = 64: SMALLINT;
 86:           assignment  254    6          // h3 = tmp130 : TYPEOF(tmp130);
//       
//       // use hexets to index into b64, and append result to encoded string
// 
//       enc += b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
 84:    is_false_jmp_down  130    0          // if (tmp130 == false) goto 87; // REWRITE
 87:           assignment  130    5          // tmp130 = 'charAt': STRING;
 88:          prop_getter  131  254          // tmp131 = b64[tmp130];
 89:           assignment  132    6          // tmp132 = b64 : TYPEOF(b64);
 90:               call_n  255  131          // 
 91:                 meta    1    1          // 
 92:                 meta    2  254          // 
 90:               call_n  133  131          //  // REWRITE
 93:           assignment  134    5          // tmp134 = 'charAt': STRING;
 94:          prop_getter  135  254          // tmp135 = b64[tmp134];
 95:           assignment  136    6          // tmp136 = b64 : TYPEOF(b64);
 96:               call_n  255  135          // 
 97:                 meta    1    1          // 
 98:                 meta    2  254          // 
 96:               call_n  137  135          //  // REWRITE
 99:             addition  138  133          // tmp138 = tmp133 + tmp137;
100:           assignment  139    5          // tmp139 = 'charAt': STRING;
101:          prop_getter  140  254          // tmp140 = b64[tmp139];
102:           assignment  141    6          // tmp141 = b64 : TYPEOF(b64);
103:               call_n  255  140          // 
104:                 meta    1    1          // 
105:                 meta    2  254          // 
103:               call_n  142  140          //  // REWRITE
106:             addition  143  138          // tmp143 = tmp138 + tmp142;
107:           assignment  144    5          // tmp144 = 'charAt': STRING;
108:          prop_getter  145  254          // tmp145 = b64[tmp144];
109:           assignment  146    6          // tmp146 = b64 : TYPEOF(b64);
110:               call_n  255  145          // 
111:                 meta    1    1          // 
112:                 meta    2  254          // 
110:               call_n  147  145          //  // REWRITE
113:             addition  148  143          // tmp148 = tmp143 + tmp147;
114:             addition  254  254          // enc = enc + tmp148;
115:           assignment  149    6          // tmp149 = enc : TYPEOF(enc);
//    } while (i < str.length);
116:           assignment  150    6          // tmp150 = i : TYPEOF(i);
117:           assignment  151    5          // tmp151 = 'length': STRING;
118:          prop_getter  152  254          // tmp152 = str[tmp151];
119:            less_than  153  150          // tmp153 = tmp150 < tmp152;
120:       is_true_jmp_up  153    0          // if (tmp153) goto 22;
//    
//    return enc;
121:               retval                    // return enc;
// }
  4:         reg_var_decl  128               // var tmp128 .. tmp153; // REWRITE
122:                  ret                    // ret;
  2:                 meta    7    0          // function end: 123; // REWRITE
// function decodeBase64(str) {
  0:          func_decl_n  254               // 
  1:                 meta    2  254          // 
  0:          func_decl_n  254               //  // REWRITE
  2:                 meta    7  255          // function end: 65537;
//    var o1, o2, o3, h1, h2, h3, h4, bits, i=0, enc='';
  3:                 meta   12  255          // [to be rewritten]
//    do {  // unpack four hexets into three octets using index points in b64
// 
//       h1 = b64.indexOf(str.charAt(i++));
//       h2 = b64.indexOf(str.charAt(i++));
//       h3 = b64.indexOf(str.charAt(i++));
//       h4 = b64.indexOf(str.charAt(i++));
//       
//       bits = h1<<18 | h2<<12 | h3<<6 | h4;
//       
//       o1 = bits>>16 & 0xff;
//       o2 = bits>>8 & 0xff;
//       o3 = bits & 0xff;
//       
//       if (h3 == 64)      enc += String.fromCharCode(o1);
//       else if (h4 == 64) enc += String.fromCharCode(o1, o2);
//       else               enc += String.fromCharCode(o1, o2, o3);
//    } while (i < str.length);
//    return decodeUTF8(enc);  // decode UTF-8 byte-array back to Unicode
// 
// }
  3:                 meta   12    6          // [no 'arguments'] [no 'eval']  // REWRITE
  4:         reg_var_decl  128               // var tmp128 .. tmp255;
  5:             var_decl                    // var o1;
  6:             var_decl                    // var o2;
  7:             var_decl                    // var o3;
  8:             var_decl                    // var h1;
  9:             var_decl                    // var h2;
 10:             var_decl                    // var h3;
 11:             var_decl                    // var h4;
 12:             var_decl                    // var bits;
 13:             var_decl                    // var i;
 14:             var_decl                    // var enc;
//    do {  // unpack four hexets into three octets using index points in b64
// 
//       h1 = b64.indexOf(str.charAt(i++));
//       h2 = b64.indexOf(str.charAt(i++));
//       h3 = b64.indexOf(str.charAt(i++));
//       h4 = b64.indexOf(str.charAt(i++));
//       
//       bits = h1<<18 | h2<<12 | h3<<6 | h4;
//       
//       o1 = bits>>16 & 0xff;
//       o2 = bits>>8 & 0xff;
//       o3 = bits & 0xff;
//       
//       if (h3 == 64)      enc += String.fromCharCode(o1);
//       else if (h4 == 64) enc += String.fromCharCode(o1, o2);
//       else               enc += String.fromCharCode(o1, o2, o3);
//    } while (i < str.length);
//    return decodeUTF8(enc);  // decode UTF-8 byte-array back to Unicode
// 
// }
 15:           assignment  130    1          // tmp130 = 0: SMALLINT;
 16:           assignment  254    6          // i = tmp130 : TYPEOF(tmp130);
 17:           assignment  131    5          // tmp131 = '': STRING;
 18:           assignment  254    6          // enc = tmp131 : TYPEOF(tmp131);
//    do {  // unpack four hexets into three octets using index points in b64
// 
//       h1 = b64.indexOf(str.charAt(i++));
 19:           assignment  130    5          // tmp130 = 'indexOf': STRING;
 20:          prop_getter  131  254          // tmp131 = b64[tmp130];
 21:           assignment  132    6          // tmp132 = b64 : TYPEOF(b64);
 22:               call_n  255  131          // 
 23:                 meta    1    1          // 
 24:           assignment  133    5          // tmp133 = 'charAt': STRING;
 25:          prop_getter  134  254          // tmp134 = str[tmp133];
 26:           assignment  135    6          // tmp135 = str : TYPEOF(str);
 27:               call_n  255  134          // 
 28:                 meta    1    1          // 
 29:            post_incr  136               // tmp136 = i++;
 30:                 meta    2  136          // 
 27:               call_n  136  134          //  // REWRITE
 31:                 meta    2  136          // tmp136 = tmp134 (this_arg = tmp135, tmp136, tmp136);
 22:               call_n  133  131          //  // REWRITE
 32:           assignment  254    6          // h1 = tmp133 : TYPEOF(tmp133);
//       h2 = b64.indexOf(str.charAt(i++));
 33:           assignment  130    5          // tmp130 = 'indexOf': STRING;
 34:          prop_getter  131  254          // tmp131 = b64[tmp130];
 35:           assignment  132    6          // tmp132 = b64 : TYPEOF(b64);
 36:               call_n  255  131          // 
 37:                 meta    1    1          // 
 38:           assignment  133    5          // tmp133 = 'charAt': STRING;
 39:          prop_getter  134  254          // tmp134 = str[tmp133];
 40:           assignment  135    6          // tmp135 = str : TYPEOF(str);
 41:               call_n  255  134          // 
 42:                 meta    1    1          // 
 43:            post_incr  136               // tmp136 = i++;
 44:                 meta    2  136          // 
 41:               call_n  136  134          //  // REWRITE
 45:                 meta    2  136          // tmp136 = tmp134 (this_arg = tmp135, tmp136, tmp136);
 36:               call_n  133  131          //  // REWRITE
 46:           assignment  254    6          // h2 = tmp133 : TYPEOF(tmp133);
//       h3 = b64.indexOf(str.charAt(i++));
 47:           assignment  130    5          // tmp130 = 'indexOf': STRING;
 48:          prop_getter  131  254          // tmp131 = b64[tmp130];
 49:           assignment  132    6          // tmp132 = b64 : TYPEOF(b64);
 50:               call_n  255  131          // 
 51:                 meta    1    1          // 
 52:           assignment  133    5          // tmp133 = 'charAt': STRING;
 53:          prop_getter  134  254          // tmp134 = str[tmp133];
 54:           assignment  135    6          // tmp135 = str : TYPEOF(str);
 55:               call_n  255  134          // 
 56:                 meta    1    1          // 
 57:            post_incr  136               // tmp136 = i++;
 58:                 meta    2  136          // 
 55:               call_n  136  134          //  // REWRITE
 59:                 meta    2  136          // tmp136 = tmp134 (this_arg = tmp135, tmp136, tmp136);
 50:               call_n  133  131          //  // REWRITE
 60:           assignment  254    6          // h3 = tmp133 : TYPEOF(tmp133);
//       h4 = b64.indexOf(str.charAt(i++));
 61:           assignment  130    5          // tmp130 = 'indexOf': STRING;
 62:          prop_getter  131  254          // tmp131 = b64[tmp130];
 63:           assignment  132    6          // tmp132 = b64 : TYPEOF(b64);
 64:               call_n  255  131          // 
 65:                 meta    1    1          // 
 66:           assignment  133    5          // tmp133 = 'charAt': STRING;
 67:          prop_getter  134  254          // tmp134 = str[tmp133];
 68:           assignment  135    6          // tmp135 = str : TYPEOF(str);
 69:               call_n  255  134          // 
 70:                 meta    1    1          // 
 71:            post_incr  136               // tmp136 = i++;
 72:                 meta    2  136          // 
 69:               call_n  136  134          //  // REWRITE
 73:                 meta    2  136          // tmp136 = tmp134 (this_arg = tmp135, tmp136, tmp136);
 64:               call_n  133  131          //  // REWRITE
 74:           assignment  254    6          // h4 = tmp133 : TYPEOF(tmp133);
//       
//       bits = h1<<18 | h2<<12 | h3<<6 | h4;
 75:           assignment  130    6          // tmp130 = h1 : TYPEOF(h1);
 76:           assignment  131    1          // tmp131 = 18: SMALLINT;
 77:         b_shift_left  132  130          // tmp132 = tmp130 << tmp131;
 78:           assignment  133    6          // tmp133 = h2 : TYPEOF(h2);
 79:           assignment  134    1          // tmp134 = 12: SMALLINT;
 80:         b_shift_left  135  133          // tmp135 = tmp133 << tmp134;
 81:                 b_or  136  132          // tmp136 = tmp132 | tmp135;
 82:           assignment  137    6          // tmp137 = h3 : TYPEOF(h3);
 83:           assignment  138    1          // tmp138 = 6: SMALLINT;
 84:         b_shift_left  139  137          // tmp139 = tmp137 << tmp138;
 85:                 b_or  140  136          // tmp140 = tmp136 | tmp139;
 86:                 b_or  141  140          // tmp141 = tmp140 | h4;
 87:           assignment  254    6          // bits = tmp141 : TYPEOF(tmp141);
//       
//       o1 = bits>>16 & 0xff;
 88:           assignment  130    6          // tmp130 = bits : TYPEOF(bits);
 89:           assignment  131    1          // tmp131 = 16: SMALLINT;
 90:        b_shift_right  132  130          // tmp132 = tmp130 >> tmp131;
 91:           assignment  133    1          // tmp133 = 255: SMALLINT;
 92:                b_and  134  132          // tmp134 = tmp132 & tmp133;
 93:           assignment  254    6          // o1 = tmp134 : TYPEOF(tmp134);
//       o2 = bits>>8 & 0xff;
 94:           assignment  130    6          // tmp130 = bits : TYPEOF(bits);
 95:           assignment  131    1          // tmp131 = 8: SMALLINT;
 96:        b_shift_right  132  130          // tmp132 = tmp130 >> tmp131;
 97:           assignment  133    1          // tmp133 = 255: SMALLINT;
 98:                b_and  134  132          // tmp134 = tmp132 & tmp133;
 99:           assignment  254    6          // o2 = tmp134 : TYPEOF(tmp134);
//       o3 = bits & 0xff;
100:           assignment  130    6          // tmp130 = bits : TYPEOF(bits);
101:           assignment  131    1          // tmp131 = 255: SMALLINT;
102:                b_and  132  130          // tmp132 = tmp130 & tmp131;
103:           assignment  254    6          // o3 = tmp132 : TYPEOF(tmp132);
//       
//       if (h3 == 64)      enc += String.fromCharCode(o1);
104:           assignment  130    6          // tmp130 = h3 : TYPEOF(h3);
105:           assignment  131    1          // tmp131 = 64: SMALLINT;
106:          equal_value  132  130          // tmp132 = tmp130 == tmp131;
107:    is_false_jmp_down  132  255          // if (tmp132 == false) goto 65642;
108:           assignment  130    5          // tmp130 = 'fromCharCode': STRING;
109:          prop_getter  131  254          // tmp131 = String[tmp130];
110:           assignment  132    6          // tmp132 = String : TYPEOF(String);
111:               call_n  255  131          // 
112:                 meta    1    1          // 
113:                 meta    2  254          // 
111:               call_n  133  131          //  // REWRITE
114:             addition  254  254          // enc = enc + tmp133;
115:           assignment  134    6          // tmp134 = enc : TYPEOF(enc);
//       else if (h4 == 64) enc += String.fromCharCode(o1, o2);
116:             jmp_down  255               // goto 65651;
107:    is_false_jmp_down  132    0          // if (tmp132 == false) goto 117; // REWRITE
117:           assignment  130    6          // tmp130 = h4 : TYPEOF(h4);
118:           assignment  131    1          // tmp131 = 64: SMALLINT;
119:          equal_value  132  130          // tmp132 = tmp130 == tmp131;
120:    is_false_jmp_down  132  255          // if (tmp132 == false) goto 65655;
121:           assignment  130    5          // tmp130 = 'fromCharCode': STRING;
122:          prop_getter  131  254          // tmp131 = String[tmp130];
123:           assignment  132    6          // tmp132 = String : TYPEOF(String);
124:               call_n  255  131          // 
125:                 meta    1    1          // 
126:                 meta    2  254          // 
127:                 meta    2  254          // 
124:               call_n  133  131          //  // REWRITE
128:             addition  254  254          // enc = enc + tmp133;
129:           assignment  134    6          // tmp134 = enc : TYPEOF(enc);
//       else               enc += String.fromCharCode(o1, o2, o3);
130:             jmp_down  255               // goto 65665;
120:    is_false_jmp_down  132    0          // if (tmp132 == false) goto 131; // REWRITE
131:           assignment  130    5          // tmp130 = 'fromCharCode': STRING;
132:          prop_getter  131  254          // tmp131 = String[tmp130];
133:           assignment  132    6          // tmp132 = String : TYPEOF(String);
134:               call_n  255  131          // 
135:                 meta    1    1          // 
136:                 meta    2  254          // 
137:                 meta    2  254          // 
138:                 meta    2  254          // 
134:               call_n  133  131          //  // REWRITE
139:             addition  254  254          // enc = enc + tmp133;
140:           assignment  134    6          // tmp134 = enc : TYPEOF(enc);
130:             jmp_down    0               // goto 141; // REWRITE
116:             jmp_down    0               // goto 141; // REWRITE
//    } while (i < str.length);
141:           assignment  135    6          // tmp135 = i : TYPEOF(i);
142:           assignment  136    5          // tmp136 = 'length': STRING;
143:          prop_getter  137  254          // tmp137 = str[tmp136];
144:            less_than  138  135          // tmp138 = tmp135 < tmp137;
145:       is_true_jmp_up  138    0          // if (tmp138) goto 19;
//    return decodeUTF8(enc);  // decode UTF-8 byte-array back to Unicode
146:               call_n  255  254          // 
147:                 meta    2  254          // 
146:               call_n  130  254          //  // REWRITE
148:               retval                    // return tmp130;
// 
// }
  4:         reg_var_decl  128               // var tmp128 .. tmp141; // REWRITE
149:                  ret                    // ret;
  2:                 meta    7    0          // function end: 150; // REWRITE
// function encodeUTF8(str) {  // encode multi-byte string into utf-8 multiple single-byte characters 
  0:          func_decl_n  254               // 
  1:                 meta    2  254          // 
  0:          func_decl_n  254               //  // REWRITE
  2:                 meta    7  255          // function end: 65537;
// 
//   str = str.replace(
  3:                 meta   12  255          // [to be rewritten]
//       /[\u0080-\u07ff]/g,  // U+0080 - U+07FF = 2-byte chars
// 
//       function(c) { 
//         var cc = c.charCodeAt(0);
//         return String.fromCharCode(0xc0 | cc>>6, 0x80 | cc&0x3f); }
//     );
//   str = str.replace(
//       /[\u0800-\uffff]/g,  // U+0800 - U+FFFF = 3-byte chars
// 
//       function(c) { 
//         var cc = c.charCodeAt(0); 
//         return String.fromCharCode(0xe0 | cc>>12, 0x80 | cc>>6&0x3F, 0x80 | cc&0x3f); }
//     );
//   return str;
// }
  3:                 meta   12    6          // [no 'arguments'] [no 'eval']  // REWRITE
  4:         reg_var_decl  128               // var tmp128 .. tmp255;
//       /[\u0080-\u07ff]/g,  // U+0080 - U+07FF = 2-byte chars
// 
//       function(c) { 
//         var cc = c.charCodeAt(0);
//         return String.fromCharCode(0xc0 | cc>>6, 0x80 | cc&0x3f); }
//     );
//   str = str.replace(
//       /[\u0800-\uffff]/g,  // U+0800 - U+FFFF = 3-byte chars
// 
//       function(c) { 
//         var cc = c.charCodeAt(0); 
//         return String.fromCharCode(0xe0 | cc>>12, 0x80 | cc>>6&0x3F, 0x80 | cc&0x3f); }
//     );
//   return str;
// }
  5:           assignment  130    5          // tmp130 = 'replace': STRING;
  6:          prop_getter  131  254          // tmp131 = str[tmp130];
  7:           assignment  132    6          // tmp132 = str : TYPEOF(str);
  8:               call_n  255  131          // 
  9:                 meta    1    1          // 
//       /[\u0080-\u07ff]/g,  // U+0080 - U+07FF = 2-byte chars
 10:           assignment  133    7          // tmp133 = 
 11:                 meta    2  133          // 
// 
//       function(c) { 
 12:          func_expr_n  255  255          // 
 13:                 meta    2  254          // 
 12:          func_expr_n  133  255          //  // REWRITE
 14:                 meta    7  255          // function end: 65549;
//         var cc = c.charCodeAt(0);
 15:                 meta   12  255          // [to be rewritten]
//         return String.fromCharCode(0xc0 | cc>>6, 0x80 | cc&0x3f); }
 15:                 meta   12    6          // [no 'arguments'] [no 'eval']  // REWRITE
 16:         reg_var_decl  128               // var tmp128 .. tmp255;
 17:             var_decl                    // var cc;
//         return String.fromCharCode(0xc0 | cc>>6, 0x80 | cc&0x3f); }
 18:           assignment  130    5          // tmp130 = 'charCodeAt': STRING;
 19:          prop_getter  131  254          // tmp131 = c[tmp130];
 20:           assignment  132    6          // tmp132 = c : TYPEOF(c);
 21:               call_n  255  131          // 
 22:                 meta    1    1          // 
 23:           assignment  133    1          // tmp133 = 0: SMALLINT;
 24:                 meta    2  133          // 
 21:               call_n  133  131          //  // REWRITE
 25:           assignment  254    6          // cc = tmp133 : TYPEOF(tmp133);
//         return String.fromCharCode(0xc0 | cc>>6, 0x80 | cc&0x3f); }
 26:           assignment  130    5          // tmp130 = 'fromCharCode': STRING;
 27:          prop_getter  131  254          // tmp131 = String[tmp130];
 28:           assignment  132    6          // tmp132 = String : TYPEOF(String);
 29:               call_n  255  131          // 
 30:                 meta    1    1          // 
 31:           assignment  133    1          // tmp133 = 192: SMALLINT;
 32:           assignment  134    6          // tmp134 = cc : TYPEOF(cc);
 33:           assignment  135    1          // tmp135 = 6: SMALLINT;
 34:        b_shift_right  136  134          // tmp136 = tmp134 >> tmp135;
 35:                 b_or  137  133          // tmp137 = tmp133 | tmp136;
 36:                 meta    2  137          // 
 37:           assignment  133    1          // tmp133 = 128: SMALLINT;
 38:           assignment  134    6          // tmp134 = cc : TYPEOF(cc);
 39:           assignment  135    1          // tmp135 = 63: SMALLINT;
 40:                b_and  136  134          // tmp136 = tmp134 & tmp135;
 41:                 b_or  137  133          // tmp137 = tmp133 | tmp136;
 42:                 meta    2  137          // 
 29:               call_n  133  131          //  // REWRITE
 43:               retval                    // return tmp133;
 16:         reg_var_decl  128               // var tmp128 .. tmp137; // REWRITE
 44:                  ret                    // ret;
 14:                 meta    7    0          // function end: 45; // REWRITE
//     );
 45:                 meta    2  133          // 
  8:               call_n  133  131          //  // REWRITE
 46:           assignment  254    6          // str = tmp133 : TYPEOF(tmp133);
//   str = str.replace(
 47:           assignment  130    5          // tmp130 = 'replace': STRING;
 48:          prop_getter  131  254          // tmp131 = str[tmp130];
 49:           assignment  132    6          // tmp132 = str : TYPEOF(str);
 50:               call_n  255  131          // 
 51:                 meta    1    1          // 
//       /[\u0800-\uffff]/g,  // U+0800 - U+FFFF = 3-byte chars
 52:           assignment  133    7          // tmp133 = 
 53:                 meta    2  133          // 
// 
//       function(c) { 
 54:          func_expr_n  255  255          // 
 55:                 meta    2  254          // 
 54:          func_expr_n  133  255          //  // REWRITE
 56:                 meta    7  255          // function end: 65591;
//         var cc = c.charCodeAt(0); 
 57:                 meta   12  255          // [to be rewritten]
//         return String.fromCharCode(0xe0 | cc>>12, 0x80 | cc>>6&0x3F, 0x80 | cc&0x3f); }
 57:                 meta   12    6          // [no 'arguments'] [no 'eval']  // REWRITE
 58:         reg_var_decl  128               // var tmp128 .. tmp255;
 59:             var_decl                    // var cc;
//         return String.fromCharCode(0xe0 | cc>>12, 0x80 | cc>>6&0x3F, 0x80 | cc&0x3f); }
 60:           assignment  130    5          // tmp130 = 'charCodeAt': STRING;
 61:          prop_getter  131  254          // tmp131 = c[tmp130];
 62:           assignment  132    6          // tmp132 = c : TYPEOF(c);
 63:               call_n  255  131          // 
 64:                 meta    1    1          // 
 65:           assignment  133    1          // tmp133 = 0: SMALLINT;
 66:                 meta    2  133          // 
 63:               call_n  133  131          //  // REWRITE
 67:           assignment  254    6          // cc = tmp133 : TYPEOF(tmp133);
//         return String.fromCharCode(0xe0 | cc>>12, 0x80 | cc>>6&0x3F, 0x80 | cc&0x3f); }
 68:           assignment  130    5          // tmp130 = 'fromCharCode': STRING;
 69:          prop_getter  131  254          // tmp131 = String[tmp130];
 70:           assignment  132    6          // tmp132 = String : TYPEOF(String);
 71:               call_n  255  131          // 
 72:                 meta    1    1          // 
 73:           assignment  133    1          // tmp133 = 224: SMALLINT;
 74:           assignment  134    6          // tmp134 = cc : TYPEOF(cc);
 75:           assignment  135    1          // tmp135 = 12: SMALLINT;
 76:        b_shift_right  136  134          // tmp136 = tmp134 >> tmp135;
 77:                 b_or  137  133          // tmp137 = tmp133 | tmp136;
 78:                 meta    2  137          // 
 79:           assignment  133    1          // tmp133 = 128: SMALLINT;
 80:           assignment  134    6          // tmp134 = cc : TYPEOF(cc);
 81:           assignment  135    1          // tmp135 = 6: SMALLINT;
 82:        b_shift_right  136  134          // tmp136 = tmp134 >> tmp135;
 83:           assignment  137    1          // tmp137 = 63: SMALLINT;
 84:                b_and  138  136          // tmp138 = tmp136 & tmp137;
 85:                 b_or  139  133          // tmp139 = tmp133 | tmp138;
 86:                 meta    2  139          // 
 87:           assignment  133    1          // tmp133 = 128: SMALLINT;
 88:           assignment  134    6          // tmp134 = cc : TYPEOF(cc);
 89:           assignment  135    1          // tmp135 = 63: SMALLINT;
 90:                b_and  136  134          // tmp136 = tmp134 & tmp135;
 91:                 b_or  137  133          // tmp137 = tmp133 | tmp136;
 92:                 meta    2  137          // 
 71:               call_n  133  131          //  // REWRITE
 93:               retval                    // return tmp133;
 58:         reg_var_decl  128               // var tmp128 .. tmp139; // REWRITE
 94:                  ret                    // ret;
 56:                 meta    7    0          // function end: 95; // REWRITE
//     );
 95:                 meta    2  133          // 
 50:               call_n  133  131          //  // REWRITE
 96:           assignment  254    6          // str = tmp133 : TYPEOF(tmp133);
//   return str;
 97:               retval                    // return str;
// }
  4:         reg_var_decl  128               // var tmp128 .. tmp133; // REWRITE
 98:                  ret                    // ret;
  2:                 meta    7    0          // function end: 99; // REWRITE
// function decodeUTF8(str) {  // decode utf-8 encoded string back into multi-byte characters
  0:          func_decl_n  254               // 
  1:                 meta    2  254          // 
  0:          func_decl_n  254               //  // REWRITE
  2:                 meta    7  255          // function end: 65537;
// 
//   str = str.replace(
  3:                 meta   12  255          // [to be rewritten]
//       /[\u00c0-\u00df][\u0080-\u00bf]/g,                 // 2-byte chars
// 
//       function(c) { 
//         var cc = (c.charCodeAt(0)&0x1f)<<6 | c.charCodeAt(1)&0x3f;
//         return String.fromCharCode(cc); }
//     );
//   str = str.replace(
//       /[\u00e0-\u00ef][\u0080-\u00bf][\u0080-\u00bf]/g,  // 3-byte chars
// 
//       function(c) { 
//         var cc = (c.charCodeAt(0)&0x0f)<<12 | (c.charCodeAt(1)&0x3f<<6) | c.charCodeAt(2)&0x3f; 
//         return String.fromCharCode(cc); }
//     );
//   return str;
// }
  3:                 meta   12    6          // [no 'arguments'] [no 'eval']  // REWRITE
  4:         reg_var_decl  128               // var tmp128 .. tmp255;
//       /[\u00c0-\u00df][\u0080-\u00bf]/g,                 // 2-byte chars
// 
//       function(c) { 
//         var cc = (c.charCodeAt(0)&0x1f)<<6 | c.charCodeAt(1)&0x3f;
//         return String.fromCharCode(cc); }
//     );
//   str = str.replace(
//       /[\u00e0-\u00ef][\u0080-\u00bf][\u0080-\u00bf]/g,  // 3-byte chars
// 
//       function(c) { 
//         var cc = (c.charCodeAt(0)&0x0f)<<12 | (c.charCodeAt(1)&0x3f<<6) | c.charCodeAt(2)&0x3f; 
//         return String.fromCharCode(cc); }
//     );
//   return str;
// }
  5:           assignment  130    5          // tmp130 = 'replace': STRING;
  6:          prop_getter  131  254          // tmp131 = str[tmp130];
  7:           assignment  132    6          // tmp132 = str : TYPEOF(str);
  8:               call_n  255  131          // 
  9:                 meta    1    1          // 
//       /[\u00c0-\u00df][\u0080-\u00bf]/g,                 // 2-byte chars
 10:           assignment  133    7          // tmp133 = 
 11:                 meta    2  133          // 
// 
//       function(c) { 
 12:          func_expr_n  255  255          // 
 13:                 meta    2  254          // 
 12:          func_expr_n  133  255          //  // REWRITE
 14:                 meta    7  255          // function end: 65549;
//         var cc = (c.charCodeAt(0)&0x1f)<<6 | c.charCodeAt(1)&0x3f;
 15:                 meta   12  255          // [to be rewritten]
//         return String.fromCharCode(cc); }
 15:                 meta   12    6          // [no 'arguments'] [no 'eval']  // REWRITE
 16:         reg_var_decl  128               // var tmp128 .. tmp255;
 17:             var_decl                    // var cc;
//         return String.fromCharCode(cc); }
 18:           assignment  130    5          // tmp130 = 'charCodeAt': STRING;
 19:          prop_getter  131  254          // tmp131 = c[tmp130];
 20:           assignment  132    6          // tmp132 = c : TYPEOF(c);
 21:               call_n  255  131          // 
 22:                 meta    1    1          // 
 23:           assignment  133    1          // tmp133 = 0: SMALLINT;
 24:                 meta    2  133          // 
 21:               call_n  133  131          //  // REWRITE
 25:           assignment  134    1          // tmp134 = 31: SMALLINT;
 26:                b_and  135  133          // tmp135 = tmp133 & tmp134;
 27:           assignment  136    1          // tmp136 = 6: SMALLINT;
 28:         b_shift_left  137  135          // tmp137 = tmp135 << tmp136;
 29:           assignment  138    5          // tmp138 = 'charCodeAt': STRING;
 30:          prop_getter  139  254          // tmp139 = c[tmp138];
 31:           assignment  140    6          // tmp140 = c : TYPEOF(c);
 32:               call_n  255  139          // 
 33:                 meta    1    1          // 
 34:           assignment  141    1          // tmp141 = 1: SMALLINT;
 35:                 meta    2  141          // 
 32:               call_n  141  139          //  // REWRITE
 36:           assignment  142    1          // tmp142 = 63: SMALLINT;
 37:                b_and  143  141          // tmp143 = tmp141 & tmp142;
 38:                 b_or  144  137          // tmp144 = tmp137 | tmp143;
 39:           assignment  254    6          // cc = tmp144 : TYPEOF(tmp144);
//         return String.fromCharCode(cc); }
 40:           assignment  130    5          // tmp130 = 'fromCharCode': STRING;
 41:          prop_getter  131  254          // tmp131 = String[tmp130];
 42:           assignment  132    6          // tmp132 = String : TYPEOF(String);
 43:               call_n  255  131          // 
 44:                 meta    1    1          // 
 45:                 meta    2  254          // 
 43:               call_n  133  131          //  // REWRITE
 46:               retval                    // return tmp133;
 16:         reg_var_decl  128               // var tmp128 .. tmp144; // REWRITE
 47:                  ret                    // ret;
 14:                 meta    7    0          // function end: 48; // REWRITE
//     );
 48:                 meta    2  133          // tmp133 = tmp131 (this_arg = tmp132, hz, tmp133);
  8:               call_n  133  131          //  // REWRITE
 49:           assignment  254    6          // str = tmp133 : TYPEOF(tmp133);
//   str = str.replace(
 50:           assignment  130    5          // tmp130 = 'replace': STRING;
 51:          prop_getter  131  254          // tmp131 = str[tmp130];
 52:           assignment  132    6          // tmp132 = str : TYPEOF(str);
 53:               call_n  255  131          // 
 54:                 meta    1    1          // 
//       /[\u00e0-\u00ef][\u0080-\u00bf][\u0080-\u00bf]/g,  // 3-byte chars
 55:           assignment  133    7          // tmp133 = 
 56:                 meta    2  133          // 
// 
//       function(c) { 
 57:          func_expr_n  255  255          // 
 58:                 meta    2  254          // 
 57:          func_expr_n  133  255          //  // REWRITE
 59:                 meta    7  255          // function end: 65594;
//         var cc = (c.charCodeAt(0)&0x0f)<<12 | (c.charCodeAt(1)&0x3f<<6) | c.charCodeAt(2)&0x3f; 
 60:                 meta   12  255          // [to be rewritten]
//         return String.fromCharCode(cc); }
 60:                 meta   12    6          // [no 'arguments'] [no 'eval']  // REWRITE
 61:         reg_var_decl  128               // var tmp128 .. tmp255;
 62:             var_decl                    // var cc;
//         return String.fromCharCode(cc); }
 63:           assignment  130    5          // tmp130 = 'charCodeAt': STRING;
 64:          prop_getter  131  254          // tmp131 = c[tmp130];
 65:           assignment  132    6          // tmp132 = c : TYPEOF(c);
 66:               call_n  255  131          // 
 67:                 meta    1    1          // 
 68:           assignment  133    1          // tmp133 = 0: SMALLINT;
 69:                 meta    2  133          // 
 66:               call_n  133  131          //  // REWRITE
 70:           assignment  134    1          // tmp134 = 15: SMALLINT;
 71:                b_and  135  133          // tmp135 = tmp133 & tmp134;
 72:           assignment  136    1          // tmp136 = 12: SMALLINT;
 73:         b_shift_left  137  135          // tmp137 = tmp135 << tmp136;
 74:           assignment  138    5          // tmp138 = 'charCodeAt': STRING;
 75:          prop_getter  139  254          // tmp139 = c[tmp138];
 76:           assignment  140    6          // tmp140 = c : TYPEOF(c);
 77:               call_n  255  139          // 
 78:                 meta    1    1          // 
 79:           assignment  141    1          // tmp141 = 1: SMALLINT;
 80:                 meta    2  141          // 
 77:               call_n  141  139          //  // REWRITE
 81:           assignment  142    1          // tmp142 = 63: SMALLINT;
 82:           assignment  143    1          // tmp143 = 6: SMALLINT;
 83:         b_shift_left  144  142          // tmp144 = tmp142 << tmp143;
 84:                b_and  145  141          // tmp145 = tmp141 & tmp144;
 85:                 b_or  146  137          // tmp146 = tmp137 | tmp145;
 86:           assignment  147    5          // tmp147 = 'charCodeAt': STRING;
 87:          prop_getter  148  254          // tmp148 = c[tmp147];
 88:           assignment  149    6          // tmp149 = c : TYPEOF(c);
 89:               call_n  255  148          // 
 90:                 meta    1    1          // 
 91:           assignment  150    1          // tmp150 = 2: SMALLINT;
 92:                 meta    2  150          // 
 89:               call_n  150  148          //  // REWRITE
 93:           assignment  151    1          // tmp151 = 63: SMALLINT;
 94:                b_and  152  150          // tmp152 = tmp150 & tmp151;
 95:                 b_or  153  146          // tmp153 = tmp146 | tmp152;
 96:           assignment  254    6          // cc = tmp153 : TYPEOF(tmp153);
//         return String.fromCharCode(cc); }
 97:           assignment  130    5          // tmp130 = 'fromCharCode': STRING;
 98:          prop_getter  131  254          // tmp131 = String[tmp130];
 99:           assignment  132    6          // tmp132 = String : TYPEOF(String);
100:               call_n  255  131          // 
101:                 meta    1    1          // 
102:                 meta    2  254          // 
100:               call_n  133  131          //  // REWRITE
103:               retval                    // return tmp133;
 61:         reg_var_decl  128               // var tmp128 .. tmp153; // REWRITE
104:                  ret                    // ret;
 59:                 meta    7    0          // function end: 105; // REWRITE
//     );
105:                 meta    2  133          // tmp133 = tmp131 (this_arg = tmp132, hz, tmp133);
 53:               call_n  133  131          //  // REWRITE
106:           assignment  254    6          // str = tmp133 : TYPEOF(tmp133);
//   return str;
107:               retval                    // return str;
// }
  4:         reg_var_decl  128               // var tmp128 .. tmp133; // REWRITE
108:                  ret                    // ret;
  2:                 meta    7    0          // function end: 109; // REWRITE
// function byteArrayToHexStr(b) {  // convert byte array to hex string for displaying test vectors
  0:          func_decl_n  254               // 
  1:                 meta    2  254          // 
  0:          func_decl_n  254               //  // REWRITE
  2:                 meta    7  255          // function end: 65537;
// 
//   var s = '';
  3:                 meta   12  255          // [to be rewritten]
//   for (var i=0; i<b.length; i++) s += b[i].toString(16) + ' ';
//   return s;
// }
  3:                 meta   12    6          // [no 'arguments'] [no 'eval']  // REWRITE
  4:         reg_var_decl  128               // var tmp128 .. tmp255;
  5:             var_decl                    // var s;
//   for (var i=0; i<b.length; i++) s += b[i].toString(16) + ' ';
  6:             var_decl                    // var i;
//   return s;
// }
  7:           assignment  130    5          // tmp130 = '': STRING;
  8:           assignment  254    6          // s = tmp130 : TYPEOF(tmp130);
//   for (var i=0; i<b.length; i++) s += b[i].toString(16) + ' ';
  9:           assignment  130    1          // tmp130 = 0: SMALLINT;
 10:           assignment  254    6          // i = tmp130 : TYPEOF(tmp130);
 11:             jmp_down  255               // goto 65546;
 12:          prop_getter  130  254          // tmp130 = b[i];
 13:           assignment  131    5          // tmp131 = 'toString': STRING;
 14:          prop_getter  132  130          // tmp132 = tmp130[tmp131];
 15:               call_n  255  132          // 
 16:                 meta    1    1          // 
 17:           assignment  133    1          // tmp133 = 16: SMALLINT;
 18:                 meta    2  133          // 
 15:               call_n  133  132          //  // REWRITE
 19:           assignment  134    5          // tmp134 = ' ': STRING;
 20:             addition  135  133          // tmp135 = tmp133 + tmp134;
 21:             addition  254  254          // s = s + tmp135;
 22:           assignment  136    6          // tmp136 = s : TYPEOF(s);
 23:            post_incr  137               // tmp137 = i++;
 11:             jmp_down    0               // goto 24; // REWRITE
 24:           assignment  138    6          // tmp138 = i : TYPEOF(i);
 25:           assignment  139    5          // tmp139 = 'length': STRING;
 26:          prop_getter  140  254          // tmp140 = b[tmp139];
 27:            less_than  141  138          // tmp141 = tmp138 < tmp140;
 28:       is_true_jmp_up  141    0          // if (tmp141) goto 12;
//   return s;
 29:               retval                    // return s;
// }
  4:         reg_var_decl  128               // var tmp128 .. tmp141; // REWRITE
 30:                  ret                    // ret;
  2:                 meta    7    0          // function end: 31; // REWRITE
// /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
// var plainText = "ROMEO: But, soft! what light through yonder window breaks?\n\
637:           assignment  130    5          // tmp130 = 'ROMEO: But, soft! what light through yonder window breaks?
It is': STRING;
638:           assignment  254    6          // plainText = tmp130 : TYPEOF(tmp130);
// var password = "O Romeo, Romeo! wherefore art thou Romeo?";
639:           assignment  130    5          // tmp130 = 'O Romeo, Romeo! wherefore art thou Romeo?': STRING;
640:           assignment  254    6          // password = tmp130 : TYPEOF(tmp130);
// var cipherText = AESEncryptCtr(plainText, password, 256);
641:               call_n  255  254          // 
642:                 meta    2  254          // 
643:                 meta    2  254          // 
644:           assignment  130    3          // tmp130 = 256: NUMBER;
645:                 meta    2  130          // 
641:               call_n  130  254          //  // REWRITE
646:           assignment  254    6          // cipherText = tmp130 : TYPEOF(tmp130);
// var decryptedText = AESDecryptCtr(cipherText, password, 256);
647:               call_n  255  254          // 
648:                 meta    2  254          // 
649:                 meta    2  254          // 
650:           assignment  130    3          // tmp130 = 256: NUMBER;
651:                 meta    2  130          // 
647:               call_n  130  254          //  // REWRITE
652:           assignment  254    6          // decryptedText = tmp130 : TYPEOF(tmp130);
// if (decryptedText != plainText)
653:           assignment  130    6          // tmp130 = decryptedText : TYPEOF(decryptedText);
654:      not_equal_value  131  130          // tmp131 = tmp130 != plainText;
655:    is_false_jmp_down  131  255          // if (tmp131 == false) goto 66190;
//     throw "ERROR: bad result: expected " + plainText + " but got " + decryptedText;
656:           assignment  130    5          // tmp130 = 'ERROR: bad result: expected ': STRING;
657:             addition  131  130          // tmp131 = tmp130 + plainText;
658:           assignment  132    5          // tmp132 = ' but got ': STRING;
659:             addition  133  131          // tmp133 = tmp131 + tmp132;
660:             addition  134  133          // tmp134 = tmp133 + decryptedText;
661:          throw_value                    // throw tmp134;
// 
655:    is_false_jmp_down  131    0          // if (tmp131 == false) goto 662; // REWRITE
  1:         reg_var_decl  128               // var tmp128 .. tmp134; // REWRITE
662:                  ret                    // ret;
LITERALS:
0x84ec54 [ 12] Cipher : STRING
0x84ec60 [  4] input : MAGIC STRING [id=21] 
0x84ec64 [  8] w : STRING
0x84ec6c [  8] Nb : STRING
0x84ec74 [  8] Nr : STRING
0x84ec7c [  4] length : MAGIC STRING [id=15] 
0x84ec94 [ 12] state : STRING
0x84eca0 [  4] i : MAGIC STRING [id=200] 
0x84eca4 [  4] Math : MAGIC STRING [id=44] 
0x84eca8 [  4] floor : MAGIC STRING [id=91] 
0x84ecac [ 20] AddRoundKey : STRING
0x84ecd4 [  4] round : MAGIC STRING [id=97] 
0x84ecd8 [ 16] SubBytes : STRING
0x84ece8 [ 16] ShiftRows : STRING
0x84ecf8 [ 16] MixColumns : STRING
0x84ed1c [ 12] output : STRING
0x84ed28 [  4] Array : MAGIC STRING [id=29] 
0x84ed2c [  8] s : STRING
0x84ed34 [  8] r : STRING
0x84ed3c [  8] c : STRING
0x84ed58 [ 12] Sbox : STRING
0x84ed64 [  8] t : STRING
0x84ed6c [  8] a : STRING
0x84ed74 [  8] b : STRING
0x84ed7c [ 12] 283 : NUMBER
0x84ed9c [ 12] rnd : STRING
0x84eda8 [ 20] KeyExpansion : STRING
0x84edbc [ 12] key : STRING
0x84eddc [  8] Nk : STRING
0x84ede4 [ 12] temp : STRING
0x84edf0 [ 16] SubWord : STRING
0x84ee14 [ 16] RotWord : STRING
0x84ee24 [ 12] Rcon : STRING
0x84ee30 [ 20] AESEncryptCtr : STRING
0x84ee58 [ 16] plaintext : STRING
0x84ee68 [ 16] password : STRING
0x84ee78 [ 12] nBits : STRING
0x84ee98 [ 12] 256 : NUMBER
0x84eea4 [  4]  : MAGIC STRING [id=218] 
0x84eea8 [ 12] nBytes : STRING
0x84eeb4 [ 16] pwBytes : STRING
0x84eed8 [  4] charCodeAt : MAGIC STRING [id=129] 
0x84eedc [  4] concat : MAGIC STRING [id=109] 
0x84eee0 [  4] slice : MAGIC STRING [id=115] 
0x84eee4 [ 16] blockSize : STRING
0x84eef4 [ 20] counterBlock : STRING
0x84ef1c [ 12] nonce : STRING
0x84ef28 [  4] Date : MAGIC STRING [id=34] 
0x84ef2c [  4] getTime : MAGIC STRING [id=149] 
0x84ef30 [ 12] 4294967296 : NUMBER
0x84ef3c [ 20] keySchedule : STRING
0x84ef64 [ 16] blockCount : STRING
0x84ef74 [  4] ceil : MAGIC STRING [id=88] 
0x84ef78 [ 16] ciphertext : STRING
0x84ef9c [ 16] cipherCntr : STRING
0x84efac [ 20] blockLength : STRING
0x84efd4 [  8] ct : STRING
0x84efdc [ 20] plaintextByte : STRING
0x84eff0 [ 16] cipherByte : STRING
0x84f014 [  4] String : MAGIC STRING [id=31] 
0x84f018 [  4] fromCharCode : MAGIC STRING [id=101] 
0x84f01c [ 20] escCtrlChars : STRING
0x84f030 [ 12] ctrTxt : STRING
0x84f03c [  4] - : MAGIC STRING [id=211] 
0x84f054 [  4] join : MAGIC STRING [id=111] 
0x84f058 [ 20] AESDecryptCtr : STRING
0x84f06c [ 20] pwKeySchedule : STRING
0x84f094 [  4] split : MAGIC STRING [id=134] 
0x84f098 [ 20] unescCtrlChars : STRING
0x84f0ac [  8] pt : STRING
0x84f0b4 [ 20] ciphertextByte : STRING
0x84f0dc [ 12] str : STRING
0x84f0e8 [  4] replace : MAGIC STRING [id=132] 
0x84f0ec [ 32] [\0\t\n\v\f\r\xa0'"!-]/g : STRING
0x84f120 [  8] ! : STRING
0x84f128 [ 20] !\d\d?\d?!/g : STRING
0x84f13c [ 12] b64 : STRING
0x84f15c [ 72] ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/= : STRING
0x84f1b8 [ 20] encodeBase64 : STRING
0x84f1e0 [  8] o1 : STRING
0x84f1e8 [  8] o2 : STRING
0x84f1f0 [  8] o3 : STRING
0x84f1f8 [  8] h1 : STRING
0x84f214 [  8] h2 : STRING
0x84f21c [  8] h3 : STRING
0x84f224 [  8] h4 : STRING
0x84f22c [ 12] bits : STRING
0x84f238 [ 12] enc : STRING
0x84f258 [ 16] encodeUTF8 : STRING
0x84f268 [  4] isNaN : MAGIC STRING [id=50] 
0x84f26c [  4] charAt : MAGIC STRING [id=128] 
0x84f270 [ 20] decodeBase64 : STRING
0x84f298 [  4] indexOf : MAGIC STRING [id=119] 
0x84f29c [ 16] decodeUTF8 : STRING
0x84f2ac [ 24] [\u0080-\u07ff]/g : STRING
0x84f2d8 [  8] cc : STRING
0x84f2e0 [ 24] [\u0800-\uffff]/g : STRING
0x84f2f8 [ 40] [\u00c0-\u00df][\u0080-\u00bf]/g : STRING
0x84f334 [ 56] [\u00e0-\u00ef][\u0080-\u00bf][\u0080-\u00bf]/g : STRING
0x84f394 [ 24] byteArrayToHexStr : STRING
0x84f3ac [  4] toString : MAGIC STRING [id=103] 
0x84f3b0 [  4]   : MAGIC STRING [id=217] 
0x84f3b4 [ 16] plainText : STRING
0x84f3d8 [1352] ROMEO: But, soft! what light through yonder window breaks?
It is the east, and Juliet is the sun.
Arise, fair sun, and kill the envious moon,
Who is already sick and pale with grief,
That thou her maid art far more fair than she:
Be not her maid, since she is envious;
Her vestal livery is but sick and green
And none but fools do wear it; cast it off.
It is my lady, O, it is my love!
O, that she knew she were!
She speaks yet she says nothing: what of that?
Her eye discourses; I will answer it.
I am too bold, 'tis not to me she speaks:
Two of the fairest stars in all the heaven,
Having some business, do entreat her eyes
To twinkle in their spheres till they return.
What if her eyes were there, they in her head?
The brightness of her cheek would shame those stars,
As daylight doth a lamp; her eyes in heaven
Would through the airy region stream so bright
That birds would sing and think it were not night.
See, how she leans her cheek upon her hand!
O, that I were a glove upon that hand,
That I might touch that cheek!
JULIET: Ay me!
ROMEO: She speaks:
O, speak again, bright angel! for thou art
As glorious to this night, being o'er my head
As is a winged messenger of heaven
Unto the white-upturned wondering eyes
Of mortals that fall back to gaze on him
When he bestrides the lazy-pacing clouds
And sails upon the bosom of the air. : STRING
0x84fb78 [ 48] O Romeo, Romeo! wherefore art thou Romeo? : STRING
0x84fbbc [ 16] cipherText : STRING
0x84fbe0 [ 20] decryptedText : STRING
0x84fbf4 [ 36] ERROR: bad result: expected  : STRING
0x84fc2c [ 16]  but got  : STRING
0x84fc3c [  4]  : EMPTY RECORD
  0:                 meta   12    6          // [no 'arguments'] [no 'eval'] 
  1:         reg_var_decl  128               // var tmp128 .. tmp134;
  2:             var_decl                    // var Sbox;
  3:             var_decl                    // var Rcon;
  4:             var_decl                    // var b64;
  5:             var_decl                    // var plainText;
  6:             var_decl                    // var password;
  7:             var_decl                    // var cipherText;
  8:             var_decl                    // var decryptedText;
  9:          func_decl_n    7               // 
 10:                 meta    2    8          // 
 11:                 meta    2    9          // function Cipher (input, w);
 12:                 meta    7    0          // function end: 140;
 13:                 meta   12    6          // [no 'arguments'] [no 'eval'] 
 14:         reg_var_decl  128               // var tmp128 .. tmp144;
 15:             var_decl                    // var Nb;
 16:             var_decl                    // var Nr;
 17:             var_decl                    // var state;
 18:             var_decl                    // var i;
 19:             var_decl                    // var round;
 20:             var_decl                    // var output;
 21:           assignment  130    1          // tmp130 = 4: SMALLINT;
 22:           assignment   10    6          // Nb = tmp130 : TYPEOF(tmp130);
 23:           assignment  130    5          // tmp130 = 'length': STRING;
 24:          prop_getter  131    9          // tmp131 = w[tmp130];
 25:             division  132  131          // tmp132 = tmp131 / Nb;
 26:           assignment  133    1          // tmp133 = 1: SMALLINT;
 27:         substraction  134  132          // tmp134 = tmp132 - tmp133;
 28:           assignment   11    6          // Nr = tmp134 : TYPEOF(tmp134);
 29:           array_decl  130               // 
 30:           array_decl  130               // tmp130 = [];
 31:                 meta    2  130          // 
 32:           array_decl  130               // tmp130 = [];
 33:                 meta    2  130          // 
 34:           array_decl  130               // tmp130 = [];
 35:                 meta    2  130          // 
 36:           array_decl  130               // tmp130 = [];
 37:                 meta    2  130          // tmp130 = [tmp130];
 38:           assignment   12    6          // state = tmp130 : TYPEOF(tmp130);
 39:           assignment  130    1          // tmp130 = 0: SMALLINT;
 40:           assignment   13    6          // i = tmp130 : TYPEOF(tmp130);
 41:             jmp_down    0               // goto 58;
 42:           assignment  130    6          // tmp130 = i : TYPEOF(i);
 43:           assignment  131    1          // tmp131 = 4: SMALLINT;
 44:            remainder  132  130          // tmp132 = tmp130 %% tmp131;
 45:          prop_getter  133   12          // tmp133 = state[tmp132];
 46:           assignment  134    5          // tmp134 = 'floor': STRING;
 47:          prop_getter  135   18          // tmp135 = Math[tmp134];
 48:           assignment  136    6          // tmp136 = Math : TYPEOF(Math);
 49:               call_n  137  135          // 
 50:                 meta    1    1          // 
 51:           assignment  137    6          // tmp137 = i : TYPEOF(i);
 52:           assignment  138    1          // tmp138 = 4: SMALLINT;
 53:             division  139  137          // tmp139 = tmp137 / tmp138;
 54:                 meta    2  139          // tmp137 = tmp135 (this_arg = tmp136, tmp139);
 55:          prop_getter  139    8          // tmp139 = input[i];
 56:          prop_setter  133  137          // tmp133[tmp137] = tmp139;
 57:            post_incr  140               // tmp140 = i++;
 58:           assignment  141    6          // tmp141 = i : TYPEOF(i);
 59:           assignment  142    1          // tmp142 = 4: SMALLINT;
 60:       multiplication  143  142          // tmp143 = tmp142 * Nb;
 61:            less_than  144  141          // tmp144 = tmp141 < tmp143;
 62:       is_true_jmp_up  144    0          // if (tmp144) goto 42;
 63:               call_n  130   19          // 
 64:                 meta    2    0          // 
 65:                 meta    2    1          // 
 66:           assignment  130    1          // tmp130 = 0: SMALLINT;
 67:                 meta    2  130          // 
 68:                 meta    2    2          // tmp130 = AddRoundKey (state, w, tmp130, Nb);
 69:           assignment    0    6          // state = tmp130 : TYPEOF(tmp130);
 70:           assignment  130    1          // tmp130 = 1: SMALLINT;
 71:           assignment    3    6          // round = tmp130 : TYPEOF(tmp130);
 72:             jmp_down    0               // goto 92;
 73:               call_n  130    4          // 
 74:                 meta    2    0          // 
 75:                 meta    2    2          // tmp130 = SubBytes (state, Nb);
 76:           assignment    0    6          // state = tmp130 : TYPEOF(tmp130);
 77:               call_n  130    5          // 
 78:                 meta    2    0          // 
 79:                 meta    2    2          // tmp130 = ShiftRows (state, Nb);
 80:           assignment    0    6          // state = tmp130 : TYPEOF(tmp130);
 81:               call_n  130    6          // 
 82:                 meta    2    0          // 
 83:                 meta    2    2          // tmp130 = MixColumns (state, Nb);
 84:           assignment    0    6          // state = tmp130 : TYPEOF(tmp130);
 85:               call_n  130    7          // 
 86:                 meta    2    0          // 
 87:                 meta    2    1          // 
 88:                 meta    2    3          // 
 89:                 meta    2    2          // tmp130 = AddRoundKey (state, w, round, Nb);
 90:           assignment    0    6          // state = tmp130 : TYPEOF(tmp130);
 91:            post_incr  131               // tmp131 = round++;
 92:           assignment  132    6          // tmp132 = round : TYPEOF(round);
 93:            less_than  133  132          // tmp133 = tmp132 < Nr;
 94:       is_true_jmp_up  133    0          // if (tmp133) goto 73;
 95:               call_n  130    4          // 
 96:                 meta    2    0          // 
 97:                 meta    2    2          // tmp130 = SubBytes (state, Nb);
 98:           assignment    0    6          // state = tmp130 : TYPEOF(tmp130);
 99:               call_n  130    5          // 
100:                 meta    2    0          // 
101:                 meta    2    2          // tmp130 = ShiftRows (state, Nb);
102:           assignment    0    6          // state = tmp130 : TYPEOF(tmp130);
103:               call_n  130    7          // 
104:                 meta    2    0          // 
105:                 meta    2    1          // 
106:                 meta    2    8          // 
107:                 meta    2    2          // tmp130 = AddRoundKey (state, w, Nr, Nb);
108:           assignment    0    6          // state = tmp130 : TYPEOF(tmp130);
109:          construct_n  130    9          // 
110:           assignment  130    1          // tmp130 = 4: SMALLINT;
111:       multiplication  131  130          // tmp131 = tmp130 * Nb;
112:                 meta    2  131          // tmp130 = new Array (tmp131);
113:           assignment   10    6          // output = tmp130 : TYPEOF(tmp130);
114:           assignment  130    1          // tmp130 = 0: SMALLINT;
115:           assignment   11    6          // i = tmp130 : TYPEOF(tmp130);
116:             jmp_down    0               // goto 133;
117:           assignment  131    6          // tmp131 = i : TYPEOF(i);
118:           assignment  132    1          // tmp132 = 4: SMALLINT;
119:            remainder  133  131          // tmp133 = tmp131 %% tmp132;
120:          prop_getter  134    0          // tmp134 = state[tmp133];
121:           assignment  135    5          // tmp135 = 'floor': STRING;
122:          prop_getter  136   13          // tmp136 = Math[tmp135];
123:           assignment  137    6          // tmp137 = Math : TYPEOF(Math);
124:               call_n  138  136          // 
125:                 meta    1    1          // 
126:           assignment  138    6          // tmp138 = i : TYPEOF(i);
127:           assignment  139    1          // tmp139 = 4: SMALLINT;
128:             division  140  138          // tmp140 = tmp138 / tmp139;
129:                 meta    2  140          // tmp138 = tmp136 (this_arg = tmp137, tmp140);
130:          prop_getter  139  134          // tmp139 = tmp134[tmp138];
131:          prop_setter    0    1          // output[i] = tmp139;
132:            post_incr  140               // tmp140 = i++;
133:           assignment  141    6          // tmp141 = i : TYPEOF(i);
134:           assignment  142    1          // tmp142 = 4: SMALLINT;
135:       multiplication  143  142          // tmp143 = tmp142 * Nb;
136:            less_than  144  141          // tmp144 = tmp141 < tmp143;
137:       is_true_jmp_up  144    0          // if (tmp144) goto 117;
138:               retval                    // return output;
139:                  ret                    // ret;
140:          func_decl_n    3               // 
141:                 meta    2    4          // 
142:                 meta    2    2          // function SubBytes (s, Nb);
143:                 meta    7    0          // function end: 170;
144:                 meta   12    6          // [no 'arguments'] [no 'eval'] 
145:         reg_var_decl  128               // var tmp128 .. tmp141;
146:             var_decl                    // var r;
147:             var_decl                    // var c;
148:           assignment  130    1          // tmp130 = 0: SMALLINT;
149:           assignment    5    6          // r = tmp130 : TYPEOF(tmp130);
150:             jmp_down    0               // goto 164;
151:           assignment  130    1          // tmp130 = 0: SMALLINT;
152:           assignment    6    6          // c = tmp130 : TYPEOF(tmp130);
153:             jmp_down    0               // goto 160;
154:          prop_getter  130    4          // tmp130 = s[r];
155:          prop_getter  132    4          // tmp132 = s[r];
156:          prop_getter  133  132          // tmp133 = tmp132[c];
157:          prop_getter  134    7          // tmp134 = Sbox[tmp133];
158:          prop_setter  130    6          // tmp130[c] = tmp134;
159:            post_incr  135               // tmp135 = c++;
160:           assignment  136    6          // tmp136 = c : TYPEOF(c);
161:            less_than  137  136          // tmp137 = tmp136 < Nb;
162:       is_true_jmp_up  137    0          // if (tmp137) goto 154;
163:            post_incr  138               // tmp138 = r++;
164:           assignment  139    6          // tmp139 = r : TYPEOF(r);
165:           assignment  140    1          // tmp140 = 4: SMALLINT;
166:            less_than  141  139          // tmp141 = tmp139 < tmp140;
167:       is_true_jmp_up  141    0          // if (tmp141) goto 151;
168:               retval                    // return s;
169:                  ret                    // ret;
170:          func_decl_n    8               // 
171:                 meta    2    4          // 
172:                 meta    2    2          // function ShiftRows (s, Nb);
173:                 meta    7    0          // function end: 218;
174:                 meta   12    6          // [no 'arguments'] [no 'eval'] 
175:         reg_var_decl  128               // var tmp128 .. tmp140;
176:             var_decl                    // var t;
177:             var_decl                    // var r;
178:             var_decl                    // var c;
179:          construct_n  130   10          // 
180:           assignment  130    1          // tmp130 = 4: SMALLINT;
181:                 meta    2  130          // tmp130 = new Array (tmp130);
182:           assignment    9    6          // t = tmp130 : TYPEOF(tmp130);
183:           assignment  130    1          // tmp130 = 1: SMALLINT;
184:           assignment    5    6          // r = tmp130 : TYPEOF(tmp130);
185:             jmp_down    0               // goto 212;
186:           assignment  130    1          // tmp130 = 0: SMALLINT;
187:           assignment    6    6          // c = tmp130 : TYPEOF(tmp130);
188:             jmp_down    0               // goto 196;
189:          prop_getter  131    4          // tmp131 = s[r];
190:           assignment  132    6          // tmp132 = c : TYPEOF(c);
191:             addition  133  132          // tmp133 = tmp132 + r;
192:            remainder  134  133          // tmp134 = tmp133 %% Nb;
193:          prop_getter  135  131          // tmp135 = tmp131[tmp134];
194:          prop_setter    1    2          // t[c] = tmp135;
195:            post_incr  136               // tmp136 = c++;
196:           assignment  137    6          // tmp137 = c : TYPEOF(c);
197:           assignment  138    1          // tmp138 = 4: SMALLINT;
198:            less_than  139  137          // tmp139 = tmp137 < tmp138;
199:       is_true_jmp_up  139    0          // if (tmp139) goto 189;
200:           assignment  130    1          // tmp130 = 0: SMALLINT;
201:           assignment    2    6          // c = tmp130 : TYPEOF(tmp130);
202:             jmp_down    0               // goto 207;
203:          prop_getter  130    3          // tmp130 = s[r];
204:          prop_getter  132    1          // tmp132 = t[c];
205:          prop_setter  130    2          // tmp130[c] = tmp132;
206:            post_incr  133               // tmp133 = c++;
207:           assignment  134    6          // tmp134 = c : TYPEOF(c);
208:           assignment  135    1          // tmp135 = 4: SMALLINT;
209:            less_than  136  134          // tmp136 = tmp134 < tmp135;
210:       is_true_jmp_up  136    0          // if (tmp136) goto 203;
211:            post_incr  137               // tmp137 = r++;
212:           assignment  138    6          // tmp138 = r : TYPEOF(r);
213:           assignment  139    1          // tmp139 = 4: SMALLINT;
214:            less_than  140  138          // tmp140 = tmp138 < tmp139;
215:       is_true_jmp_up  140    0          // if (tmp140) goto 186;
216:               retval                    // return s;
217:                  ret                    // ret;
218:          func_decl_n    5               // 
219:                 meta    2    3          // 
220:                 meta    2    0          // function MixColumns (s, Nb);
221:                 meta    7    0          // function end: 344;
222:                 meta   12    6          // [no 'arguments'] [no 'eval'] 
223:         reg_var_decl  128               // var tmp128 .. tmp150;
224:             var_decl                    // var c;
225:             var_decl                    // var a;
226:             var_decl                    // var b;
227:             var_decl                    // var i;
228:           assignment  130    1          // tmp130 = 0: SMALLINT;
229:           assignment    2    6          // c = tmp130 : TYPEOF(tmp130);
230:             jmp_down    0               // goto 338;
231:          construct_n  130    9          // 
232:           assignment  130    1          // tmp130 = 4: SMALLINT;
233:                 meta    2  130          // tmp130 = new Array (tmp130);
234:           assignment    6    6          // a = tmp130 : TYPEOF(tmp130);
235:          construct_n  130    9          // 
236:           assignment  130    1          // tmp130 = 4: SMALLINT;
237:                 meta    2  130          // tmp130 = new Array (tmp130);
238:           assignment    7    6          // b = tmp130 : TYPEOF(tmp130);
239:           assignment  130    1          // tmp130 = 0: SMALLINT;
240:           assignment    8    6          // i = tmp130 : TYPEOF(tmp130);
241:             jmp_down    0               // goto 265;
242:          prop_getter  131    3          // tmp131 = s[i];
243:          prop_getter  132  131          // tmp132 = tmp131[c];
244:          prop_setter    6    8          // a[i] = tmp132;
245:          prop_getter  131    3          // tmp131 = s[i];
246:          prop_getter  132  131          // tmp132 = tmp131[c];
247:           assignment  133    1          // tmp133 = 128: SMALLINT;
248:                b_and  134  132          // tmp134 = tmp132 & tmp133;
249:    is_false_jmp_down  134    0          // if (tmp134 == false) goto 258;
250:          prop_getter  135    3          // tmp135 = s[i];
251:          prop_getter  136  135          // tmp136 = tmp135[c];
252:           assignment  137    1          // tmp137 = 1: SMALLINT;
253:         b_shift_left  138  136          // tmp138 = tmp136 << tmp137;
254:           assignment  139    3          // tmp139 = 283: NUMBER;
255:                b_xor  140  138          // tmp140 = tmp138 ^ tmp139;
256:           assignment  141    6          // tmp141 = tmp140 : TYPEOF(tmp140);
257:             jmp_down    0               // goto 263;
258:          prop_getter  142    0          // tmp142 = s[i];
259:          prop_getter  143  142          // tmp143 = tmp142[c];
260:           assignment  144    1          // tmp144 = 1: SMALLINT;
261:         b_shift_left  145  143          // tmp145 = tmp143 << tmp144;
262:           assignment  141    6          // tmp141 = tmp145 : TYPEOF(tmp145);
263:          prop_setter    3    1          // b[i] = tmp141;
264:            post_incr  146               // tmp146 = i++;
265:           assignment  147    6          // tmp147 = i : TYPEOF(i);
266:           assignment  148    1          // tmp148 = 4: SMALLINT;
267:            less_than  149  147          // tmp149 = tmp147 < tmp148;
268:       is_true_jmp_up  149    0          // if (tmp149) goto 242;
269:           assignment  130    1          // tmp130 = 0: SMALLINT;
270:          prop_getter  131    0          // tmp131 = s[tmp130];
271:           assignment  133    1          // tmp133 = 0: SMALLINT;
272:          prop_getter  134    3          // tmp134 = b[tmp133];
273:           assignment  135    1          // tmp135 = 1: SMALLINT;
274:          prop_getter  136    4          // tmp136 = a[tmp135];
275:                b_xor  137  134          // tmp137 = tmp134 ^ tmp136;
276:           assignment  138    1          // tmp138 = 1: SMALLINT;
277:          prop_getter  139    3          // tmp139 = b[tmp138];
278:                b_xor  140  137          // tmp140 = tmp137 ^ tmp139;
279:           assignment  141    1          // tmp141 = 2: SMALLINT;
280:          prop_getter  142    4          // tmp142 = a[tmp141];
281:                b_xor  143  140          // tmp143 = tmp140 ^ tmp142;
282:           assignment  144    1          // tmp144 = 3: SMALLINT;
283:          prop_getter  145    4          // tmp145 = a[tmp144];
284:                b_xor  146  143          // tmp146 = tmp143 ^ tmp145;
285:          prop_setter  131    2          // tmp131[c] = tmp146;
286:           assignment  130    1          // tmp130 = 1: SMALLINT;
287:          prop_getter  131    0          // tmp131 = s[tmp130];
288:           assignment  133    1          // tmp133 = 0: SMALLINT;
289:          prop_getter  134    4          // tmp134 = a[tmp133];
290:           assignment  135    1          // tmp135 = 1: SMALLINT;
291:          prop_getter  136    3          // tmp136 = b[tmp135];
292:                b_xor  137  134          // tmp137 = tmp134 ^ tmp136;
293:           assignment  138    1          // tmp138 = 2: SMALLINT;
294:          prop_getter  139    4          // tmp139 = a[tmp138];
295:                b_xor  140  137          // tmp140 = tmp137 ^ tmp139;
296:           assignment  141    1          // tmp141 = 2: SMALLINT;
297:          prop_getter  142    3          // tmp142 = b[tmp141];
298:                b_xor  143  140          // tmp143 = tmp140 ^ tmp142;
299:           assignment  144    1          // tmp144 = 3: SMALLINT;
300:          prop_getter  145    4          // tmp145 = a[tmp144];
301:                b_xor  146  143          // tmp146 = tmp143 ^ tmp145;
302:          prop_setter  131    2          // tmp131[c] = tmp146;
303:           assignment  130    1          // tmp130 = 2: SMALLINT;
304:          prop_getter  131    0          // tmp131 = s[tmp130];
305:           assignment  133    1          // tmp133 = 0: SMALLINT;
306:          prop_getter  134    4          // tmp134 = a[tmp133];
307:           assignment  135    1          // tmp135 = 1: SMALLINT;
308:          prop_getter  136    4          // tmp136 = a[tmp135];
309:                b_xor  137  134          // tmp137 = tmp134 ^ tmp136;
310:           assignment  138    1          // tmp138 = 2: SMALLINT;
311:          prop_getter  139    3          // tmp139 = b[tmp138];
312:                b_xor  140  137          // tmp140 = tmp137 ^ tmp139;
313:           assignment  141    1          // tmp141 = 3: SMALLINT;
314:          prop_getter  142    4          // tmp142 = a[tmp141];
315:                b_xor  143  140          // tmp143 = tmp140 ^ tmp142;
316:           assignment  144    1          // tmp144 = 3: SMALLINT;
317:          prop_getter  145    3          // tmp145 = b[tmp144];
318:                b_xor  146  143          // tmp146 = tmp143 ^ tmp145;
319:          prop_setter  131    2          // tmp131[c] = tmp146;
320:           assignment  130    1          // tmp130 = 3: SMALLINT;
321:          prop_getter  131    0          // tmp131 = s[tmp130];
322:           assignment  133    1          // tmp133 = 0: SMALLINT;
323:          prop_getter  134    1          // tmp134 = a[tmp133];
324:           assignment  135    1          // tmp135 = 0: SMALLINT;
325:          prop_getter  136    2          // tmp136 = b[tmp135];
326:                b_xor  137  134          // tmp137 = tmp134 ^ tmp136;
327:           assignment  138    1          // tmp138 = 1: SMALLINT;
328:          prop_getter  139    1          // tmp139 = a[tmp138];
329:                b_xor  140  137          // tmp140 = tmp137 ^ tmp139;
330:           assignment  141    1          // tmp141 = 2: SMALLINT;
331:          prop_getter  142    1          // tmp142 = a[tmp141];
332:                b_xor  143  140          // tmp143 = tmp140 ^ tmp142;
333:           assignment  144    1          // tmp144 = 3: SMALLINT;
334:          prop_getter  145    2          // tmp145 = b[tmp144];
335:                b_xor  146  143          // tmp146 = tmp143 ^ tmp145;
336:          prop_setter  131    3          // tmp131[c] = tmp146;
337:            post_incr  147               // tmp147 = c++;
338:           assignment  148    6          // tmp148 = c : TYPEOF(c);
339:           assignment  149    1          // tmp149 = 4: SMALLINT;
340:            less_than  150  148          // tmp150 = tmp148 < tmp149;
341:       is_true_jmp_up  150    0          // if (tmp150) goto 231;
342:               retval                    // return s;
343:                  ret                    // ret;
344:          func_decl_n    4               // 
345:                 meta    2    5          // 
346:                 meta    2    6          // 
347:                 meta    2    7          // 
348:                 meta    2    8          // function AddRoundKey (state, w, rnd, Nb);
349:                 meta    7    0          // function end: 381;
350:                 meta   12    6          // [no 'arguments'] [no 'eval'] 
351:         reg_var_decl  128               // var tmp128 .. tmp145;
352:             var_decl                    // var r;
353:             var_decl                    // var c;
354:           assignment  130    1          // tmp130 = 0: SMALLINT;
355:           assignment    9    6          // r = tmp130 : TYPEOF(tmp130);
356:             jmp_down    0               // goto 375;
357:           assignment  130    1          // tmp130 = 0: SMALLINT;
358:           assignment    3    6          // c = tmp130 : TYPEOF(tmp130);
359:             jmp_down    0               // goto 371;
360:          prop_getter  130    5          // tmp130 = state[r];
361:           assignment  132    6          // tmp132 = rnd : TYPEOF(rnd);
362:           assignment  133    1          // tmp133 = 4: SMALLINT;
363:       multiplication  134  132          // tmp134 = tmp132 * tmp133;
364:             addition  135  134          // tmp135 = tmp134 + c;
365:          prop_getter  136    6          // tmp136 = w[tmp135];
366:          prop_getter  137  136          // tmp137 = tmp136[r];
367:          prop_getter  138  130          // tmp138 = tmp130[c];
368:                b_xor  138  138          // tmp138 = tmp138 ^ tmp137;
369:          prop_setter  130    3          // tmp130[c] = tmp138;
370:            post_incr  139               // tmp139 = c++;
371:           assignment  140    6          // tmp140 = c : TYPEOF(c);
372:            less_than  141  140          // tmp141 = tmp140 < Nb;
373:       is_true_jmp_up  141    0          // if (tmp141) goto 360;
374:            post_incr  142               // tmp142 = r++;
375:           assignment  143    6          // tmp143 = r : TYPEOF(r);
376:           assignment  144    1          // tmp144 = 4: SMALLINT;
377:            less_than  145  143          // tmp145 = tmp143 < tmp144;
378:       is_true_jmp_up  145    0          // if (tmp145) goto 357;
379:               retval                    // return state;
380:                  ret                    // ret;
381:          func_decl_n   10               // 
382:                 meta    2   11          // function KeyExpansion (key);
383:                 meta    7    0          // function end: 537;
384:                 meta   12    6          // [no 'arguments'] [no 'eval'] 
385:         reg_var_decl  128               // var tmp128 .. tmp149;
386:             var_decl                    // var Nb;
387:             var_decl                    // var Nk;
388:             var_decl                    // var Nr;
389:             var_decl                    // var w;
390:             var_decl                    // var temp;
391:             var_decl                    // var i;
392:             var_decl                    // var r;
393:             var_decl                    // var t;
394:           assignment  130    1          // tmp130 = 4: SMALLINT;
395:           assignment    0    6          // Nb = tmp130 : TYPEOF(tmp130);
396:           assignment  130    5          // tmp130 = 'length': STRING;
397:          prop_getter  131    9          // tmp131 = key[tmp130];
398:           assignment  132    1          // tmp132 = 4: SMALLINT;
399:             division  133  131          // tmp133 = tmp131 / tmp132;
400:           assignment    1    6          // Nk = tmp133 : TYPEOF(tmp133);
401:           assignment  130    6          // tmp130 = Nk : TYPEOF(Nk);
402:           assignment  131    1          // tmp131 = 6: SMALLINT;
403:             addition  132  130          // tmp132 = tmp130 + tmp131;
404:           assignment    2    6          // Nr = tmp132 : TYPEOF(tmp132);
405:          construct_n  130   10          // 
406:           assignment  130    6          // tmp130 = Nb : TYPEOF(Nb);
407:           assignment  131    6          // tmp131 = Nr : TYPEOF(Nr);
408:           assignment  132    1          // tmp132 = 1: SMALLINT;
409:             addition  133  131          // tmp133 = tmp131 + tmp132;
410:       multiplication  134  130          // tmp134 = tmp130 * tmp133;
411:                 meta    2  134          // tmp130 = new Array (tmp134);
412:           assignment    3    6          // w = tmp130 : TYPEOF(tmp130);
413:          construct_n  130   10          // 
414:           assignment  130    1          // tmp130 = 4: SMALLINT;
415:                 meta    2  130          // tmp130 = new Array (tmp130);
416:           assignment    4    6          // temp = tmp130 : TYPEOF(tmp130);
417:           assignment  130    1          // tmp130 = 0: SMALLINT;
418:           assignment    5    6          // i = tmp130 : TYPEOF(tmp130);
419:             jmp_down    0               // goto 447;
420:           array_decl  130               // 
421:           assignment  130    1          // tmp130 = 4: SMALLINT;
422:       multiplication  131  130          // tmp131 = tmp130 * i;
423:          prop_getter  132    9          // tmp132 = key[tmp131];
424:                 meta    2  132          // 
425:           assignment  130    1          // tmp130 = 4: SMALLINT;
426:       multiplication  131  130          // tmp131 = tmp130 * i;
427:           assignment  132    1          // tmp132 = 1: SMALLINT;
428:             addition  133  131          // tmp133 = tmp131 + tmp132;
429:          prop_getter  134    9          // tmp134 = key[tmp133];
430:                 meta    2  134          // 
431:           assignment  130    1          // tmp130 = 4: SMALLINT;
432:       multiplication  131  130          // tmp131 = tmp130 * i;
433:           assignment  132    1          // tmp132 = 2: SMALLINT;
434:             addition  133  131          // tmp133 = tmp131 + tmp132;
435:          prop_getter  134    9          // tmp134 = key[tmp133];
436:                 meta    2  134          // 
437:           assignment  130    1          // tmp130 = 4: SMALLINT;
438:       multiplication  131  130          // tmp131 = tmp130 * i;
439:           assignment  132    1          // tmp132 = 3: SMALLINT;
440:             addition  133  131          // tmp133 = tmp131 + tmp132;
441:          prop_getter  134    9          // tmp134 = key[tmp133];
442:                 meta    2  134          // tmp130 = [tmp132, tmp134, tmp134, tmp134];
443:           assignment    6    6          // r = tmp130 : TYPEOF(tmp130);
444:          prop_setter    3    5          // w[i] = r;
445:           assignment  131    6          // tmp131 = r : TYPEOF(r);
446:            post_incr  132               // tmp132 = i++;
447:           assignment  133    6          // tmp133 = i : TYPEOF(i);
448:            less_than  134  133          // tmp134 = tmp133 < Nk;
449:       is_true_jmp_up  134    0          // if (tmp134) goto 420;
450:           assignment    1    6          // i = Nk : TYPEOF(Nk);
451:             jmp_down    0               // goto 527;
452:          construct_n  131    2          // 
453:           assignment  131    1          // tmp131 = 4: SMALLINT;
454:                 meta    2  131          // tmp131 = new Array (tmp131);
455:          prop_setter    3    1          // w[i] = tmp131;
456:           assignment  130    1          // tmp130 = 0: SMALLINT;
457:           assignment    4    6          // t = tmp130 : TYPEOF(tmp130);
458:             jmp_down    0               // goto 466;
459:           assignment  131    6          // tmp131 = i : TYPEOF(i);
460:           assignment  132    1          // tmp132 = 1: SMALLINT;
461:         substraction  133  131          // tmp133 = tmp131 - tmp132;
462:          prop_getter  134    3          // tmp134 = w[tmp133];
463:          prop_getter  135  134          // tmp135 = tmp134[t];
464:          prop_setter    5    4          // temp[t] = tmp135;
465:            post_incr  136               // tmp136 = t++;
466:           assignment  137    6          // tmp137 = t : TYPEOF(t);
467:           assignment  138    1          // tmp138 = 4: SMALLINT;
468:            less_than  139  137          // tmp139 = tmp137 < tmp138;
469:       is_true_jmp_up  139    0          // if (tmp139) goto 459;
470:           assignment  130    6          // tmp130 = i : TYPEOF(i);
471:            remainder  131  130          // tmp131 = tmp130 %% Nk;
472:           assignment  132    1          // tmp132 = 0: SMALLINT;
473:          equal_value  133  131          // tmp133 = tmp131 == tmp132;
474:    is_false_jmp_down  133    0          // if (tmp133 == false) goto 496;
475:               call_n  130    6          // 
476:               call_n  130    7          // 
477:                 meta    2    5          // tmp130 = RotWord (temp);
478:                 meta    2  130          // 
479:           assignment    5    6          // temp = tmp130 : TYPEOF(tmp130);
480:           assignment  130    1          // tmp130 = 0: SMALLINT;
481:           assignment    4    6          // t = tmp130 : TYPEOF(tmp130);
482:             jmp_down    0               // goto 491;
483:           assignment  131    6          // tmp131 = i : TYPEOF(i);
484:             division  132  131          // tmp132 = tmp131 / Nk;
485:          prop_getter  133    8          // tmp133 = Rcon[tmp132];
486:          prop_getter  134  133          // tmp134 = tmp133[t];
487:          prop_getter  135    5          // tmp135 = temp[t];
488:                b_xor  135  135          // tmp135 = tmp135 ^ tmp134;
489:          prop_setter    5    4          // temp[t] = tmp135;
490:            post_incr  136               // tmp136 = t++;
491:           assignment  137    6          // tmp137 = t : TYPEOF(t);
492:           assignment  138    1          // tmp138 = 4: SMALLINT;
493:            less_than  139  137          // tmp139 = tmp137 < tmp138;
494:       is_true_jmp_up  139    0          // if (tmp139) goto 483;
495:             jmp_down    0               // goto 510;
496:           assignment  130    6          // tmp130 = Nk : TYPEOF(Nk);
497:           assignment  131    1          // tmp131 = 6: SMALLINT;
498:         greater_than  132  130          // tmp132 = tmp130 > tmp131;
499:           assignment  133    6          // tmp133 = tmp132 : TYPEOF(tmp132);
500:    is_false_jmp_down  133    0          // if (tmp133 == false) goto 506;
501:           assignment  134    6          // tmp134 = i : TYPEOF(i);
502:            remainder  135  134          // tmp135 = tmp134 %% Nk;
503:           assignment  136    1          // tmp136 = 4: SMALLINT;
504:          equal_value  137  135          // tmp137 = tmp135 == tmp136;
505:           assignment  133    6          // tmp133 = tmp137 : TYPEOF(tmp137);
506:    is_false_jmp_down  133    0          // if (tmp133 == false) goto 510;
507:               call_n  130    6          // 
508:                 meta    2    5          // tmp130 = SubWord (temp);
509:           assignment    5    6          // temp = tmp130 : TYPEOF(tmp130);
510:           assignment  130    1          // tmp130 = 0: SMALLINT;
511:           assignment    4    6          // t = tmp130 : TYPEOF(tmp130);
512:             jmp_down    0               // goto 522;
513:          prop_getter  130    0          // tmp130 = w[i];
514:           assignment  132    6          // tmp132 = i : TYPEOF(i);
515:         substraction  133  132          // tmp133 = tmp132 - Nk;
516:          prop_getter  134    0          // tmp134 = w[tmp133];
517:          prop_getter  135  134          // tmp135 = tmp134[t];
518:          prop_getter  136    4          // tmp136 = temp[t];
519:                b_xor  137  135          // tmp137 = tmp135 ^ tmp136;
520:          prop_setter  130    3          // tmp130[t] = tmp137;
521:            post_incr  138               // tmp138 = t++;
522:           assignment  139    6          // tmp139 = t : TYPEOF(t);
523:           assignment  140    1          // tmp140 = 4: SMALLINT;
524:            less_than  141  139          // tmp141 = tmp139 < tmp140;
525:       is_true_jmp_up  141    0          // if (tmp141) goto 513;
526:            post_incr  142               // tmp142 = i++;
527:           assignment  143    6          // tmp143 = i : TYPEOF(i);
528:           assignment  144    6          // tmp144 = Nb : TYPEOF(Nb);
529:           assignment  145    6          // tmp145 = Nr : TYPEOF(Nr);
530:           assignment  146    1          // tmp146 = 1: SMALLINT;
531:             addition  147  145          // tmp147 = tmp145 + tmp146;
532:       multiplication  148  144          // tmp148 = tmp144 * tmp147;
533:            less_than  149  143          // tmp149 = tmp143 < tmp148;
534:       is_true_jmp_up  149    0          // if (tmp149) goto 452;
535:               retval                    // return w;
536:                  ret                    // ret;
537:          func_decl_n    7               // 
538:                 meta    2    0          // function SubWord (w);
539:                 meta    7    0          // function end: 556;
540:                 meta   12    6          // [no 'arguments'] [no 'eval'] 
541:         reg_var_decl  128               // var tmp128 .. tmp136;
542:             var_decl                    // var i;
543:           assignment  130    1          // tmp130 = 0: SMALLINT;
544:           assignment    1    6          // i = tmp130 : TYPEOF(tmp130);
545:             jmp_down    0               // goto 550;
546:          prop_getter  131    0          // tmp131 = w[i];
547:          prop_getter  132    8          // tmp132 = Sbox[tmp131];
548:          prop_setter    0    1          // w[i] = tmp132;
549:            post_incr  133               // tmp133 = i++;
550:           assignment  134    6          // tmp134 = i : TYPEOF(i);
551:           assignment  135    1          // tmp135 = 4: SMALLINT;
552:            less_than  136  134          // tmp136 = tmp134 < tmp135;
553:       is_true_jmp_up  136    0          // if (tmp136) goto 546;
554:               retval                    // return w;
555:                  ret                    // ret;
556:          func_decl_n    9               // 
557:                 meta    2    0          // function RotWord (w);
558:                 meta    7    0          // function end: 581;
559:                 meta   12    6          // [no 'arguments'] [no 'eval'] 
560:         reg_var_decl  128               // var tmp128 .. tmp138;
561:             var_decl                    // var i;
562:           assignment  130    1          // tmp130 = 4: SMALLINT;
563:           assignment  132    1          // tmp132 = 0: SMALLINT;
564:          prop_getter  133    0          // tmp133 = w[tmp132];
565:          prop_setter    0  130          // w[tmp130] = tmp133;
566:           assignment  130    1          // tmp130 = 0: SMALLINT;
567:           assignment    1    6          // i = tmp130 : TYPEOF(tmp130);
568:             jmp_down    0               // goto 575;
569:           assignment  131    6          // tmp131 = i : TYPEOF(i);
570:           assignment  132    1          // tmp132 = 1: SMALLINT;
571:             addition  133  131          // tmp133 = tmp131 + tmp132;
572:          prop_getter  134    0          // tmp134 = w[tmp133];
573:          prop_setter    0    1          // w[i] = tmp134;
574:            post_incr  135               // tmp135 = i++;
575:           assignment  136    6          // tmp136 = i : TYPEOF(i);
576:           assignment  137    1          // tmp137 = 4: SMALLINT;
577:            less_than  138  136          // tmp138 = tmp136 < tmp137;
578:       is_true_jmp_up  138    0          // if (tmp138) goto 569;
579:               retval                    // return w;
580:                  ret                    // ret;
581:          func_decl_n    1               // 
582:                 meta    2    2          // 
583:                 meta    2    3          // 
584:                 meta    2    4          // function AESEncryptCtr (plaintext, password, nBits);
585:                 meta    7    1          // function end: 870;
586:                 meta   12    6          // [no 'arguments'] [no 'eval'] 
587:         reg_var_decl  128               // var tmp128 .. tmp146;
588:             var_decl                    // var nBytes;
589:             var_decl                    // var pwBytes;
590:             var_decl                    // var i;
591:             var_decl                    // var key;
592:             var_decl                    // var blockSize;
593:             var_decl                    // var counterBlock;
594:             var_decl                    // var nonce;
595:             var_decl                    // var keySchedule;
596:             var_decl                    // var blockCount;
597:             var_decl                    // var ciphertext;
598:             var_decl                    // var b;
599:             var_decl                    // var c;
600:             var_decl                    // var cipherCntr;
601:             var_decl                    // var blockLength;
602:             var_decl                    // var ct;
603:             var_decl                    // var plaintextByte;
604:             var_decl                    // var cipherByte;
605:             var_decl                    // var ctrTxt;
606:           assignment  130    6          // tmp130 = nBits : TYPEOF(nBits);
607:           assignment  131    1          // tmp131 = 128: SMALLINT;
608:          equal_value  132  130          // tmp132 = tmp130 == tmp131;
609:           assignment  133    6          // tmp133 = tmp132 : TYPEOF(tmp132);
610:     is_true_jmp_down  133    0          // if (tmp133) goto 620;
611:           assignment  134    6          // tmp134 = nBits : TYPEOF(nBits);
612:           assignment  135    1          // tmp135 = 192: SMALLINT;
613:          equal_value  136  134          // tmp136 = tmp134 == tmp135;
614:           assignment  133    6          // tmp133 = tmp136 : TYPEOF(tmp136);
615:     is_true_jmp_down  133    0          // if (tmp133) goto 620;
616:           assignment  137    6          // tmp137 = nBits : TYPEOF(nBits);
617:           assignment  138    3          // tmp138 = 256: NUMBER;
618:          equal_value  139  137          // tmp139 = tmp137 == tmp138;
619:           assignment  133    6          // tmp133 = tmp139 : TYPEOF(tmp139);
620:          logical_not  140               // tmp140 = ! tmp133;
621:    is_false_jmp_down  140    0          // if (tmp140 == false) goto 624;
622:           assignment  130    5          // tmp130 = '': STRING;
623:               retval                    // return tmp130;
624:           assignment  130    6          // tmp130 = nBits : TYPEOF(nBits);
625:           assignment  131    1          // tmp131 = 8: SMALLINT;
626:             division  132  130          // tmp132 = tmp130 / tmp131;
627:           assignment    5    6          // nBytes = tmp132 : TYPEOF(tmp132);
628:          construct_n  130   25          // 
629:                 meta    2    5          // tmp130 = new Array (nBytes);
630:           assignment    6    6          // pwBytes = tmp130 : TYPEOF(tmp130);
631:           assignment  130    1          // tmp130 = 0: SMALLINT;
632:           assignment    7    6          // i = tmp130 : TYPEOF(tmp130);
633:             jmp_down    0               // goto 644;
634:           assignment  131    5          // tmp131 = 'charCodeAt': STRING;
635:          prop_getter  132    3          // tmp132 = password[tmp131];
636:           assignment  133    6          // tmp133 = password : TYPEOF(password);
637:               call_n  134  132          // 
638:                 meta    1    1          // 
639:                 meta    2    7          // tmp134 = tmp132 (this_arg = tmp133, i);
640:           assignment  135    1          // tmp135 = 255: SMALLINT;
641:                b_and  136  134          // tmp136 = tmp134 & tmp135;
642:          prop_setter    0    1          // pwBytes[i] = tmp136;
643:            post_incr  137               // tmp137 = i++;
644:           assignment  138    6          // tmp138 = i : TYPEOF(i);
645:            less_than  139  138          // tmp139 = tmp138 < nBytes;
646:       is_true_jmp_up  139    0          // if (tmp139) goto 634;
647:               call_n  130    3          // 
648:                 meta    2    0          // 
649:               call_n  130    4          // 
650:                 meta    2    0          // tmp130 = KeyExpansion (pwBytes);
651:                 meta    2  130          // 
652:           assignment    5    6          // key = tmp130 : TYPEOF(tmp130);
653:           assignment  130    5          // tmp130 = 'concat': STRING;
654:          prop_getter  131    5          // tmp131 = key[tmp130];
655:           assignment  132    6          // tmp132 = key : TYPEOF(key);
656:               call_n  133  131          // 
657:                 meta    1    1          // 
658:           assignment  133    5          // tmp133 = 'slice': STRING;
659:          prop_getter  134    5          // tmp134 = key[tmp133];
660:           assignment  135    6          // tmp135 = key : TYPEOF(key);
661:               call_n  136  134          // 
662:                 meta    1    1          // 
663:           assignment  136    1          // tmp136 = 0: SMALLINT;
664:                 meta    2  136          // 
665:           assignment  136    6          // tmp136 = nBytes : TYPEOF(nBytes);
666:           assignment  137    1          // tmp137 = 16: SMALLINT;
667:         substraction  138  136          // tmp138 = tmp136 - tmp137;
668:                 meta    2  138          // tmp136 = tmp134 (this_arg = tmp135, tmp136, tmp138);
669:                 meta    2  136          // 
670:           assignment    5    6          // key = tmp133 : TYPEOF(tmp133);
671:           assignment  130    1          // tmp130 = 16: SMALLINT;
672:           assignment    8    6          // blockSize = tmp130 : TYPEOF(tmp130);
673:          construct_n  130    9          // 
674:                 meta    2    8          // tmp130 = new Array (blockSize);
675:           assignment   10    6          // counterBlock = tmp130 : TYPEOF(tmp130);
676:          construct_n  130   11          // tmp130 = new Date;
677:           assignment  131    5          // tmp131 = 'getTime': STRING;
678:          prop_getter  132  130          // tmp132 = tmp130[tmp131];
679:               call_n  133  132          // 
680:                 meta    1    1          // tmp133 = tmp132 (this_arg = tmp130);
681:           assignment   13    6          // nonce = tmp133 : TYPEOF(tmp133);
682:           assignment  130    1          // tmp130 = 0: SMALLINT;
683:           assignment    1    6          // i = tmp130 : TYPEOF(tmp130);
684:             jmp_down    0               // goto 694;
685:           assignment  131    6          // tmp131 = nonce : TYPEOF(nonce);
686:           assignment  132    6          // tmp132 = i : TYPEOF(i);
687:           assignment  133    1          // tmp133 = 8: SMALLINT;
688:       multiplication  134  132          // tmp134 = tmp132 * tmp133;
689:       b_shift_uright  135  131          // tmp135 = tmp131 >>> tmp134;
690:           assignment  136    1          // tmp136 = 255: SMALLINT;
691:                b_and  137  135          // tmp137 = tmp135 & tmp136;
692:          prop_setter   10    1          // counterBlock[i] = tmp137;
693:            post_incr  138               // tmp138 = i++;
694:           assignment  139    6          // tmp139 = i : TYPEOF(i);
695:           assignment  140    1          // tmp140 = 4: SMALLINT;
696:            less_than  141  139          // tmp141 = tmp139 < tmp140;
697:       is_true_jmp_up  141    0          // if (tmp141) goto 685;
698:           assignment  130    1          // tmp130 = 0: SMALLINT;
699:           assignment    1    6          // i = tmp130 : TYPEOF(tmp130);
700:             jmp_down    0               // goto 715;
701:           assignment  130    6          // tmp130 = i : TYPEOF(i);
702:           assignment  131    1          // tmp131 = 4: SMALLINT;
703:             addition  132  130          // tmp132 = tmp130 + tmp131;
704:           assignment  134    6          // tmp134 = nonce : TYPEOF(nonce);
705:           assignment  135    3          // tmp135 = 4294967296: NUMBER;
706:             division  136  134          // tmp136 = tmp134 / tmp135;
707:           assignment  137    6          // tmp137 = i : TYPEOF(i);
708:           assignment  138    1          // tmp138 = 8: SMALLINT;
709:       multiplication  139  137          // tmp139 = tmp137 * tmp138;
710:       b_shift_uright  140  136          // tmp140 = tmp136 >>> tmp139;
711:           assignment  141    1          // tmp141 = 255: SMALLINT;
712:                b_and  142  140          // tmp142 = tmp140 & tmp141;
713:          prop_setter    3  132          // counterBlock[tmp132] = tmp142;
714:            post_incr  143               // tmp143 = i++;
715:           assignment  144    6          // tmp144 = i : TYPEOF(i);
716:           assignment  145    1          // tmp145 = 4: SMALLINT;
717:            less_than  146  144          // tmp146 = tmp144 < tmp145;
718:       is_true_jmp_up  146    0          // if (tmp146) goto 701;
719:               call_n  130    4          // 
720:                 meta    2    5          // tmp130 = KeyExpansion (key);
721:           assignment    6    6          // keySchedule = tmp130 : TYPEOF(tmp130);
722:           assignment  130    5          // tmp130 = 'ceil': STRING;
723:          prop_getter  131    8          // tmp131 = Math[tmp130];
724:           assignment  132    6          // tmp132 = Math : TYPEOF(Math);
725:               call_n  133  131          // 
726:                 meta    1    1          // 
727:           assignment  133    5          // tmp133 = 'length': STRING;
728:          prop_getter  134   10          // tmp134 = plaintext[tmp133];
729:             division  135  134          // tmp135 = tmp134 / blockSize;
730:                 meta    2  135          // tmp133 = tmp131 (this_arg = tmp132, tmp135);
731:           assignment   12    6          // blockCount = tmp133 : TYPEOF(tmp133);
732:          construct_n  130   13          // 
733:                 meta    2   12          // tmp130 = new Array (blockCount);
734:           assignment   14    6          // ciphertext = tmp130 : TYPEOF(tmp130);
735:           assignment  130    1          // tmp130 = 0: SMALLINT;
736:           assignment   15    6          // b = tmp130 : TYPEOF(tmp130);
737:             jmp_down    0               // goto 832;
738:           assignment  130    1          // tmp130 = 0: SMALLINT;
739:           assignment   16    6          // c = tmp130 : TYPEOF(tmp130);
740:             jmp_down    0               // goto 752;
741:           assignment  130    1          // tmp130 = 15: SMALLINT;
742:         substraction  131  130          // tmp131 = tmp130 - c;
743:           assignment  133    6          // tmp133 = b : TYPEOF(b);
744:           assignment  134    6          // tmp134 = c : TYPEOF(c);
745:           assignment  135    1          // tmp135 = 8: SMALLINT;
746:       multiplication  136  134          // tmp136 = tmp134 * tmp135;
747:       b_shift_uright  137  133          // tmp137 = tmp133 >>> tmp136;
748:           assignment  138    1          // tmp138 = 255: SMALLINT;
749:                b_and  139  137          // tmp139 = tmp137 & tmp138;
750:          prop_setter    3  131          // counterBlock[tmp131] = tmp139;
751:            post_incr  140               // tmp140 = c++;
752:           assignment  141    6          // tmp141 = c : TYPEOF(c);
753:           assignment  142    1          // tmp142 = 4: SMALLINT;
754:            less_than  143  141          // tmp143 = tmp141 < tmp142;
755:       is_true_jmp_up  143    0          // if (tmp143) goto 741;
756:           assignment  130    1          // tmp130 = 0: SMALLINT;
757:           assignment   16    6          // c = tmp130 : TYPEOF(tmp130);
758:             jmp_down    0               // goto 772;
759:           assignment  130    1          // tmp130 = 15: SMALLINT;
760:         substraction  131  130          // tmp131 = tmp130 - c;
761:           assignment  132    1          // tmp132 = 4: SMALLINT;
762:         substraction  133  131          // tmp133 = tmp131 - tmp132;
763:           assignment  135    6          // tmp135 = b : TYPEOF(b);
764:           assignment  136    3          // tmp136 = 4294967296: NUMBER;
765:             division  137  135          // tmp137 = tmp135 / tmp136;
766:           assignment  138    6          // tmp138 = c : TYPEOF(c);
767:           assignment  139    1          // tmp139 = 8: SMALLINT;
768:       multiplication  140  138          // tmp140 = tmp138 * tmp139;
769:       b_shift_uright  141  137          // tmp141 = tmp137 >>> tmp140;
770:          prop_setter    0  133          // counterBlock[tmp133] = tmp141;
771:            post_incr  142               // tmp142 = c++;
772:           assignment  143    6          // tmp143 = c : TYPEOF(c);
773:           assignment  144    1          // tmp144 = 4: SMALLINT;
774:            less_than  145  143          // tmp145 = tmp143 < tmp144;
775:       is_true_jmp_up  145    0          // if (tmp145) goto 759;
776:               call_n  130    2          // 
777:                 meta    2    0          // 
778:                 meta    2    3          // tmp130 = Cipher (counterBlock, keySchedule);
779:           assignment    4    6          // cipherCntr = tmp130 : TYPEOF(tmp130);
780:           assignment  130    6          // tmp130 = b : TYPEOF(b);
781:           assignment  131    6          // tmp131 = blockCount : TYPEOF(blockCount);
782:           assignment  132    1          // tmp132 = 1: SMALLINT;
783:         substraction  133  131          // tmp133 = tmp131 - tmp132;
784:            less_than  134  130          // tmp134 = tmp130 < tmp133;
785:    is_false_jmp_down  134    0          // if (tmp134 == false) goto 788;
786:           assignment  135    6          // tmp135 = blockSize : TYPEOF(blockSize);
787:             jmp_down    0               // goto 796;
788:           assignment  136    5          // tmp136 = 'length': STRING;
789:          prop_getter  137    9          // tmp137 = plaintext[tmp136];
790:           assignment  138    1          // tmp138 = 1: SMALLINT;
791:         substraction  139  137          // tmp139 = tmp137 - tmp138;
792:            remainder  140  139          // tmp140 = tmp139 %% blockSize;
793:           assignment  141    1          // tmp141 = 1: SMALLINT;
794:             addition  142  140          // tmp142 = tmp140 + tmp141;
795:           assignment  135    6          // tmp135 = tmp142 : TYPEOF(tmp142);
796:           assignment   10    6          // blockLength = tmp135 : TYPEOF(tmp135);
797:           assignment  130    5          // tmp130 = '': STRING;
798:           assignment   12    6          // ct = tmp130 : TYPEOF(tmp130);
799:           assignment  130    1          // tmp130 = 0: SMALLINT;
800:           assignment   13    6          // i = tmp130 : TYPEOF(tmp130);
801:             jmp_down    0               // goto 825;
802:           assignment  130    5          // tmp130 = 'charCodeAt': STRING;
803:          prop_getter  131    9          // tmp131 = plaintext[tmp130];
804:           assignment  132    6          // tmp132 = plaintext : TYPEOF(plaintext);
805:               call_n  133  131          // 
806:                 meta    1    1          // 
807:           assignment  133    6          // tmp133 = b : TYPEOF(b);
808:       multiplication  134  133          // tmp134 = tmp133 * blockSize;
809:             addition  135  134          // tmp135 = tmp134 + i;
810:                 meta    2  135          // tmp133 = tmp131 (this_arg = tmp132, tmp135);
811:           assignment   15    6          // plaintextByte = tmp133 : TYPEOF(tmp133);
812:           assignment  130    6          // tmp130 = plaintextByte : TYPEOF(plaintextByte);
813:          prop_getter  131    4          // tmp131 = cipherCntr[i];
814:                b_xor  132  130          // tmp132 = tmp130 ^ tmp131;
815:           assignment   16    6          // cipherByte = tmp132 : TYPEOF(tmp132);
816:           assignment  130    5          // tmp130 = 'fromCharCode': STRING;
817:          prop_getter  131   18          // tmp131 = String[tmp130];
818:           assignment  132    6          // tmp132 = String : TYPEOF(String);
819:               call_n  133  131          // 
820:                 meta    1    1          // 
821:                 meta    2   16          // tmp133 = tmp131 (this_arg = tmp132, cipherByte);
822:             addition   12   12          // ct = ct + tmp133;
823:           assignment  134    6          // tmp134 = ct : TYPEOF(ct);
824:            post_incr  135               // tmp135 = i++;
825:           assignment  136    6          // tmp136 = i : TYPEOF(i);
826:            less_than  137  136          // tmp137 = tmp136 < blockLength;
827:       is_true_jmp_up  137    0          // if (tmp137) goto 802;
828:               call_n  131   19          // 
829:                 meta    2   12          // tmp131 = escCtrlChars (ct);
830:          prop_setter   20    5          // ciphertext[b] = tmp131;
831:            post_incr  132               // tmp132 = b++;
832:           assignment  133    6          // tmp133 = b : TYPEOF(b);
833:            less_than  134  133          // tmp134 = tmp133 < blockCount;
834:       is_true_jmp_up  134    0          // if (tmp134) goto 738;
835:           assignment  130    5          // tmp130 = '': STRING;
836:           assignment    3    6          // ctrTxt = tmp130 : TYPEOF(tmp130);
837:           assignment  130    1          // tmp130 = 0: SMALLINT;
838:           assignment    4    6          // i = tmp130 : TYPEOF(tmp130);
839:             jmp_down    0               // goto 850;
840:           assignment  130    5          // tmp130 = 'fromCharCode': STRING;
841:          prop_getter  131    6          // tmp131 = String[tmp130];
842:           assignment  132    6          // tmp132 = String : TYPEOF(String);
843:               call_n  133  131          // 
844:                 meta    1    1          // 
845:          prop_getter  133    7          // tmp133 = counterBlock[i];
846:                 meta    2  133          // tmp133 = tmp131 (this_arg = tmp132, tmp133);
847:             addition    3    3          // ctrTxt = ctrTxt + tmp133;
848:           assignment  134    6          // tmp134 = ctrTxt : TYPEOF(ctrTxt);
849:            post_incr  135               // tmp135 = i++;
850:           assignment  136    6          // tmp136 = i : TYPEOF(i);
851:           assignment  137    1          // tmp137 = 8: SMALLINT;
852:            less_than  138  136          // tmp138 = tmp136 < tmp137;
853:       is_true_jmp_up  138    0          // if (tmp138) goto 840;
854:               call_n  130    8          // 
855:                 meta    2    3          // tmp130 = escCtrlChars (ctrTxt);
856:           assignment    3    6          // ctrTxt = tmp130 : TYPEOF(tmp130);
857:           assignment  130    6          // tmp130 = ctrTxt : TYPEOF(ctrTxt);
858:           assignment  131    5          // tmp131 = '-': STRING;
859:             addition  132  130          // tmp132 = tmp130 + tmp131;
860:           assignment  133    5          // tmp133 = 'join': STRING;
861:          prop_getter  134   11          // tmp134 = ciphertext[tmp133];
862:           assignment  135    6          // tmp135 = ciphertext : TYPEOF(ciphertext);
863:               call_n  136  134          // 
864:                 meta    1    1          // 
865:           assignment  136    5          // tmp136 = '-': STRING;
866:                 meta    2  136          // tmp136 = tmp134 (this_arg = tmp135, tmp136);
867:             addition  137  132          // tmp137 = tmp132 + tmp136;
868:               retval                    // return tmp137;
869:                  ret                    // ret;
870:          func_decl_n   12               // 
871:                 meta    2   11          // 
872:                 meta    2   13          // 
873:                 meta    2   14          // function AESDecryptCtr (ciphertext, password, nBits);
874:                 meta    7    0          // function end: 1108;
875:                 meta   12    6          // [no 'arguments'] [no 'eval'] 
876:         reg_var_decl  128               // var tmp128 .. tmp149;
877:             var_decl                    // var nBytes;
878:             var_decl                    // var pwBytes;
879:             var_decl                    // var i;
880:             var_decl                    // var pwKeySchedule;
881:             var_decl                    // var key;
882:             var_decl                    // var keySchedule;
883:             var_decl                    // var blockSize;
884:             var_decl                    // var counterBlock;
885:             var_decl                    // var ctrTxt;
886:             var_decl                    // var plaintext;
887:             var_decl                    // var b;
888:             var_decl                    // var c;
889:             var_decl                    // var cipherCntr;
890:             var_decl                    // var pt;
891:             var_decl                    // var ciphertextByte;
892:             var_decl                    // var plaintextByte;
893:           assignment  130    6          // tmp130 = nBits : TYPEOF(nBits);
894:           assignment  131    1          // tmp131 = 128: SMALLINT;
895:          equal_value  132  130          // tmp132 = tmp130 == tmp131;
896:           assignment  133    6          // tmp133 = tmp132 : TYPEOF(tmp132);
897:     is_true_jmp_down  133    0          // if (tmp133) goto 907;
898:           assignment  134    6          // tmp134 = nBits : TYPEOF(nBits);
899:           assignment  135    1          // tmp135 = 192: SMALLINT;
900:          equal_value  136  134          // tmp136 = tmp134 == tmp135;
901:           assignment  133    6          // tmp133 = tmp136 : TYPEOF(tmp136);
902:     is_true_jmp_down  133    0          // if (tmp133) goto 907;
903:           assignment  137    6          // tmp137 = nBits : TYPEOF(nBits);
904:           assignment  138    3          // tmp138 = 256: NUMBER;
905:          equal_value  139  137          // tmp139 = tmp137 == tmp138;
906:           assignment  133    6          // tmp133 = tmp139 : TYPEOF(tmp139);
907:          logical_not  140               // tmp140 = ! tmp133;
908:    is_false_jmp_down  140    0          // if (tmp140 == false) goto 911;
909:           assignment  130    5          // tmp130 = '': STRING;
910:               retval                    // return tmp130;
911:           assignment  130    6          // tmp130 = nBits : TYPEOF(nBits);
912:           assignment  131    1          // tmp131 = 8: SMALLINT;
913:             division  132  130          // tmp132 = tmp130 / tmp131;
914:           assignment    3    6          // nBytes = tmp132 : TYPEOF(tmp132);
915:          construct_n  130    4          // 
916:                 meta    2    3          // tmp130 = new Array (nBytes);
917:           assignment    5    6          // pwBytes = tmp130 : TYPEOF(tmp130);
918:           assignment  130    1          // tmp130 = 0: SMALLINT;
919:           assignment    6    6          // i = tmp130 : TYPEOF(tmp130);
920:             jmp_down    0               // goto 931;
921:           assignment  131    5          // tmp131 = 'charCodeAt': STRING;
922:          prop_getter  132    8          // tmp132 = password[tmp131];
923:           assignment  133    6          // tmp133 = password : TYPEOF(password);
924:               call_n  134  132          // 
925:                 meta    1    1          // 
926:                 meta    2    6          // tmp134 = tmp132 (this_arg = tmp133, i);
927:           assignment  135    1          // tmp135 = 255: SMALLINT;
928:                b_and  136  134          // tmp136 = tmp134 & tmp135;
929:          prop_setter    5    6          // pwBytes[i] = tmp136;
930:            post_incr  137               // tmp137 = i++;
931:           assignment  138    6          // tmp138 = i : TYPEOF(i);
932:            less_than  139  138          // tmp139 = tmp138 < nBytes;
933:       is_true_jmp_up  139    0          // if (tmp139) goto 921;
934:               call_n  130    9          // 
935:                 meta    2    5          // tmp130 = KeyExpansion (pwBytes);
936:           assignment   10    6          // pwKeySchedule = tmp130 : TYPEOF(tmp130);
937:               call_n  130   11          // 
938:                 meta    2    5          // 
939:                 meta    2   10          // tmp130 = Cipher (pwBytes, pwKeySchedule);
940:           assignment   12    6          // key = tmp130 : TYPEOF(tmp130);
941:           assignment  130    5          // tmp130 = 'concat': STRING;
942:          prop_getter  131   12          // tmp131 = key[tmp130];
943:           assignment  132    6          // tmp132 = key : TYPEOF(key);
944:               call_n  133  131          // 
945:                 meta    1    1          // 
946:           assignment  133    5          // tmp133 = 'slice': STRING;
947:          prop_getter  134   12          // tmp134 = key[tmp133];
948:           assignment  135    6          // tmp135 = key : TYPEOF(key);
949:               call_n  136  134          // 
950:                 meta    1    1          // 
951:           assignment  136    1          // tmp136 = 0: SMALLINT;
952:                 meta    2  136          // 
953:           assignment  136    6          // tmp136 = nBytes : TYPEOF(nBytes);
954:           assignment  137    1          // tmp137 = 16: SMALLINT;
955:         substraction  138  136          // tmp138 = tmp136 - tmp137;
956:                 meta    2  138          // tmp136 = tmp134 (this_arg = tmp135, tmp136, tmp138);
957:                 meta    2  136          // 
958:           assignment   12    6          // key = tmp133 : TYPEOF(tmp133);
959:               call_n  130    9          // 
960:                 meta    2    0          // tmp130 = KeyExpansion (key);
961:           assignment    1    6          // keySchedule = tmp130 : TYPEOF(tmp130);
962:           assignment  130    5          // tmp130 = 'split': STRING;
963:          prop_getter  131    3          // tmp131 = ciphertext[tmp130];
964:           assignment  132    6          // tmp132 = ciphertext : TYPEOF(ciphertext);
965:               call_n  133  131          // 
966:                 meta    1    1          // 
967:           assignment  133    5          // tmp133 = '-': STRING;
968:                 meta    2  133          // tmp133 = tmp131 (this_arg = tmp132, tmp133);
969:           assignment    3    6          // ciphertext = tmp133 : TYPEOF(tmp133);
970:           assignment  130    1          // tmp130 = 16: SMALLINT;
971:           assignment    5    6          // blockSize = tmp130 : TYPEOF(tmp130);
972:          construct_n  130    6          // 
973:                 meta    2    5          // tmp130 = new Array (blockSize);
974:           assignment    7    6          // counterBlock = tmp130 : TYPEOF(tmp130);
975:               call_n  130    8          // 
976:           assignment  130    1          // tmp130 = 0: SMALLINT;
977:          prop_getter  131    3          // tmp131 = ciphertext[tmp130];
978:                 meta    2  131          // tmp130 = unescCtrlChars (tmp131);
979:           assignment    9    6          // ctrTxt = tmp130 : TYPEOF(tmp130);
980:           assignment  130    1          // tmp130 = 0: SMALLINT;
981:           assignment   10    6          // i = tmp130 : TYPEOF(tmp130);
982:             jmp_down    0               // goto 991;
983:           assignment  131    5          // tmp131 = 'charCodeAt': STRING;
984:          prop_getter  132    9          // tmp132 = ctrTxt[tmp131];
985:           assignment  133    6          // tmp133 = ctrTxt : TYPEOF(ctrTxt);
986:               call_n  134  132          // 
987:                 meta    1    1          // 
988:                 meta    2   10          // tmp134 = tmp132 (this_arg = tmp133, i);
989:          prop_setter    7   10          // counterBlock[i] = tmp134;
990:            post_incr  135               // tmp135 = i++;
991:           assignment  136    6          // tmp136 = i : TYPEOF(i);
992:           assignment  137    1          // tmp137 = 8: SMALLINT;
993:            less_than  138  136          // tmp138 = tmp136 < tmp137;
994:       is_true_jmp_up  138    0          // if (tmp138) goto 983;
995:          construct_n  130    6          // 
996:           assignment  130    5          // tmp130 = 'length': STRING;
997:          prop_getter  131    3          // tmp131 = ciphertext[tmp130];
998:           assignment  132    1          // tmp132 = 1: SMALLINT;
999:         substraction  133  131          // tmp133 = tmp131 - tmp132;
1000:                 meta    2  133          // tmp130 = new Array (tmp133);
1001:           assignment   13    6          // plaintext = tmp130 : TYPEOF(tmp130);
1002:           assignment  130    1          // tmp130 = 1: SMALLINT;
1003:           assignment   14    6          // b = tmp130 : TYPEOF(tmp130);
1004:             jmp_down    0               // goto 1094;
1005:           assignment  130    1          // tmp130 = 0: SMALLINT;
1006:           assignment   15    6          // c = tmp130 : TYPEOF(tmp130);
1007:             jmp_down    0               // goto 1021;
1008:           assignment  130    1          // tmp130 = 15: SMALLINT;
1009:         substraction  131  130          // tmp131 = tmp130 - c;
1010:           assignment  133    6          // tmp133 = b : TYPEOF(b);
1011:           assignment  134    1          // tmp134 = 1: SMALLINT;
1012:         substraction  135  133          // tmp135 = tmp133 - tmp134;
1013:           assignment  136    6          // tmp136 = c : TYPEOF(c);
1014:           assignment  137    1          // tmp137 = 8: SMALLINT;
1015:       multiplication  138  136          // tmp138 = tmp136 * tmp137;
1016:       b_shift_uright  139  135          // tmp139 = tmp135 >>> tmp138;
1017:           assignment  140    1          // tmp140 = 255: SMALLINT;
1018:                b_and  141  139          // tmp141 = tmp139 & tmp140;
1019:          prop_setter    7  131          // counterBlock[tmp131] = tmp141;
1020:            post_incr  142               // tmp142 = c++;
1021:           assignment  143    6          // tmp143 = c : TYPEOF(c);
1022:           assignment  144    1          // tmp144 = 4: SMALLINT;
1023:            less_than  145  143          // tmp145 = tmp143 < tmp144;
1024:       is_true_jmp_up  145    0          // if (tmp145) goto 1008;
1025:           assignment  130    1          // tmp130 = 0: SMALLINT;
1026:           assignment    0    6          // c = tmp130 : TYPEOF(tmp130);
1027:             jmp_down    0               // goto 1045;
1028:           assignment  130    1          // tmp130 = 15: SMALLINT;
1029:         substraction  131  130          // tmp131 = tmp130 - c;
1030:           assignment  132    1          // tmp132 = 4: SMALLINT;
1031:         substraction  133  131          // tmp133 = tmp131 - tmp132;
1032:           assignment  135    6          // tmp135 = b : TYPEOF(b);
1033:           assignment  136    3          // tmp136 = 4294967296: NUMBER;
1034:             division  137  135          // tmp137 = tmp135 / tmp136;
1035:           assignment  138    1          // tmp138 = 1: SMALLINT;
1036:         substraction  139  137          // tmp139 = tmp137 - tmp138;
1037:           assignment  140    6          // tmp140 = c : TYPEOF(c);
1038:           assignment  141    1          // tmp141 = 8: SMALLINT;
1039:       multiplication  142  140          // tmp142 = tmp140 * tmp141;
1040:       b_shift_uright  143  139          // tmp143 = tmp139 >>> tmp142;
1041:           assignment  144    1          // tmp144 = 255: SMALLINT;
1042:                b_and  145  143          // tmp145 = tmp143 & tmp144;
1043:          prop_setter    3  133          // counterBlock[tmp133] = tmp145;
1044:            post_incr  146               // tmp146 = c++;
1045:           assignment  147    6          // tmp147 = c : TYPEOF(c);
1046:           assignment  148    1          // tmp148 = 4: SMALLINT;
1047:            less_than  149  147          // tmp149 = tmp147 < tmp148;
1048:       is_true_jmp_up  149    0          // if (tmp149) goto 1028;
1049:               call_n  130    4          // 
1050:                 meta    2    3          // 
1051:                 meta    2    5          // tmp130 = Cipher (counterBlock, keySchedule);
1052:           assignment    6    6          // cipherCntr = tmp130 : TYPEOF(tmp130);
1053:               call_n  131    7          // 
1054:          prop_getter  131    8          // tmp131 = ciphertext[b];
1055:                 meta    2  131          // tmp131 = unescCtrlChars (tmp131);
1056:          prop_setter    8    1          // ciphertext[b] = tmp131;
1057:           assignment  130    5          // tmp130 = '': STRING;
1058:           assignment   10    6          // pt = tmp130 : TYPEOF(tmp130);
1059:           assignment  130    1          // tmp130 = 0: SMALLINT;
1060:           assignment   11    6          // i = tmp130 : TYPEOF(tmp130);
1061:             jmp_down    0               // goto 1082;
1062:          prop_getter  130    8          // tmp130 = ciphertext[b];
1063:           assignment  131    5          // tmp131 = 'charCodeAt': STRING;
1064:          prop_getter  132  130          // tmp132 = tmp130[tmp131];
1065:               call_n  133  132          // 
1066:                 meta    1    1          // 
1067:                 meta    2   11          // tmp133 = tmp132 (this_arg = tmp130, i);
1068:           assignment   13    6          // ciphertextByte = tmp133 : TYPEOF(tmp133);
1069:           assignment  130    6          // tmp130 = ciphertextByte : TYPEOF(ciphertextByte);
1070:          prop_getter  131    6          // tmp131 = cipherCntr[i];
1071:                b_xor  132  130          // tmp132 = tmp130 ^ tmp131;
1072:           assignment   14    6          // plaintextByte = tmp132 : TYPEOF(tmp132);
1073:           assignment  130    5          // tmp130 = 'fromCharCode': STRING;
1074:          prop_getter  131   16          // tmp131 = String[tmp130];
1075:           assignment  132    6          // tmp132 = String : TYPEOF(String);
1076:               call_n  133  131          // 
1077:                 meta    1    1          // 
1078:                 meta    2   14          // tmp133 = tmp131 (this_arg = tmp132, plaintextByte);
1079:             addition   10   10          // pt = pt + tmp133;
1080:           assignment  134    6          // tmp134 = pt : TYPEOF(pt);
1081:            post_incr  135               // tmp135 = i++;
1082:           assignment  136    6          // tmp136 = i : TYPEOF(i);
1083:          prop_getter  137    8          // tmp137 = ciphertext[b];
1084:           assignment  138    5          // tmp138 = 'length': STRING;
1085:          prop_getter  139  137          // tmp139 = tmp137[tmp138];
1086:            less_than  140  136          // tmp140 = tmp136 < tmp139;
1087:       is_true_jmp_up  140    0          // if (tmp140) goto 1062;
1088:           assignment  130    6          // tmp130 = b : TYPEOF(b);
1089:           assignment  131    1          // tmp131 = 1: SMALLINT;
1090:         substraction  132  130          // tmp132 = tmp130 - tmp131;
1091:          prop_setter    1  132          // plaintext[tmp132] = pt;
1092:           assignment  134    6          // tmp134 = pt : TYPEOF(pt);
1093:            post_incr  135               // tmp135 = b++;
1094:           assignment  136    6          // tmp136 = b : TYPEOF(b);
1095:           assignment  137    5          // tmp137 = 'length': STRING;
1096:          prop_getter  138    4          // tmp138 = ciphertext[tmp137];
1097:            less_than  139  136          // tmp139 = tmp136 < tmp138;
1098:       is_true_jmp_up  139    0          // if (tmp139) goto 1005;
1099:           assignment  130    5          // tmp130 = 'join': STRING;
1100:          prop_getter  131    1          // tmp131 = plaintext[tmp130];
1101:           assignment  132    6          // tmp132 = plaintext : TYPEOF(plaintext);
1102:               call_n  133  131          // 
1103:                 meta    1    1          // 
1104:           assignment  133    5          // tmp133 = '': STRING;
1105:                 meta    2  133          // tmp133 = tmp131 (this_arg = tmp132, tmp133);
1106:               retval                    // return tmp133;
1107:                  ret                    // ret;
1108:          func_decl_n    7               // 
1109:                 meta    2    8          // function escCtrlChars (str);
1110:                 meta    7    0          // function end: 1141;
1111:                 meta   12    6          // [no 'arguments'] [no 'eval'] 
1112:         reg_var_decl  128               // var tmp128 .. tmp133;
1113:           assignment  130    5          // tmp130 = 'replace': STRING;
1114:          prop_getter  131    8          // tmp131 = str[tmp130];
1115:           assignment  132    6          // tmp132 = str : TYPEOF(str);
1116:               call_n  133  131          // 
1117:                 meta    1    1          // 
1118:           assignment  133    7          // tmp133 = 
1119:                 meta    2  133          // 
1120:          func_expr_n  133  255          // 
1121:                 meta    2   11          // tmp133 = function (c);
1122:                 meta    7    0          // function end: 1138;
1123:                 meta   12    6          // [no 'arguments'] [no 'eval'] 
1124:         reg_var_decl  128               // var tmp128 .. tmp137;
1125:           assignment  130    5          // tmp130 = '!': STRING;
1126:           assignment  131    5          // tmp131 = 'charCodeAt': STRING;
1127:          prop_getter  132   11          // tmp132 = c[tmp131];
1128:           assignment  133    6          // tmp133 = c : TYPEOF(c);
1129:               call_n  134  132          // 
1130:                 meta    1    1          // 
1131:           assignment  134    1          // tmp134 = 0: SMALLINT;
1132:                 meta    2  134          // tmp134 = tmp132 (this_arg = tmp133, tmp134);
1133:             addition  135  130          // tmp135 = tmp130 + tmp134;
1134:           assignment  136    5          // tmp136 = '!': STRING;
1135:             addition  137  135          // tmp137 = tmp135 + tmp136;
1136:               retval                    // return tmp137;
1137:                  ret                    // ret;
1138:                 meta    2  133          // 
1139:               retval                    // return tmp133;
1140:                  ret                    // ret;
1141:          func_decl_n   14               // 
1142:                 meta    2    8          // function unescCtrlChars (str);
1143:                 meta    7    0          // function end: 1179;
1144:                 meta   12    6          // [no 'arguments'] [no 'eval'] 
1145:         reg_var_decl  128               // var tmp128 .. tmp133;
1146:           assignment  130    5          // tmp130 = 'replace': STRING;
1147:          prop_getter  131    8          // tmp131 = str[tmp130];
1148:           assignment  132    6          // tmp132 = str : TYPEOF(str);
1149:               call_n  133  131          // 
1150:                 meta    1    1          // 
1151:           assignment  133    7          // tmp133 = 
1152:                 meta    2  133          // 
1153:          func_expr_n  133  255          // 
1154:                 meta    2    0          // tmp133 = function (c);
1155:                 meta    7    0          // function end: 1176;
1156:                 meta   12    6          // [no 'arguments'] [no 'eval'] 
1157:         reg_var_decl  128               // var tmp128 .. tmp137;
1158:           assignment  130    5          // tmp130 = 'fromCharCode': STRING;
1159:          prop_getter  131    2          // tmp131 = String[tmp130];
1160:           assignment  132    6          // tmp132 = String : TYPEOF(String);
1161:               call_n  133  131          // 
1162:                 meta    1    1          // 
1163:           assignment  133    5          // tmp133 = 'slice': STRING;
1164:          prop_getter  134    0          // tmp134 = c[tmp133];
1165:           assignment  135    6          // tmp135 = c : TYPEOF(c);
1166:               call_n  136  134          // 
1167:                 meta    1    1          // 
1168:           assignment  136    1          // tmp136 = 1: SMALLINT;
1169:                 meta    2  136          // 
1170:           assignment  136    1          // tmp136 = 1: SMALLINT;
1171:          unary_minus  137               // tmp137 = -tmp136;
1172:                 meta    2  137          // tmp136 = tmp134 (this_arg = tmp135, tmp136, tmp137);
1173:                 meta    2  136          // 
1174:               retval                    // return tmp133;
1175:                  ret                    // ret;
1176:                 meta    2  133          // 
1177:               retval                    // return tmp133;
1178:                  ret                    // ret;
1179:          func_decl_n    4               // 
1180:                 meta    2    5          // function encodeBase64 (str);
1181:                 meta    7    0          // function end: 1302;
1182:                 meta   12    6          // [no 'arguments'] [no 'eval'] 
1183:         reg_var_decl  128               // var tmp128 .. tmp153;
1184:             var_decl                    // var o1;
1185:             var_decl                    // var o2;
1186:             var_decl                    // var o3;
1187:             var_decl                    // var h1;
1188:             var_decl                    // var h2;
1189:             var_decl                    // var h3;
1190:             var_decl                    // var h4;
1191:             var_decl                    // var bits;
1192:             var_decl                    // var i;
1193:             var_decl                    // var enc;
1194:           assignment  130    1          // tmp130 = 0: SMALLINT;
1195:           assignment   14    6          // i = tmp130 : TYPEOF(tmp130);
1196:           assignment  131    5          // tmp131 = '': STRING;
1197:           assignment   15    6          // enc = tmp131 : TYPEOF(tmp131);
1198:               call_n  130   17          // 
1199:                 meta    2    5          // tmp130 = encodeUTF8 (str);
1200:           assignment    5    6          // str = tmp130 : TYPEOF(tmp130);
1201:           assignment  130    5          // tmp130 = 'charCodeAt': STRING;
1202:          prop_getter  131    5          // tmp131 = str[tmp130];
1203:           assignment  132    6          // tmp132 = str : TYPEOF(str);
1204:               call_n  133  131          // 
1205:                 meta    1    1          // 
1206:            post_incr  133               // tmp133 = i++;
1207:                 meta    2  133          // tmp133 = tmp131 (this_arg = tmp132, tmp133);
1208:           assignment    6    6          // o1 = tmp133 : TYPEOF(tmp133);
1209:           assignment  130    5          // tmp130 = 'charCodeAt': STRING;
1210:          prop_getter  131    5          // tmp131 = str[tmp130];
1211:           assignment  132    6          // tmp132 = str : TYPEOF(str);
1212:               call_n  133  131          // 
1213:                 meta    1    1          // 
1214:            post_incr  133               // tmp133 = i++;
1215:                 meta    2  133          // tmp133 = tmp131 (this_arg = tmp132, tmp133);
1216:           assignment    0    6          // o2 = tmp133 : TYPEOF(tmp133);
1217:           assignment  130    5          // tmp130 = 'charCodeAt': STRING;
1218:          prop_getter  131    2          // tmp131 = str[tmp130];
1219:           assignment  132    6          // tmp132 = str : TYPEOF(str);
1220:               call_n  133  131          // 
1221:                 meta    1    1          // 
1222:            post_incr  133               // tmp133 = i++;
1223:                 meta    2  133          // tmp133 = tmp131 (this_arg = tmp132, tmp133);
1224:           assignment    4    6          // o3 = tmp133 : TYPEOF(tmp133);
1225:           assignment  130    6          // tmp130 = o1 : TYPEOF(o1);
1226:           assignment  131    1          // tmp131 = 16: SMALLINT;
1227:         b_shift_left  132  130          // tmp132 = tmp130 << tmp131;
1228:           assignment  133    6          // tmp133 = o2 : TYPEOF(o2);
1229:           assignment  134    1          // tmp134 = 8: SMALLINT;
1230:         b_shift_left  135  133          // tmp135 = tmp133 << tmp134;
1231:                 b_or  136  132          // tmp136 = tmp132 | tmp135;
1232:                 b_or  137  136          // tmp137 = tmp136 | o3;
1233:           assignment    6    6          // bits = tmp137 : TYPEOF(tmp137);
1234:           assignment  130    6          // tmp130 = bits : TYPEOF(bits);
1235:           assignment  131    1          // tmp131 = 18: SMALLINT;
1236:        b_shift_right  132  130          // tmp132 = tmp130 >> tmp131;
1237:           assignment  133    1          // tmp133 = 63: SMALLINT;
1238:                b_and  134  132          // tmp134 = tmp132 & tmp133;
1239:           assignment    7    6          // h1 = tmp134 : TYPEOF(tmp134);
1240:           assignment  130    6          // tmp130 = bits : TYPEOF(bits);
1241:           assignment  131    1          // tmp131 = 12: SMALLINT;
1242:        b_shift_right  132  130          // tmp132 = tmp130 >> tmp131;
1243:           assignment  133    1          // tmp133 = 63: SMALLINT;
1244:                b_and  134  132          // tmp134 = tmp132 & tmp133;
1245:           assignment    8    6          // h2 = tmp134 : TYPEOF(tmp134);
1246:           assignment  130    6          // tmp130 = bits : TYPEOF(bits);
1247:           assignment  131    1          // tmp131 = 6: SMALLINT;
1248:        b_shift_right  132  130          // tmp132 = tmp130 >> tmp131;
1249:           assignment  133    1          // tmp133 = 63: SMALLINT;
1250:                b_and  134  132          // tmp134 = tmp132 & tmp133;
1251:           assignment    9    6          // h3 = tmp134 : TYPEOF(tmp134);
1252:           assignment  130    6          // tmp130 = bits : TYPEOF(bits);
1253:           assignment  131    1          // tmp131 = 63: SMALLINT;
1254:                b_and  132  130          // tmp132 = tmp130 & tmp131;
1255:           assignment   10    6          // h4 = tmp132 : TYPEOF(tmp132);
1256:               call_n  130   11          // 
1257:                 meta    2    4          // tmp130 = isNaN (o3);
1258:    is_false_jmp_down  130    0          // if (tmp130 == false) goto 1261;
1259:           assignment  130    1          // tmp130 = 64: SMALLINT;
1260:           assignment   10    6          // h4 = tmp130 : TYPEOF(tmp130);
1261:               call_n  130   11          // 
1262:                 meta    2    0          // tmp130 = isNaN (o2);
1263:    is_false_jmp_down  130    0          // if (tmp130 == false) goto 1266;
1264:           assignment  130    1          // tmp130 = 64: SMALLINT;
1265:           assignment    9    6          // h3 = tmp130 : TYPEOF(tmp130);
1266:           assignment  130    5          // tmp130 = 'charAt': STRING;
1267:          prop_getter  131   13          // tmp131 = b64[tmp130];
1268:           assignment  132    6          // tmp132 = b64 : TYPEOF(b64);
1269:               call_n  133  131          // 
1270:                 meta    1    1          // 
1271:                 meta    2    7          // tmp133 = tmp131 (this_arg = tmp132, h1);
1272:           assignment  134    5          // tmp134 = 'charAt': STRING;
1273:          prop_getter  135   13          // tmp135 = b64[tmp134];
1274:           assignment  136    6          // tmp136 = b64 : TYPEOF(b64);
1275:               call_n  137  135          // 
1276:                 meta    1    1          // 
1277:                 meta    2    8          // tmp137 = tmp135 (this_arg = tmp136, h2);
1278:             addition  138  133          // tmp138 = tmp133 + tmp137;
1279:           assignment  139    5          // tmp139 = 'charAt': STRING;
1280:          prop_getter  140    0          // tmp140 = b64[tmp139];
1281:           assignment  141    6          // tmp141 = b64 : TYPEOF(b64);
1282:               call_n  142  140          // 
1283:                 meta    1    1          // 
1284:                 meta    2    1          // tmp142 = tmp140 (this_arg = tmp141, h3);
1285:             addition  143  138          // tmp143 = tmp138 + tmp142;
1286:           assignment  144    5          // tmp144 = 'charAt': STRING;
1287:          prop_getter  145    0          // tmp145 = b64[tmp144];
1288:           assignment  146    6          // tmp146 = b64 : TYPEOF(b64);
1289:               call_n  147  145          // 
1290:                 meta    1    1          // 
1291:                 meta    2    3          // tmp147 = tmp145 (this_arg = tmp146, h4);
1292:             addition  148  143          // tmp148 = tmp143 + tmp147;
1293:             addition    4    4          // enc = enc + tmp148;
1294:           assignment  149    6          // tmp149 = enc : TYPEOF(enc);
1295:           assignment  150    6          // tmp150 = i : TYPEOF(i);
1296:           assignment  151    5          // tmp151 = 'length': STRING;
1297:          prop_getter  152    7          // tmp152 = str[tmp151];
1298:            less_than  153  150          // tmp153 = tmp150 < tmp152;
1299:       is_true_jmp_up  153    0          // if (tmp153) goto 1201;
1300:               retval                    // return enc;
1301:                  ret                    // ret;
1302:          func_decl_n    8               // 
1303:                 meta    2    7          // function decodeBase64 (str);
1304:                 meta    7    0          // function end: 1452;
1305:                 meta   12    6          // [no 'arguments'] [no 'eval'] 
1306:         reg_var_decl  128               // var tmp128 .. tmp141;
1307:             var_decl                    // var o1;
1308:             var_decl                    // var o2;
1309:             var_decl                    // var o3;
1310:             var_decl                    // var h1;
1311:             var_decl                    // var h2;
1312:             var_decl                    // var h3;
1313:             var_decl                    // var h4;
1314:             var_decl                    // var bits;
1315:             var_decl                    // var i;
1316:             var_decl                    // var enc;
1317:           assignment  130    1          // tmp130 = 0: SMALLINT;
1318:           assignment    5    6          // i = tmp130 : TYPEOF(tmp130);
1319:           assignment  131    5          // tmp131 = '': STRING;
1320:           assignment    4    6          // enc = tmp131 : TYPEOF(tmp131);
1321:           assignment  130    5          // tmp130 = 'indexOf': STRING;
1322:          prop_getter  131    0          // tmp131 = b64[tmp130];
1323:           assignment  132    6          // tmp132 = b64 : TYPEOF(b64);
1324:               call_n  133  131          // 
1325:                 meta    1    1          // 
1326:           assignment  133    5          // tmp133 = 'charAt': STRING;
1327:          prop_getter  134    7          // tmp134 = str[tmp133];
1328:           assignment  135    6          // tmp135 = str : TYPEOF(str);
1329:               call_n  136  134          // 
1330:                 meta    1    1          // 
1331:            post_incr  136               // tmp136 = i++;
1332:                 meta    2  136          // tmp136 = tmp134 (this_arg = tmp135, tmp136);
1333:                 meta    2  136          // 
1334:           assignment   12    6          // h1 = tmp133 : TYPEOF(tmp133);
1335:           assignment  130    5          // tmp130 = 'indexOf': STRING;
1336:          prop_getter  131    0          // tmp131 = b64[tmp130];
1337:           assignment  132    6          // tmp132 = b64 : TYPEOF(b64);
1338:               call_n  133  131          // 
1339:                 meta    1    1          // 
1340:           assignment  133    5          // tmp133 = 'charAt': STRING;
1341:          prop_getter  134    7          // tmp134 = str[tmp133];
1342:           assignment  135    6          // tmp135 = str : TYPEOF(str);
1343:               call_n  136  134          // 
1344:                 meta    1    1          // 
1345:            post_incr  136               // tmp136 = i++;
1346:                 meta    2  136          // tmp136 = tmp134 (this_arg = tmp135, tmp136);
1347:                 meta    2  136          // 
1348:           assignment    1    6          // h2 = tmp133 : TYPEOF(tmp133);
1349:           assignment  130    5          // tmp130 = 'indexOf': STRING;
1350:          prop_getter  131    3          // tmp131 = b64[tmp130];
1351:           assignment  132    6          // tmp132 = b64 : TYPEOF(b64);
1352:               call_n  133  131          // 
1353:                 meta    1    1          // 
1354:           assignment  133    5          // tmp133 = 'charAt': STRING;
1355:          prop_getter  134    5          // tmp134 = str[tmp133];
1356:           assignment  135    6          // tmp135 = str : TYPEOF(str);
1357:               call_n  136  134          // 
1358:                 meta    1    1          // 
1359:            post_incr  136               // tmp136 = i++;
1360:                 meta    2  136          // tmp136 = tmp134 (this_arg = tmp135, tmp136);
1361:                 meta    2  136          // 
1362:           assignment    6    6          // h3 = tmp133 : TYPEOF(tmp133);
1363:           assignment  130    5          // tmp130 = 'indexOf': STRING;
1364:          prop_getter  131    3          // tmp131 = b64[tmp130];
1365:           assignment  132    6          // tmp132 = b64 : TYPEOF(b64);
1366:               call_n  133  131          // 
1367:                 meta    1    1          // 
1368:           assignment  133    5          // tmp133 = 'charAt': STRING;
1369:          prop_getter  134    5          // tmp134 = str[tmp133];
1370:           assignment  135    6          // tmp135 = str : TYPEOF(str);
1371:               call_n  136  134          // 
1372:                 meta    1    1          // 
1373:            post_incr  136               // tmp136 = i++;
1374:                 meta    2  136          // tmp136 = tmp134 (this_arg = tmp135, tmp136);
1375:                 meta    2  136          // 
1376:           assignment    7    6          // h4 = tmp133 : TYPEOF(tmp133);
1377:           assignment  130    6          // tmp130 = h1 : TYPEOF(h1);
1378:           assignment  131    1          // tmp131 = 18: SMALLINT;
1379:         b_shift_left  132  130          // tmp132 = tmp130 << tmp131;
1380:           assignment  133    6          // tmp133 = h2 : TYPEOF(h2);
1381:           assignment  134    1          // tmp134 = 12: SMALLINT;
1382:         b_shift_left  135  133          // tmp135 = tmp133 << tmp134;
1383:                 b_or  136  132          // tmp136 = tmp132 | tmp135;
1384:           assignment  137    6          // tmp137 = h3 : TYPEOF(h3);
1385:           assignment  138    1          // tmp138 = 6: SMALLINT;
1386:         b_shift_left  139  137          // tmp139 = tmp137 << tmp138;
1387:                 b_or  140  136          // tmp140 = tmp136 | tmp139;
1388:                 b_or  141  140          // tmp141 = tmp140 | h4;
1389:           assignment    9    6          // bits = tmp141 : TYPEOF(tmp141);
1390:           assignment  130    6          // tmp130 = bits : TYPEOF(bits);
1391:           assignment  131    1          // tmp131 = 16: SMALLINT;
1392:        b_shift_right  132  130          // tmp132 = tmp130 >> tmp131;
1393:           assignment  133    1          // tmp133 = 255: SMALLINT;
1394:                b_and  134  132          // tmp134 = tmp132 & tmp133;
1395:           assignment   10    6          // o1 = tmp134 : TYPEOF(tmp134);
1396:           assignment  130    6          // tmp130 = bits : TYPEOF(bits);
1397:           assignment  131    1          // tmp131 = 8: SMALLINT;
1398:        b_shift_right  132  130          // tmp132 = tmp130 >> tmp131;
1399:           assignment  133    1          // tmp133 = 255: SMALLINT;
1400:                b_and  134  132          // tmp134 = tmp132 & tmp133;
1401:           assignment   11    6          // o2 = tmp134 : TYPEOF(tmp134);
1402:           assignment  130    6          // tmp130 = bits : TYPEOF(bits);
1403:           assignment  131    1          // tmp131 = 255: SMALLINT;
1404:                b_and  132  130          // tmp132 = tmp130 & tmp131;
1405:           assignment   12    6          // o3 = tmp132 : TYPEOF(tmp132);
1406:           assignment  130    6          // tmp130 = h3 : TYPEOF(h3);
1407:           assignment  131    1          // tmp131 = 64: SMALLINT;
1408:          equal_value  132  130          // tmp132 = tmp130 == tmp131;
1409:    is_false_jmp_down  132    0          // if (tmp132 == false) goto 1419;
1410:           assignment  130    5          // tmp130 = 'fromCharCode': STRING;
1411:          prop_getter  131    1          // tmp131 = String[tmp130];
1412:           assignment  132    6          // tmp132 = String : TYPEOF(String);
1413:               call_n  133  131          // 
1414:                 meta    1    1          // 
1415:                 meta    2    2          // tmp133 = tmp131 (this_arg = tmp132, o1);
1416:             addition    3    3          // enc = enc + tmp133;
1417:           assignment  134    6          // tmp134 = enc : TYPEOF(enc);
1418:             jmp_down    0               // goto 1443;
1419:           assignment  130    6          // tmp130 = h4 : TYPEOF(h4);
1420:           assignment  131    1          // tmp131 = 64: SMALLINT;
1421:          equal_value  132  130          // tmp132 = tmp130 == tmp131;
1422:    is_false_jmp_down  132    0          // if (tmp132 == false) goto 1433;
1423:           assignment  130    5          // tmp130 = 'fromCharCode': STRING;
1424:          prop_getter  131    1          // tmp131 = String[tmp130];
1425:           assignment  132    6          // tmp132 = String : TYPEOF(String);
1426:               call_n  133  131          // 
1427:                 meta    1    1          // 
1428:                 meta    2    2          // 
1429:                 meta    2    5          // tmp133 = tmp131 (this_arg = tmp132, o1, o2);
1430:             addition    3    3          // enc = enc + tmp133;
1431:           assignment  134    6          // tmp134 = enc : TYPEOF(enc);
1432:             jmp_down    0               // goto 1443;
1433:           assignment  130    5          // tmp130 = 'fromCharCode': STRING;
1434:          prop_getter  131    1          // tmp131 = String[tmp130];
1435:           assignment  132    6          // tmp132 = String : TYPEOF(String);
1436:               call_n  133  131          // 
1437:                 meta    1    1          // 
1438:                 meta    2    2          // 
1439:                 meta    2    5          // 
1440:                 meta    2    6          // tmp133 = tmp131 (this_arg = tmp132, o1, o2, o3);
1441:             addition    3    3          // enc = enc + tmp133;
1442:           assignment  134    6          // tmp134 = enc : TYPEOF(enc);
1443:           assignment  135    6          // tmp135 = i : TYPEOF(i);
1444:           assignment  136    5          // tmp136 = 'length': STRING;
1445:          prop_getter  137    9          // tmp137 = str[tmp136];
1446:            less_than  138  135          // tmp138 = tmp135 < tmp137;
1447:       is_true_jmp_up  138    0          // if (tmp138) goto 1321;
1448:               call_n  130   10          // 
1449:                 meta    2    3          // tmp130 = decodeUTF8 (enc);
1450:               retval                    // return tmp130;
1451:                  ret                    // ret;
1452:          func_decl_n   11               // 
1453:                 meta    2    9          // function encodeUTF8 (str);
1454:                 meta    7    0          // function end: 1551;
1455:                 meta   12    6          // [no 'arguments'] [no 'eval'] 
1456:         reg_var_decl  128               // var tmp128 .. tmp133;
1457:           assignment  130    5          // tmp130 = 'replace': STRING;
1458:          prop_getter  131    9          // tmp131 = str[tmp130];
1459:           assignment  132    6          // tmp132 = str : TYPEOF(str);
1460:               call_n  133  131          // 
1461:                 meta    1    1          // 
1462:           assignment  133    7          // tmp133 = 
1463:                 meta    2  133          // 
1464:          func_expr_n  133  255          // 
1465:                 meta    2   14          // tmp133 = function (c);
1466:                 meta    7    0          // function end: 1497;
1467:                 meta   12    6          // [no 'arguments'] [no 'eval'] 
1468:         reg_var_decl  128               // var tmp128 .. tmp137;
1469:             var_decl                    // var cc;
1470:           assignment  130    5          // tmp130 = 'charCodeAt': STRING;
1471:          prop_getter  131   14          // tmp131 = c[tmp130];
1472:           assignment  132    6          // tmp132 = c : TYPEOF(c);
1473:               call_n  133  131          // 
1474:                 meta    1    1          // 
1475:           assignment  133    1          // tmp133 = 0: SMALLINT;
1476:                 meta    2  133          // tmp133 = tmp131 (this_arg = tmp132, tmp133);
1477:           assignment    1    6          // cc = tmp133 : TYPEOF(tmp133);
1478:           assignment  130    5          // tmp130 = 'fromCharCode': STRING;
1479:          prop_getter  131    3          // tmp131 = String[tmp130];
1480:           assignment  132    6          // tmp132 = String : TYPEOF(String);
1481:               call_n  133  131          // 
1482:                 meta    1    1          // 
1483:           assignment  133    1          // tmp133 = 192: SMALLINT;
1484:           assignment  134    6          // tmp134 = cc : TYPEOF(cc);
1485:           assignment  135    1          // tmp135 = 6: SMALLINT;
1486:        b_shift_right  136  134          // tmp136 = tmp134 >> tmp135;
1487:                 b_or  137  133          // tmp137 = tmp133 | tmp136;
1488:                 meta    2  137          // 
1489:           assignment  133    1          // tmp133 = 128: SMALLINT;
1490:           assignment  134    6          // tmp134 = cc : TYPEOF(cc);
1491:           assignment  135    1          // tmp135 = 63: SMALLINT;
1492:                b_and  136  134          // tmp136 = tmp134 & tmp135;
1493:                 b_or  137  133          // tmp137 = tmp133 | tmp136;
1494:                 meta    2  137          // tmp133 = tmp131 (this_arg = tmp132, tmp137, tmp137);
1495:               retval                    // return tmp133;
1496:                  ret                    // ret;
1497:                 meta    2  133          // 
1498:           assignment    4    6          // str = tmp133 : TYPEOF(tmp133);
1499:           assignment  130    5          // tmp130 = 'replace': STRING;
1500:          prop_getter  131    4          // tmp131 = str[tmp130];
1501:           assignment  132    6          // tmp132 = str : TYPEOF(str);
1502:               call_n  133  131          // 
1503:                 meta    1    1          // 
1504:           assignment  133    7          // tmp133 = 
1505:                 meta    2  133          // 
1506:          func_expr_n  133  255          // 
1507:                 meta    2    0          // tmp133 = function (c);
1508:                 meta    7    0          // function end: 1547;
1509:                 meta   12    6          // [no 'arguments'] [no 'eval'] 
1510:         reg_var_decl  128               // var tmp128 .. tmp139;
1511:             var_decl                    // var cc;
1512:           assignment  130    5          // tmp130 = 'charCodeAt': STRING;
1513:          prop_getter  131    0          // tmp131 = c[tmp130];
1514:           assignment  132    6          // tmp132 = c : TYPEOF(c);
1515:               call_n  133  131          // 
1516:                 meta    1    1          // 
1517:           assignment  133    1          // tmp133 = 0: SMALLINT;
1518:                 meta    2  133          // tmp133 = tmp131 (this_arg = tmp132, tmp133);
1519:           assignment    1    6          // cc = tmp133 : TYPEOF(tmp133);
1520:           assignment  130    5          // tmp130 = 'fromCharCode': STRING;
1521:          prop_getter  131    3          // tmp131 = String[tmp130];
1522:           assignment  132    6          // tmp132 = String : TYPEOF(String);
1523:               call_n  133  131          // 
1524:                 meta    1    1          // 
1525:           assignment  133    1          // tmp133 = 224: SMALLINT;
1526:           assignment  134    6          // tmp134 = cc : TYPEOF(cc);
1527:           assignment  135    1          // tmp135 = 12: SMALLINT;
1528:        b_shift_right  136  134          // tmp136 = tmp134 >> tmp135;
1529:                 b_or  137  133          // tmp137 = tmp133 | tmp136;
1530:                 meta    2  137          // 
1531:           assignment  133    1          // tmp133 = 128: SMALLINT;
1532:           assignment  134    6          // tmp134 = cc : TYPEOF(cc);
1533:           assignment  135    1          // tmp135 = 6: SMALLINT;
1534:        b_shift_right  136  134          // tmp136 = tmp134 >> tmp135;
1535:           assignment  137    1          // tmp137 = 63: SMALLINT;
1536:                b_and  138  136          // tmp138 = tmp136 & tmp137;
1537:                 b_or  139  133          // tmp139 = tmp133 | tmp138;
1538:                 meta    2  139          // 
1539:           assignment  133    1          // tmp133 = 128: SMALLINT;
1540:           assignment  134    6          // tmp134 = cc : TYPEOF(cc);
1541:           assignment  135    1          // tmp135 = 63: SMALLINT;
1542:                b_and  136  134          // tmp136 = tmp134 & tmp135;
1543:                 b_or  137  133          // tmp137 = tmp133 | tmp136;
1544:                 meta    2  137          // tmp133 = tmp131 (this_arg = tmp132, tmp137, tmp139, tmp137);
1545:               retval                    // return tmp133;
1546:                  ret                    // ret;
1547:                 meta    2  133          // 
1548:           assignment    1    6          // str = tmp133 : TYPEOF(tmp133);
1549:               retval                    // return str;
1550:                  ret                    // ret;
1551:          func_decl_n    2               // 
1552:                 meta    2    1          // function decodeUTF8 (str);
1553:                 meta    7    0          // function end: 1660;
1554:                 meta   12    6          // [no 'arguments'] [no 'eval'] 
1555:         reg_var_decl  128               // var tmp128 .. tmp133;
1556:           assignment  130    5          // tmp130 = 'replace': STRING;
1557:          prop_getter  131    1          // tmp131 = str[tmp130];
1558:           assignment  132    6          // tmp132 = str : TYPEOF(str);
1559:               call_n  133  131          // 
1560:                 meta    1    1          // 
1561:           assignment  133    7          // tmp133 = 
1562:                 meta    2  133          // 
1563:          func_expr_n  133  255          // 
1564:                 meta    2    5          // tmp133 = function (c);
1565:                 meta    7    0          // function end: 1599;
1566:                 meta   12    6          // [no 'arguments'] [no 'eval'] 
1567:         reg_var_decl  128               // var tmp128 .. tmp144;
1568:             var_decl                    // var cc;
1569:           assignment  130    5          // tmp130 = 'charCodeAt': STRING;
1570:          prop_getter  131    5          // tmp131 = c[tmp130];
1571:           assignment  132    6          // tmp132 = c : TYPEOF(c);
1572:               call_n  133  131          // 
1573:                 meta    1    1          // 
1574:           assignment  133    1          // tmp133 = 0: SMALLINT;
1575:                 meta    2  133          // tmp133 = tmp131 (this_arg = tmp132, tmp133);
1576:           assignment  134    1          // tmp134 = 31: SMALLINT;
1577:                b_and  135  133          // tmp135 = tmp133 & tmp134;
1578:           assignment  136    1          // tmp136 = 6: SMALLINT;
1579:         b_shift_left  137  135          // tmp137 = tmp135 << tmp136;
1580:           assignment  138    5          // tmp138 = 'charCodeAt': STRING;
1581:          prop_getter  139    5          // tmp139 = c[tmp138];
1582:           assignment  140    6          // tmp140 = c : TYPEOF(c);
1583:               call_n  141  139          // 
1584:                 meta    1    1          // 
1585:           assignment  141    1          // tmp141 = 1: SMALLINT;
1586:                 meta    2  141          // tmp141 = tmp139 (this_arg = tmp140, tmp141);
1587:           assignment  142    1          // tmp142 = 63: SMALLINT;
1588:                b_and  143  141          // tmp143 = tmp141 & tmp142;
1589:                 b_or  144  137          // tmp144 = tmp137 | tmp143;
1590:           assignment    0    6          // cc = tmp144 : TYPEOF(tmp144);
1591:           assignment  130    5          // tmp130 = 'fromCharCode': STRING;
1592:          prop_getter  131    8          // tmp131 = String[tmp130];
1593:           assignment  132    6          // tmp132 = String : TYPEOF(String);
1594:               call_n  133  131          // 
1595:                 meta    1    1          // 
1596:                 meta    2    0          // tmp133 = tmp131 (this_arg = tmp132, cc);
1597:               retval                    // return tmp133;
1598:                  ret                    // ret;
1599:                 meta    2  133          // 
1600:           assignment    0    6          // str = tmp133 : TYPEOF(tmp133);
1601:           assignment  130    5          // tmp130 = 'replace': STRING;
1602:          prop_getter  131    0          // tmp131 = str[tmp130];
1603:           assignment  132    6          // tmp132 = str : TYPEOF(str);
1604:               call_n  133  131          // 
1605:                 meta    1    1          // 
1606:           assignment  133    7          // tmp133 = 
1607:                 meta    2  133          // 
1608:          func_expr_n  133  255          // 
1609:                 meta    2    3          // tmp133 = function (c);
1610:                 meta    7    0          // function end: 1656;
1611:                 meta   12    6          // [no 'arguments'] [no 'eval'] 
1612:         reg_var_decl  128               // var tmp128 .. tmp153;
1613:             var_decl                    // var cc;
1614:           assignment  130    5          // tmp130 = 'charCodeAt': STRING;
1615:          prop_getter  131    3          // tmp131 = c[tmp130];
1616:           assignment  132    6          // tmp132 = c : TYPEOF(c);
1617:               call_n  133  131          // 
1618:                 meta    1    1          // 
1619:           assignment  133    1          // tmp133 = 0: SMALLINT;
1620:                 meta    2  133          // tmp133 = tmp131 (this_arg = tmp132, tmp133);
1621:           assignment  134    1          // tmp134 = 15: SMALLINT;
1622:                b_and  135  133          // tmp135 = tmp133 & tmp134;
1623:           assignment  136    1          // tmp136 = 12: SMALLINT;
1624:         b_shift_left  137  135          // tmp137 = tmp135 << tmp136;
1625:           assignment  138    5          // tmp138 = 'charCodeAt': STRING;
1626:          prop_getter  139    3          // tmp139 = c[tmp138];
1627:           assignment  140    6          // tmp140 = c : TYPEOF(c);
1628:               call_n  141  139          // 
1629:                 meta    1    1          // 
1630:           assignment  141    1          // tmp141 = 1: SMALLINT;
1631:                 meta    2  141          // tmp141 = tmp139 (this_arg = tmp140, tmp141);
1632:           assignment  142    1          // tmp142 = 63: SMALLINT;
1633:           assignment  143    1          // tmp143 = 6: SMALLINT;
1634:         b_shift_left  144  142          // tmp144 = tmp142 << tmp143;
1635:                b_and  145  141          // tmp145 = tmp141 & tmp144;
1636:                 b_or  146  137          // tmp146 = tmp137 | tmp145;
1637:           assignment  147    5          // tmp147 = 'charCodeAt': STRING;
1638:          prop_getter  148    3          // tmp148 = c[tmp147];
1639:           assignment  149    6          // tmp149 = c : TYPEOF(c);
1640:               call_n  150  148          // 
1641:                 meta    1    1          // 
1642:           assignment  150    1          // tmp150 = 2: SMALLINT;
1643:                 meta    2  150          // tmp150 = tmp148 (this_arg = tmp149, tmp150);
1644:           assignment  151    1          // tmp151 = 63: SMALLINT;
1645:                b_and  152  150          // tmp152 = tmp150 & tmp151;
1646:                 b_or  153  146          // tmp153 = tmp146 | tmp152;
1647:           assignment    4    6          // cc = tmp153 : TYPEOF(tmp153);
1648:           assignment  130    5          // tmp130 = 'fromCharCode': STRING;
1649:          prop_getter  131    7          // tmp131 = String[tmp130];
1650:           assignment  132    6          // tmp132 = String : TYPEOF(String);
1651:               call_n  133  131          // 
1652:                 meta    1    1          // 
1653:                 meta    2    4          // tmp133 = tmp131 (this_arg = tmp132, cc);
1654:               retval                    // return tmp133;
1655:                  ret                    // ret;
1656:                 meta    2  133          // 
1657:           assignment    0    6          // str = tmp133 : TYPEOF(tmp133);
1658:               retval                    // return str;
1659:                  ret                    // ret;
1660:          func_decl_n    8               // 
1661:                 meta    2    9          // function byteArrayToHexStr (b);
1662:                 meta    7    0          // function end: 1691;
1663:                 meta   12    6          // [no 'arguments'] [no 'eval'] 
1664:         reg_var_decl  128               // var tmp128 .. tmp141;
1665:             var_decl                    // var s;
1666:             var_decl                    // var i;
1667:           assignment  130    5          // tmp130 = '': STRING;
1668:           assignment    0    6          // s = tmp130 : TYPEOF(tmp130);
1669:           assignment  130    1          // tmp130 = 0: SMALLINT;
1670:           assignment    1    6          // i = tmp130 : TYPEOF(tmp130);
1671:             jmp_down    0               // goto 1684;
1672:          prop_getter  130    3          // tmp130 = b[i];
1673:           assignment  131    5          // tmp131 = 'toString': STRING;
1674:          prop_getter  132  130          // tmp132 = tmp130[tmp131];
1675:               call_n  133  132          // 
1676:                 meta    1    1          // 
1677:           assignment  133    1          // tmp133 = 16: SMALLINT;
1678:                 meta    2  133          // tmp133 = tmp132 (this_arg = tmp130, tmp133);
1679:           assignment  134    5          // tmp134 = ' ': STRING;
1680:             addition  135  133          // tmp135 = tmp133 + tmp134;
1681:             addition    0    0          // s = s + tmp135;
1682:           assignment  136    6          // tmp136 = s : TYPEOF(s);
1683:            post_incr  137               // tmp137 = i++;
1684:           assignment  138    6          // tmp138 = i : TYPEOF(i);
1685:           assignment  139    5          // tmp139 = 'length': STRING;
1686:          prop_getter  140    3          // tmp140 = b[tmp139];
1687:            less_than  141  138          // tmp141 = tmp138 < tmp140;
1688:       is_true_jmp_up  141    0          // if (tmp141) goto 1672;
1689:               retval                    // return s;
1690:                  ret                    // ret;
1691:           array_decl  130               // tmp130 = [];
1692:           assignment  130    1          // tmp130 = 99: SMALLINT;
1693:                 meta    2  130          // 
1694:           assignment  130    1          // tmp130 = 124: SMALLINT;
1695:                 meta    2  130          // 
1696:           assignment  130    1          // tmp130 = 119: SMALLINT;
1697:                 meta    2  130          // 
1698:           assignment  130    1          // tmp130 = 123: SMALLINT;
1699:                 meta    2  130          // 
1700:           assignment  130    1          // tmp130 = 242: SMALLINT;
1701:                 meta    2  130          // 
1702:           assignment  130    1          // tmp130 = 107: SMALLINT;
1703:                 meta    2  130          // 
1704:           assignment  130    1          // tmp130 = 111: SMALLINT;
1705:                 meta    2  130          // 
1706:           assignment  130    1          // tmp130 = 197: SMALLINT;
1707:                 meta    2  130          // 
1708:           assignment  130    1          // tmp130 = 48: SMALLINT;
1709:                 meta    2  130          // 
1710:           assignment  130    1          // tmp130 = 1: SMALLINT;
1711:                 meta    2  130          // 
1712:           assignment  130    1          // tmp130 = 103: SMALLINT;
1713:                 meta    2  130          // 
1714:           assignment  130    1          // tmp130 = 43: SMALLINT;
1715:                 meta    2  130          // 
1716:           assignment  130    1          // tmp130 = 254: SMALLINT;
1717:                 meta    2  130          // 
1718:           assignment  130    1          // tmp130 = 215: SMALLINT;
1719:                 meta    2  130          // 
1720:           assignment  130    1          // tmp130 = 171: SMALLINT;
1721:                 meta    2  130          // 
1722:           assignment  130    1          // tmp130 = 118: SMALLINT;
1723:                 meta    2  130          // 
1724:           assignment  130    1          // tmp130 = 202: SMALLINT;
1725:                 meta    2  130          // 
1726:           assignment  130    1          // tmp130 = 130: SMALLINT;
1727:                 meta    2  130          // 
1728:           assignment  130    1          // tmp130 = 201: SMALLINT;
1729:                 meta    2  130          // 
1730:           assignment  130    1          // tmp130 = 125: SMALLINT;
1731:                 meta    2  130          // 
1732:           assignment  130    1          // tmp130 = 250: SMALLINT;
1733:                 meta    2  130          // 
1734:           assignment  130    1          // tmp130 = 89: SMALLINT;
1735:                 meta    2  130          // 
1736:           assignment  130    1          // tmp130 = 71: SMALLINT;
1737:                 meta    2  130          // 
1738:           assignment  130    1          // tmp130 = 240: SMALLINT;
1739:                 meta    2  130          // 
1740:           assignment  130    1          // tmp130 = 173: SMALLINT;
1741:                 meta    2  130          // 
1742:           assignment  130    1          // tmp130 = 212: SMALLINT;
1743:                 meta    2  130          // 
1744:           assignment  130    1          // tmp130 = 162: SMALLINT;
1745:                 meta    2  130          // 
1746:           assignment  130    1          // tmp130 = 175: SMALLINT;
1747:                 meta    2  130          // 
1748:           assignment  130    1          // tmp130 = 156: SMALLINT;
1749:                 meta    2  130          // 
1750:           assignment  130    1          // tmp130 = 164: SMALLINT;
1751:                 meta    2  130          // 
1752:           assignment  130    1          // tmp130 = 114: SMALLINT;
1753:                 meta    2  130          // 
1754:           assignment  130    1          // tmp130 = 192: SMALLINT;
1755:                 meta    2  130          // 
1756:           assignment  130    1          // tmp130 = 183: SMALLINT;
1757:                 meta    2  130          // 
1758:           assignment  130    1          // tmp130 = 253: SMALLINT;
1759:                 meta    2  130          // 
1760:           assignment  130    1          // tmp130 = 147: SMALLINT;
1761:                 meta    2  130          // 
1762:           assignment  130    1          // tmp130 = 38: SMALLINT;
1763:                 meta    2  130          // 
1764:           assignment  130    1          // tmp130 = 54: SMALLINT;
1765:                 meta    2  130          // 
1766:           assignment  130    1          // tmp130 = 63: SMALLINT;
1767:                 meta    2  130          // 
1768:           assignment  130    1          // tmp130 = 247: SMALLINT;
1769:                 meta    2  130          // 
1770:           assignment  130    1          // tmp130 = 204: SMALLINT;
1771:                 meta    2  130          // 
1772:           assignment  130    1          // tmp130 = 52: SMALLINT;
1773:                 meta    2  130          // 
1774:           assignment  130    1          // tmp130 = 165: SMALLINT;
1775:                 meta    2  130          // 
1776:           assignment  130    1          // tmp130 = 229: SMALLINT;
1777:                 meta    2  130          // 
1778:           assignment  130    1          // tmp130 = 241: SMALLINT;
1779:                 meta    2  130          // 
1780:           assignment  130    1          // tmp130 = 113: SMALLINT;
1781:                 meta    2  130          // 
1782:           assignment  130    1          // tmp130 = 216: SMALLINT;
1783:                 meta    2  130          // 
1784:           assignment  130    1          // tmp130 = 49: SMALLINT;
1785:                 meta    2  130          // 
1786:           assignment  130    1          // tmp130 = 21: SMALLINT;
1787:                 meta    2  130          // 
1788:           assignment  130    1          // tmp130 = 4: SMALLINT;
1789:                 meta    2  130          // 
1790:           assignment  130    1          // tmp130 = 199: SMALLINT;
1791:                 meta    2  130          // 
1792:           assignment  130    1          // tmp130 = 35: SMALLINT;
1793:                 meta    2  130          // 
1794:           assignment  130    1          // tmp130 = 195: SMALLINT;
1795:                 meta    2  130          // 
1796:           assignment  130    1          // tmp130 = 24: SMALLINT;
1797:                 meta    2  130          // 
1798:           assignment  130    1          // tmp130 = 150: SMALLINT;
1799:                 meta    2  130          // 
1800:           assignment  130    1          // tmp130 = 5: SMALLINT;
1801:                 meta    2  130          // 
1802:           assignment  130    1          // tmp130 = 154: SMALLINT;
1803:                 meta    2  130          // 
1804:           assignment  130    1          // tmp130 = 7: SMALLINT;
1805:                 meta    2  130          // 
1806:           assignment  130    1          // tmp130 = 18: SMALLINT;
1807:                 meta    2  130          // 
1808:           assignment  130    1          // tmp130 = 128: SMALLINT;
1809:                 meta    2  130          // 
1810:           assignment  130    1          // tmp130 = 226: SMALLINT;
1811:                 meta    2  130          // 
1812:           assignment  130    1          // tmp130 = 235: SMALLINT;
1813:                 meta    2  130          // 
1814:           assignment  130    1          // tmp130 = 39: SMALLINT;
1815:                 meta    2  130          // 
1816:           assignment  130    1          // tmp130 = 178: SMALLINT;
1817:                 meta    2  130          // 
1818:           assignment  130    1          // tmp130 = 117: SMALLINT;
1819:                 meta    2  130          // 
1820:           assignment  130    1          // tmp130 = 9: SMALLINT;
1821:                 meta    2  130          // 
1822:           assignment  130    1          // tmp130 = 131: SMALLINT;
1823:                 meta    2  130          // 
1824:           assignment  130    1          // tmp130 = 44: SMALLINT;
1825:                 meta    2  130          // 
1826:           assignment  130    1          // tmp130 = 26: SMALLINT;
1827:                 meta    2  130          // 
1828:           assignment  130    1          // tmp130 = 27: SMALLINT;
1829:                 meta    2  130          // 
1830:           assignment  130    1          // tmp130 = 110: SMALLINT;
1831:                 meta    2  130          // 
1832:           assignment  130    1          // tmp130 = 90: SMALLINT;
1833:                 meta    2  130          // 
1834:           assignment  130    1          // tmp130 = 160: SMALLINT;
1835:                 meta    2  130          // 
1836:           assignment  130    1          // tmp130 = 82: SMALLINT;
1837:                 meta    2  130          // 
1838:           assignment  130    1          // tmp130 = 59: SMALLINT;
1839:                 meta    2  130          // 
1840:           assignment  130    1          // tmp130 = 214: SMALLINT;
1841:                 meta    2  130          // 
1842:           assignment  130    1          // tmp130 = 179: SMALLINT;
1843:                 meta    2  130          // 
1844:           assignment  130    1          // tmp130 = 41: SMALLINT;
1845:                 meta    2  130          // 
1846:           assignment  130    1          // tmp130 = 227: SMALLINT;
1847:                 meta    2  130          // 
1848:           assignment  130    1          // tmp130 = 47: SMALLINT;
1849:                 meta    2  130          // 
1850:           assignment  130    1          // tmp130 = 132: SMALLINT;
1851:                 meta    2  130          // 
1852:           assignment  130    1          // tmp130 = 83: SMALLINT;
1853:                 meta    2  130          // 
1854:           assignment  130    1          // tmp130 = 209: SMALLINT;
1855:                 meta    2  130          // 
1856:           assignment  130    1          // tmp130 = 0: SMALLINT;
1857:                 meta    2  130          // 
1858:           assignment  130    1          // tmp130 = 237: SMALLINT;
1859:                 meta    2  130          // 
1860:           assignment  130    1          // tmp130 = 32: SMALLINT;
1861:                 meta    2  130          // 
1862:           assignment  130    1          // tmp130 = 252: SMALLINT;
1863:                 meta    2  130          // 
1864:           assignment  130    1          // tmp130 = 177: SMALLINT;
1865:                 meta    2  130          // 
1866:           assignment  130    1          // tmp130 = 91: SMALLINT;
1867:                 meta    2  130          // 
1868:           assignment  130    1          // tmp130 = 106: SMALLINT;
1869:                 meta    2  130          // 
1870:           assignment  130    1          // tmp130 = 203: SMALLINT;
1871:                 meta    2  130          // 
1872:           assignment  130    1          // tmp130 = 190: SMALLINT;
1873:                 meta    2  130          // 
1874:           assignment  130    1          // tmp130 = 57: SMALLINT;
1875:                 meta    2  130          // 
1876:           assignment  130    1          // tmp130 = 74: SMALLINT;
1877:                 meta    2  130          // 
1878:           assignment  130    1          // tmp130 = 76: SMALLINT;
1879:                 meta    2  130          // 
1880:           assignment  130    1          // tmp130 = 88: SMALLINT;
1881:                 meta    2  130          // 
1882:           assignment  130    1          // tmp130 = 207: SMALLINT;
1883:                 meta    2  130          // 
1884:           assignment  130    1          // tmp130 = 208: SMALLINT;
1885:                 meta    2  130          // 
1886:           assignment  130    1          // tmp130 = 239: SMALLINT;
1887:                 meta    2  130          // 
1888:           assignment  130    1          // tmp130 = 170: SMALLINT;
1889:                 meta    2  130          // 
1890:           assignment  130    1          // tmp130 = 251: SMALLINT;
1891:                 meta    2  130          // 
1892:           assignment  130    1          // tmp130 = 67: SMALLINT;
1893:                 meta    2  130          // 
1894:           assignment  130    1          // tmp130 = 77: SMALLINT;
1895:                 meta    2  130          // 
1896:           assignment  130    1          // tmp130 = 51: SMALLINT;
1897:                 meta    2  130          // 
1898:           assignment  130    1          // tmp130 = 133: SMALLINT;
1899:                 meta    2  130          // 
1900:           assignment  130    1          // tmp130 = 69: SMALLINT;
1901:                 meta    2  130          // 
1902:           assignment  130    1          // tmp130 = 249: SMALLINT;
1903:                 meta    2  130          // 
1904:           assignment  130    1          // tmp130 = 2: SMALLINT;
1905:                 meta    2  130          // 
1906:           assignment  130    1          // tmp130 = 127: SMALLINT;
1907:                 meta    2  130          // 
1908:           assignment  130    1          // tmp130 = 80: SMALLINT;
1909:                 meta    2  130          // 
1910:           assignment  130    1          // tmp130 = 60: SMALLINT;
1911:                 meta    2  130          // 
1912:           assignment  130    1          // tmp130 = 159: SMALLINT;
1913:                 meta    2  130          // 
1914:           assignment  130    1          // tmp130 = 168: SMALLINT;
1915:                 meta    2  130          // 
1916:           assignment  130    1          // tmp130 = 81: SMALLINT;
1917:                 meta    2  130          // 
1918:           assignment  130    1          // tmp130 = 163: SMALLINT;
1919:                 meta    2  130          // 
1920:           assignment  130    1          // tmp130 = 64: SMALLINT;
1921:                 meta    2  130          // 
1922:           assignment  130    1          // tmp130 = 143: SMALLINT;
1923:                 meta    2  130          // 
1924:           assignment  130    1          // tmp130 = 146: SMALLINT;
1925:                 meta    2  130          // 
1926:           assignment  130    1          // tmp130 = 157: SMALLINT;
1927:                 meta    2  130          // 
1928:           assignment  130    1          // tmp130 = 56: SMALLINT;
1929:                 meta    2  130          // 
1930:           assignment  130    1          // tmp130 = 245: SMALLINT;
1931:                 meta    2  130          // 
1932:           assignment  130    1          // tmp130 = 188: SMALLINT;
1933:                 meta    2  130          // 
1934:           assignment  130    1          // tmp130 = 182: SMALLINT;
1935:                 meta    2  130          // 
1936:           assignment  130    1          // tmp130 = 218: SMALLINT;
1937:                 meta    2  130          // 
1938:           assignment  130    1          // tmp130 = 33: SMALLINT;
1939:                 meta    2  130          // 
1940:           assignment  130    1          // tmp130 = 16: SMALLINT;
1941:                 meta    2  130          // 
1942:           assignment  130    1          // tmp130 = 255: SMALLINT;
1943:                 meta    2  130          // 
1944:           assignment  130    1          // tmp130 = 243: SMALLINT;
1945:                 meta    2  130          // 
1946:           assignment  130    1          // tmp130 = 210: SMALLINT;
1947:                 meta    2  130          // 
1948:           assignment  130    1          // tmp130 = 205: SMALLINT;
1949:                 meta    2  130          // 
1950:           assignment  130    1          // tmp130 = 12: SMALLINT;
1951:                 meta    2  130          // 
1952:           assignment  130    1          // tmp130 = 19: SMALLINT;
1953:                 meta    2  130          // 
1954:           assignment  130    1          // tmp130 = 236: SMALLINT;
1955:                 meta    2  130          // 
1956:           assignment  130    1          // tmp130 = 95: SMALLINT;
1957:                 meta    2  130          // 
1958:           assignment  130    1          // tmp130 = 151: SMALLINT;
1959:                 meta    2  130          // 
1960:           assignment  130    1          // tmp130 = 68: SMALLINT;
1961:                 meta    2  130          // 
1962:           assignment  130    1          // tmp130 = 23: SMALLINT;
1963:                 meta    2  130          // 
1964:           assignment  130    1          // tmp130 = 196: SMALLINT;
1965:                 meta    2  130          // 
1966:           assignment  130    1          // tmp130 = 167: SMALLINT;
1967:                 meta    2  130          // 
1968:           assignment  130    1          // tmp130 = 126: SMALLINT;
1969:                 meta    2  130          // 
1970:           assignment  130    1          // tmp130 = 61: SMALLINT;
1971:                 meta    2  130          // 
1972:           assignment  130    1          // tmp130 = 100: SMALLINT;
1973:                 meta    2  130          // 
1974:           assignment  130    1          // tmp130 = 93: SMALLINT;
1975:                 meta    2  130          // 
1976:           assignment  130    1          // tmp130 = 25: SMALLINT;
1977:                 meta    2  130          // 
1978:           assignment  130    1          // tmp130 = 115: SMALLINT;
1979:                 meta    2  130          // 
1980:           assignment  130    1          // tmp130 = 96: SMALLINT;
1981:                 meta    2  130          // 
1982:           assignment  130    1          // tmp130 = 129: SMALLINT;
1983:                 meta    2  130          // 
1984:           assignment  130    1          // tmp130 = 79: SMALLINT;
1985:                 meta    2  130          // 
1986:           assignment  130    1          // tmp130 = 220: SMALLINT;
1987:                 meta    2  130          // 
1988:           assignment  130    1          // tmp130 = 34: SMALLINT;
1989:                 meta    2  130          // 
1990:           assignment  130    1          // tmp130 = 42: SMALLINT;
1991:                 meta    2  130          // 
1992:           assignment  130    1          // tmp130 = 144: SMALLINT;
1993:                 meta    2  130          // 
1994:           assignment  130    1          // tmp130 = 136: SMALLINT;
1995:                 meta    2  130          // 
1996:           assignment  130    1          // tmp130 = 70: SMALLINT;
1997:                 meta    2  130          // 
1998:           assignment  130    1          // tmp130 = 238: SMALLINT;
1999:                 meta    2  130          // 
2000:           assignment  130    1          // tmp130 = 184: SMALLINT;
2001:                 meta    2  130          // 
2002:           assignment  130    1          // tmp130 = 20: SMALLINT;
2003:                 meta    2  130          // 
2004:           assignment  130    1          // tmp130 = 222: SMALLINT;
2005:                 meta    2  130          // 
2006:           assignment  130    1          // tmp130 = 94: SMALLINT;
2007:                 meta    2  130          // 
2008:           assignment  130    1          // tmp130 = 11: SMALLINT;
2009:                 meta    2  130          // 
2010:           assignment  130    1          // tmp130 = 219: SMALLINT;
2011:                 meta    2  130          // 
2012:           assignment  130    1          // tmp130 = 224: SMALLINT;
2013:                 meta    2  130          // 
2014:           assignment  130    1          // tmp130 = 50: SMALLINT;
2015:                 meta    2  130          // 
2016:           assignment  130    1          // tmp130 = 58: SMALLINT;
2017:                 meta    2  130          // 
2018:           assignment  130    1          // tmp130 = 10: SMALLINT;
2019:                 meta    2  130          // 
2020:           assignment  130    1          // tmp130 = 73: SMALLINT;
2021:                 meta    2  130          // 
2022:           assignment  130    1          // tmp130 = 6: SMALLINT;
2023:                 meta    2  130          // 
2024:           assignment  130    1          // tmp130 = 36: SMALLINT;
2025:                 meta    2  130          // 
2026:           assignment  130    1          // tmp130 = 92: SMALLINT;
2027:                 meta    2  130          // 
2028:           assignment  130    1          // tmp130 = 194: SMALLINT;
2029:                 meta    2  130          // 
2030:           assignment  130    1          // tmp130 = 211: SMALLINT;
2031:                 meta    2  130          // 
2032:           assignment  130    1          // tmp130 = 172: SMALLINT;
2033:                 meta    2  130          // 
2034:           assignment  130    1          // tmp130 = 98: SMALLINT;
2035:                 meta    2  130          // 
2036:           assignment  130    1          // tmp130 = 145: SMALLINT;
2037:                 meta    2  130          // 
2038:           assignment  130    1          // tmp130 = 149: SMALLINT;
2039:                 meta    2  130          // 
2040:           assignment  130    1          // tmp130 = 228: SMALLINT;
2041:                 meta    2  130          // 
2042:           assignment  130    1          // tmp130 = 121: SMALLINT;
2043:                 meta    2  130          // 
2044:           assignment  130    1          // tmp130 = 231: SMALLINT;
2045:                 meta    2  130          // 
2046:           assignment  130    1          // tmp130 = 200: SMALLINT;
2047:                 meta    2  130          // 
2048:           assignment  130    1          // tmp130 = 55: SMALLINT;
2049:                 meta    2  130          // 
2050:           assignment  130    1          // tmp130 = 109: SMALLINT;
2051:                 meta    2  130          // 
2052:           assignment  130    1          // tmp130 = 141: SMALLINT;
2053:                 meta    2  130          // 
2054:           assignment  130    1          // tmp130 = 213: SMALLINT;
2055:                 meta    2  130          // 
2056:           assignment  130    1          // tmp130 = 78: SMALLINT;
2057:                 meta    2  130          // 
2058:           assignment  130    1          // tmp130 = 169: SMALLINT;
2059:                 meta    2  130          // 
2060:           assignment  130    1          // tmp130 = 108: SMALLINT;
2061:                 meta    2  130          // 
2062:           assignment  130    1          // tmp130 = 86: SMALLINT;
2063:                 meta    2  130          // 
2064:           assignment  130    1          // tmp130 = 244: SMALLINT;
2065:                 meta    2  130          // 
2066:           assignment  130    1          // tmp130 = 234: SMALLINT;
2067:                 meta    2  130          // 
2068:           assignment  130    1          // tmp130 = 101: SMALLINT;
2069:                 meta    2  130          // 
2070:           assignment  130    1          // tmp130 = 122: SMALLINT;
2071:                 meta    2  130          // 
2072:           assignment  130    1          // tmp130 = 174: SMALLINT;
2073:                 meta    2  130          // 
2074:           assignment  130    1          // tmp130 = 8: SMALLINT;
2075:                 meta    2  130          // 
2076:           assignment  130    1          // tmp130 = 186: SMALLINT;
2077:                 meta    2  130          // 
2078:           assignment  130    1          // tmp130 = 120: SMALLINT;
2079:                 meta    2  130          // 
2080:           assignment  130    1          // tmp130 = 37: SMALLINT;
2081:                 meta    2  130          // 
2082:           assignment  130    1          // tmp130 = 46: SMALLINT;
2083:                 meta    2  130          // 
2084:           assignment  130    1          // tmp130 = 28: SMALLINT;
2085:                 meta    2  130          // 
2086:           assignment  130    1          // tmp130 = 166: SMALLINT;
2087:                 meta    2  130          // 
2088:           assignment  130    1          // tmp130 = 180: SMALLINT;
2089:                 meta    2  130          // 
2090:           assignment  130    1          // tmp130 = 198: SMALLINT;
2091:                 meta    2  130          // 
2092:           assignment  130    1          // tmp130 = 232: SMALLINT;
2093:                 meta    2  130          // 
2094:           assignment  130    1          // tmp130 = 221: SMALLINT;
2095:                 meta    2  130          // 
2096:           assignment  130    1          // tmp130 = 116: SMALLINT;
2097:                 meta    2  130          // 
2098:           assignment  130    1          // tmp130 = 31: SMALLINT;
2099:                 meta    2  130          // 
2100:           assignment  130    1          // tmp130 = 75: SMALLINT;
2101:                 meta    2  130          // 
2102:           assignment  130    1          // tmp130 = 189: SMALLINT;
2103:                 meta    2  130          // 
2104:           assignment  130    1          // tmp130 = 139: SMALLINT;
2105:                 meta    2  130          // 
2106:           assignment  130    1          // tmp130 = 138: SMALLINT;
2107:                 meta    2  130          // 
2108:           assignment  130    1          // tmp130 = 112: SMALLINT;
2109:                 meta    2  130          // 
2110:           assignment  130    1          // tmp130 = 62: SMALLINT;
2111:                 meta    2  130          // 
2112:           assignment  130    1          // tmp130 = 181: SMALLINT;
2113:                 meta    2  130          // 
2114:           assignment  130    1          // tmp130 = 102: SMALLINT;
2115:                 meta    2  130          // 
2116:           assignment  130    1          // tmp130 = 72: SMALLINT;
2117:                 meta    2  130          // 
2118:           assignment  130    1          // tmp130 = 3: SMALLINT;
2119:                 meta    2  130          // 
2120:           assignment  130    1          // tmp130 = 246: SMALLINT;
2121:                 meta    2  130          // 
2122:           assignment  130    1          // tmp130 = 14: SMALLINT;
2123:                 meta    2  130          // 
2124:           assignment  130    1          // tmp130 = 97: SMALLINT;
2125:                 meta    2  130          // 
2126:           assignment  130    1          // tmp130 = 53: SMALLINT;
2127:                 meta    2  130          // 
2128:           assignment  130    1          // tmp130 = 87: SMALLINT;
2129:                 meta    2  130          // 
2130:           assignment  130    1          // tmp130 = 185: SMALLINT;
2131:                 meta    2  130          // 
2132:           assignment  130    1          // tmp130 = 134: SMALLINT;
2133:                 meta    2  130          // 
2134:           assignment  130    1          // tmp130 = 193: SMALLINT;
2135:                 meta    2  130          // 
2136:           assignment  130    1          // tmp130 = 29: SMALLINT;
2137:                 meta    2  130          // 
2138:           assignment  130    1          // tmp130 = 158: SMALLINT;
2139:                 meta    2  130          // 
2140:           assignment  130    1          // tmp130 = 225: SMALLINT;
2141:                 meta    2  130          // 
2142:           assignment  130    1          // tmp130 = 248: SMALLINT;
2143:                 meta    2  130          // 
2144:           assignment  130    1          // tmp130 = 152: SMALLINT;
2145:                 meta    2  130          // 
2146:           assignment  130    1          // tmp130 = 17: SMALLINT;
2147:                 meta    2  130          // 
2148:           assignment  130    1          // tmp130 = 105: SMALLINT;
2149:                 meta    2  130          // 
2150:           assignment  130    1          // tmp130 = 217: SMALLINT;
2151:                 meta    2  130          // 
2152:           assignment  130    1          // tmp130 = 142: SMALLINT;
2153:                 meta    2  130          // 
2154:           assignment  130    1          // tmp130 = 148: SMALLINT;
2155:                 meta    2  130          // 
2156:           assignment  130    1          // tmp130 = 155: SMALLINT;
2157:                 meta    2  130          // 
2158:           assignment  130    1          // tmp130 = 30: SMALLINT;
2159:                 meta    2  130          // 
2160:           assignment  130    1          // tmp130 = 135: SMALLINT;
2161:                 meta    2  130          // 
2162:           assignment  130    1          // tmp130 = 233: SMALLINT;
2163:                 meta    2  130          // 
2164:           assignment  130    1          // tmp130 = 206: SMALLINT;
2165:                 meta    2  130          // 
2166:           assignment  130    1          // tmp130 = 85: SMALLINT;
2167:                 meta    2  130          // 
2168:           assignment  130    1          // tmp130 = 40: SMALLINT;
2169:                 meta    2  130          // 
2170:           assignment  130    1          // tmp130 = 223: SMALLINT;
2171:                 meta    2  130          // 
2172:           assignment  130    1          // tmp130 = 140: SMALLINT;
2173:                 meta    2  130          // 
2174:           assignment  130    1          // tmp130 = 161: SMALLINT;
2175:                 meta    2  130          // 
2176:           assignment  130    1          // tmp130 = 137: SMALLINT;
2177:                 meta    2  130          // 
2178:           assignment  130    1          // tmp130 = 13: SMALLINT;
2179:                 meta    2  130          // 
2180:           assignment  130    1          // tmp130 = 191: SMALLINT;
2181:                 meta    2  130          // 
2182:           assignment  130    1          // tmp130 = 230: SMALLINT;
2183:                 meta    2  130          // 
2184:           assignment  130    1          // tmp130 = 66: SMALLINT;
2185:                 meta    2  130          // 
2186:           assignment  130    1          // tmp130 = 104: SMALLINT;
2187:                 meta    2  130          // 
2188:           assignment  130    1          // tmp130 = 65: SMALLINT;
2189:                 meta    2  130          // 
2190:           assignment  130    1          // tmp130 = 153: SMALLINT;
2191:                 meta    2  130          // 
2192:           assignment  130    1          // tmp130 = 45: SMALLINT;
2193:                 meta    2  130          // 
2194:           assignment  130    1          // tmp130 = 15: SMALLINT;
2195:                 meta    2  130          // 
2196:           assignment  130    1          // tmp130 = 176: SMALLINT;
2197:                 meta    2  130          // 
2198:           assignment  130    1          // tmp130 = 84: SMALLINT;
2199:                 meta    2  130          // 
2200:           assignment  130    1          // tmp130 = 187: SMALLINT;
2201:                 meta    2  130          // 
2202:           assignment  130    1          // tmp130 = 22: SMALLINT;
2203:                 meta    2  130          // 
2204:           assignment    0    6          // Sbox = tmp130 : TYPEOF(tmp130);
2205:           array_decl  130               // 
2206:           array_decl  130               // 
2207:           assignment  130    1          // tmp130 = 0: SMALLINT;
2208:                 meta    2  130          // 
2209:           assignment  130    1          // tmp130 = 0: SMALLINT;
2210:                 meta    2  130          // 
2211:           assignment  130    1          // tmp130 = 0: SMALLINT;
2212:                 meta    2  130          // 
2213:           assignment  130    1          // tmp130 = 0: SMALLINT;
2214:                 meta    2  130          // tmp130 = [tmp130, tmp130, tmp130, tmp130];
2215:                 meta    2  130          // 
2216:           array_decl  130               // 
2217:           assignment  130    1          // tmp130 = 1: SMALLINT;
2218:                 meta    2  130          // 
2219:           assignment  130    1          // tmp130 = 0: SMALLINT;
2220:                 meta    2  130          // 
2221:           assignment  130    1          // tmp130 = 0: SMALLINT;
2222:                 meta    2  130          // 
2223:           assignment  130    1          // tmp130 = 0: SMALLINT;
2224:                 meta    2  130          // tmp130 = [tmp130, tmp130, tmp130, tmp130];
2225:                 meta    2  130          // 
2226:           array_decl  130               // 
2227:           assignment  130    1          // tmp130 = 2: SMALLINT;
2228:                 meta    2  130          // 
2229:           assignment  130    1          // tmp130 = 0: SMALLINT;
2230:                 meta    2  130          // 
2231:           assignment  130    1          // tmp130 = 0: SMALLINT;
2232:                 meta    2  130          // 
2233:           assignment  130    1          // tmp130 = 0: SMALLINT;
2234:                 meta    2  130          // tmp130 = [tmp130, tmp130, tmp130, tmp130];
2235:                 meta    2  130          // 
2236:           array_decl  130               // 
2237:           assignment  130    1          // tmp130 = 4: SMALLINT;
2238:                 meta    2  130          // 
2239:           assignment  130    1          // tmp130 = 0: SMALLINT;
2240:                 meta    2  130          // 
2241:           assignment  130    1          // tmp130 = 0: SMALLINT;
2242:                 meta    2  130          // 
2243:           assignment  130    1          // tmp130 = 0: SMALLINT;
2244:                 meta    2  130          // tmp130 = [tmp130, tmp130, tmp130, tmp130];
2245:                 meta    2  130          // 
2246:           array_decl  130               // 
2247:           assignment  130    1          // tmp130 = 8: SMALLINT;
2248:                 meta    2  130          // 
2249:           assignment  130    1          // tmp130 = 0: SMALLINT;
2250:                 meta    2  130          // 
2251:           assignment  130    1          // tmp130 = 0: SMALLINT;
2252:                 meta    2  130          // 
2253:           assignment  130    1          // tmp130 = 0: SMALLINT;
2254:                 meta    2  130          // tmp130 = [tmp130, tmp130, tmp130, tmp130];
2255:                 meta    2  130          // 
2256:           array_decl  130               // 
2257:           assignment  130    1          // tmp130 = 16: SMALLINT;
2258:                 meta    2  130          // 
2259:           assignment  130    1          // tmp130 = 0: SMALLINT;
2260:                 meta    2  130          // 
2261:           assignment  130    1          // tmp130 = 0: SMALLINT;
2262:                 meta    2  130          // 
2263:           assignment  130    1          // tmp130 = 0: SMALLINT;
2264:                 meta    2  130          // tmp130 = [tmp130, tmp130, tmp130, tmp130];
2265:                 meta    2  130          // 
2266:           array_decl  130               // 
2267:           assignment  130    1          // tmp130 = 32: SMALLINT;
2268:                 meta    2  130          // 
2269:           assignment  130    1          // tmp130 = 0: SMALLINT;
2270:                 meta    2  130          // 
2271:           assignment  130    1          // tmp130 = 0: SMALLINT;
2272:                 meta    2  130          // 
2273:           assignment  130    1          // tmp130 = 0: SMALLINT;
2274:                 meta    2  130          // tmp130 = [tmp130, tmp130, tmp130, tmp130];
2275:                 meta    2  130          // 
2276:           array_decl  130               // 
2277:           assignment  130    1          // tmp130 = 64: SMALLINT;
2278:                 meta    2  130          // 
2279:           assignment  130    1          // tmp130 = 0: SMALLINT;
2280:                 meta    2  130          // 
2281:           assignment  130    1          // tmp130 = 0: SMALLINT;
2282:                 meta    2  130          // 
2283:           assignment  130    1          // tmp130 = 0: SMALLINT;
2284:                 meta    2  130          // tmp130 = [tmp130, tmp130, tmp130, tmp130];
2285:                 meta    2  130          // 
2286:           array_decl  130               // 
2287:           assignment  130    1          // tmp130 = 128: SMALLINT;
2288:                 meta    2  130          // 
2289:           assignment  130    1          // tmp130 = 0: SMALLINT;
2290:                 meta    2  130          // 
2291:           assignment  130    1          // tmp130 = 0: SMALLINT;
2292:                 meta    2  130          // 
2293:           assignment  130    1          // tmp130 = 0: SMALLINT;
2294:                 meta    2  130          // tmp130 = [tmp130, tmp130, tmp130, tmp130];
2295:                 meta    2  130          // 
2296:           array_decl  130               // 
2297:           assignment  130    1          // tmp130 = 27: SMALLINT;
2298:                 meta    2  130          // 
2299:           assignment  130    1          // tmp130 = 0: SMALLINT;
2300:                 meta    2  130          // 
2301:           assignment  130    1          // tmp130 = 0: SMALLINT;
2302:                 meta    2  130          // 
2303:           assignment  130    1          // tmp130 = 0: SMALLINT;
2304:                 meta    2  130          // tmp130 = [tmp130, tmp130, tmp130, tmp130];
2305:                 meta    2  130          // 
2306:           array_decl  130               // 
2307:           assignment  130    1          // tmp130 = 54: SMALLINT;
2308:                 meta    2  130          // 
2309:           assignment  130    1          // tmp130 = 0: SMALLINT;
2310:                 meta    2  130          // 
2311:           assignment  130    1          // tmp130 = 0: SMALLINT;
2312:                 meta    2  130          // 
2313:           assignment  130    1          // tmp130 = 0: SMALLINT;
2314:                 meta    2  130          // tmp130 = [tmp130, tmp130, tmp130, tmp130];
2315:                 meta    2  130          // 
2316:           assignment    0    6          // Rcon = tmp130 : TYPEOF(tmp130);
2317:           assignment  130    5          // tmp130 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/': STRING;
2318:           assignment    2    6          // b64 = tmp130 : TYPEOF(tmp130);
2319:           assignment  130    5          // tmp130 = 'ROMEO: But, soft! what light through yonder window breaks?
It is': STRING;
2320:           assignment    4    6          // plainText = tmp130 : TYPEOF(tmp130);
2321:           assignment  130    5          // tmp130 = 'O Romeo, Romeo! wherefore art thou Romeo?': STRING;
2322:           assignment    6    6          // password = tmp130 : TYPEOF(tmp130);
2323:               call_n  130    7          // 
2324:                 meta    2    4          // 
2325:                 meta    2    6          // 
2326:           assignment  130    3          // tmp130 = 256: NUMBER;
2327:                 meta    2  130          // tmp130 = AESEncryptCtr (plainText, password, tmp130);
2328:           assignment    9    6          // cipherText = tmp130 : TYPEOF(tmp130);
2329:               call_n  130   10          // 
2330:                 meta    2    9          // 
2331:                 meta    2    6          // 
2332:           assignment  130    3          // tmp130 = 256: NUMBER;
2333:                 meta    2  130          // tmp130 = AESDecryptCtr (cipherText, password, tmp130);
2334:           assignment   11    6          // decryptedText = tmp130 : TYPEOF(tmp130);
2335:           assignment  130    6          // tmp130 = decryptedText : TYPEOF(decryptedText);
2336:      not_equal_value  131  130          // tmp131 = tmp130 != plainText;
2337:    is_false_jmp_down  131    0          // if (tmp131 == false) goto 2344;
2338:           assignment  130    5          // tmp130 = 'ERROR: bad result: expected ': STRING;
2339:             addition  131  130          // tmp131 = tmp130 + plainText;
2340:           assignment  132    5          // tmp132 = ' but got ': STRING;
2341:             addition  133  131          // tmp133 = tmp131 + tmp132;
2342:             addition  134  133          // tmp134 = tmp133 + decryptedText;
2343:          throw_value                    // throw tmp134;
2344:                  ret                    // ret;
ICE: Assertion 'ecma_is_completion_value_throw (completion) || ecma_is_completion_value_return (completion)' failed at /home/john/git/jerryscript/jerry-core/vm/vm.cpp(vm_run_from_pos):577.
Error: ERR_FAILED_INTERNAL_ASSERTION
