// /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
// /*
// 
// function Cipher(input, w) {    // main Cipher function [_5.1]
  0:                 meta   12  253  255     // [to be rewritten]
  1:         reg_var_decl  128  253  253     // var tmp128 .. tmp253;
  0:          func_decl_n  254  253          // 
  1:                 meta    2  254  255     // 
  2:                 meta    2  254  255     // 
  0:          func_decl_n  254    2          //  // REWRITE
  3:                 meta    7  253  253     // function end: 65024;
// 
//   var Nb = 4;               // block size (in words): no of columns in state (fixed at 4 for AES)
  4:                 meta   12  253  255     // [to be rewritten]
  5:         reg_var_decl  128  253  253     // var tmp128 .. tmp253;
  6:           assignment  130    1    4     // tmp130 = 4: SMALLINT;
  7:           assignment  254    6  130     // Nb = tmp130 : TYPEOF(tmp130);
// 
//   var Nr = w.length/Nb - 1; // no of rounds: 10/12/14 for 128/192/256-bit keys
  8:           assignment  130    5  254     // tmp130 = 'length': STRING;
  9:          prop_getter  131  254  130     // tmp131 = w[tmp130];
 10:             division  132  131  254     // tmp132 = tmp131 / Nb;
 11:           assignment  133    1    1     // tmp133 = 1: SMALLINT;
 12:         substraction  134  132  133     // tmp134 = tmp132 - tmp133;
 13:           assignment  254    6  134     // Nr = tmp134 : TYPEOF(tmp134);
// 
//   var state = [[],[],[],[]];  // initialise 4xNb byte-array 'state' with input [_3.4]
 14:           array_decl  253  253  255     // 
 15:           array_decl  253  253  255     // 
 15:           array_decl  130    0    0     // tmp130 = []; // REWRITE
 16:                 meta    2  130  255     // 
 17:           array_decl  253  253  255     // 
 17:           array_decl  130    0    0     // tmp130 = []; // REWRITE
 18:                 meta    2  130  255     // 
 19:           array_decl  253  253  255     // 
 19:           array_decl  130    0    0     // tmp130 = []; // REWRITE
 20:                 meta    2  130  255     // 
 21:           array_decl  253  253  255     // 
 21:           array_decl  130    0    0     // tmp130 = []; // REWRITE
 22:                 meta    2  130  255     // 
 14:           array_decl  130    0    4     //  // REWRITE
 23:           assignment  254    6  130     // state = tmp130 : TYPEOF(tmp130);
// 
//   for (var i=0; i<4*Nb; i++) state[i%4][Math.floor(i/4)] = input[i];
 24:           assignment  130    1    0     // tmp130 = 0: SMALLINT;
 25:           assignment  254    6  130     // i = tmp130 : TYPEOF(tmp130);
 26:             jmp_down  253  253          // goto 65047;
 27:           assignment  130    6  254     // tmp130 = i : TYPEOF(i);
 28:           assignment  131    1    4     // tmp131 = 4: SMALLINT;
 29:            remainder  132  130  131     // tmp132 = tmp130 %% tmp131;
 30:          prop_getter  133  254  132     // tmp133 = state[tmp132];
 31:           assignment  134    5  254     // tmp134 = 'floor': STRING;
 32:          prop_getter  135  254  134     // tmp135 = Math[tmp134];
 33:           assignment  136    6  254     // tmp136 = Math : TYPEOF(Math);
 34:               call_n  253  135  253     // 
 35:                 meta    1    1  136     // 
 36:           assignment  137    6  254     // tmp137 = i : TYPEOF(i);
 37:           assignment  138    1    4     // tmp138 = 4: SMALLINT;
 38:             division  139  137  138     // tmp139 = tmp137 / tmp138;
 39:                 meta    2  139  255     // 
 34:               call_n  137  135    1     //  // REWRITE
 40:          prop_getter  138  133  137     // tmp138 = tmp133[tmp137];
 40:          prop_getter  139  254  254     // tmp139 = input[i];
 41:          prop_setter  133  137  139     // tmp133[tmp137] = tmp139;
 42:            post_incr  140  254          // tmp140 = i++;
 26:             jmp_down    0   17          // goto 43; // REWRITE
 43:           assignment  141    6  254     // tmp141 = i : TYPEOF(i);
 44:           assignment  142    1    4     // tmp142 = 4: SMALLINT;
 45:       multiplication  143  142  254     // tmp143 = tmp142 * Nb;
 46:            less_than  144  141  143     // tmp144 = tmp141 < tmp143;
 47:       is_true_jmp_up  144    0   20     // if (tmp144) goto 27;
//   state = AddRoundKey(state, w, 0, Nb);
 48:               call_n  253  254  253     // 
 49:                 meta    2  254  255     // 
 50:                 meta    2  254  255     // 
 51:           assignment  130    1    0     // tmp130 = 0: SMALLINT;
 52:                 meta    2  130  255     // 
 53:                 meta    2  254  255     // 
 48:               call_n  130  254    4     //  // REWRITE
 54:           assignment  254    6  130     // state = tmp130 : TYPEOF(tmp130);
//   for (var round=1; round<Nr; round++) {
 55:           assignment  130    1    1     // tmp130 = 1: SMALLINT;
 56:           assignment  254    6  130     // round = tmp130 : TYPEOF(tmp130);
 57:             jmp_down  253  253          // goto 65078;
//     state = SubBytes(state, Nb);
 58:               call_n  253  254  253     // 
 59:                 meta    2  254  255     // 
 60:                 meta    2  254  255     // 
 58:               call_n  130  254    2     //  // REWRITE
 61:           assignment  254    6  130     // state = tmp130 : TYPEOF(tmp130);
//     state = ShiftRows(state, Nb);
 62:               call_n  253  254  253     // 
 63:                 meta    2  254  255     // 
 64:                 meta    2  254  255     // 
 62:               call_n  130  254    2     //  // REWRITE
 65:           assignment  254    6  130     // state = tmp130 : TYPEOF(tmp130);
//     state = MixColumns(state, Nb);
 66:               call_n  253  254  253     // 
 67:                 meta    2  254  255     // 
 68:                 meta    2  254  255     // 
 66:               call_n  130  254    2     //  // REWRITE
 69:           assignment  254    6  130     // state = tmp130 : TYPEOF(tmp130);
//     state = AddRoundKey(state, w, round, Nb);
 70:               call_n  253  254  253     // 
 71:                 meta    2  254  255     // 
 72:                 meta    2  254  255     // 
 73:                 meta    2  254  255     // 
 74:                 meta    2  254  255     // 
 70:               call_n  130  254    4     //  // REWRITE
 75:           assignment  254    6  130     // state = tmp130 : TYPEOF(tmp130);
//   }
 76:            post_incr  131  254          // tmp131 = round++;
 57:             jmp_down    0   20          // goto 77; // REWRITE
 77:           assignment  132    6  254     // tmp132 = round : TYPEOF(round);
 78:            less_than  133  132  254     // tmp133 = tmp132 < Nr;
 79:       is_true_jmp_up  133    0   21     // if (tmp133) goto 58;
//   state = SubBytes(state, Nb);
 80:               call_n  253  254  253     // 
 81:                 meta    2  254  255     // 
 82:                 meta    2  254  255     // 
 80:               call_n  130  254    2     //  // REWRITE
 83:           assignment  254    6  130     // state = tmp130 : TYPEOF(tmp130);
//   state = ShiftRows(state, Nb);
 84:               call_n  253  254  253     // 
 85:                 meta    2  254  255     // 
 86:                 meta    2  254  255     // 
 84:               call_n  130  254    2     //  // REWRITE
 87:           assignment  254    6  130     // state = tmp130 : TYPEOF(tmp130);
//   state = AddRoundKey(state, w, Nr, Nb);
 88:               call_n  253  254  253     // 
 89:                 meta    2  254  255     // 
 90:                 meta    2  254  255     // 
 91:                 meta    2  254  255     // 
 92:                 meta    2  254  255     // 
 88:               call_n  130  254    4     //  // REWRITE
 93:           assignment  254    6  130     // state = tmp130 : TYPEOF(tmp130);
//   var output = new Array(4*Nb);  // convert state to 1-d array before returning [_3.4]
 94:          construct_n  253  254  253     // 
 95:           assignment  130    1    4     // tmp130 = 4: SMALLINT;
 96:       multiplication  131  130  254     // tmp131 = tmp130 * Nb;
 97:                 meta    2  131  255     // 
 94:          construct_n  130  254    1     //  // REWRITE
 98:           assignment  254    6  130     // output = tmp130 : TYPEOF(tmp130);
// 
//   for (var i=0; i<4*Nb; i++) output[i] = state[i%4][Math.floor(i/4)];
 99:           assignment  130    1    0     // tmp130 = 0: SMALLINT;
100:           assignment  254    6  130     // i = tmp130 : TYPEOF(tmp130);
101:             jmp_down  253  253          // goto 65122;
102:          prop_getter  130  254  254     // tmp130 = output[i];
102:           assignment  131    6  254     // tmp131 = i : TYPEOF(i);
103:           assignment  132    1    4     // tmp132 = 4: SMALLINT;
104:            remainder  133  131  132     // tmp133 = tmp131 %% tmp132;
105:          prop_getter  134  254  133     // tmp134 = state[tmp133];
106:           assignment  135    5  254     // tmp135 = 'floor': STRING;
107:          prop_getter  136  254  135     // tmp136 = Math[tmp135];
108:           assignment  137    6  254     // tmp137 = Math : TYPEOF(Math);
109:               call_n  253  136  253     // 
110:                 meta    1    1  137     // 
111:           assignment  138    6  254     // tmp138 = i : TYPEOF(i);
112:           assignment  139    1    4     // tmp139 = 4: SMALLINT;
113:             division  140  138  139     // tmp140 = tmp138 / tmp139;
114:                 meta    2  140  255     // 
109:               call_n  138  136    1     //  // REWRITE
115:          prop_getter  139  134  138     // tmp139 = tmp134[tmp138];
116:          prop_setter  254  254  139     // output[i] = tmp139;
117:            post_incr  140  254          // tmp140 = i++;
101:             jmp_down    0   17          // goto 118; // REWRITE
118:           assignment  141    6  254     // tmp141 = i : TYPEOF(i);
119:           assignment  142    1    4     // tmp142 = 4: SMALLINT;
120:       multiplication  143  142  254     // tmp143 = tmp142 * Nb;
121:            less_than  144  141  143     // tmp144 = tmp141 < tmp143;
122:       is_true_jmp_up  144    0   20     // if (tmp144) goto 102;
//   return output;
123:               retval  254               // return output;
// }
  4:                 meta   12    6  255     // [no 'arguments'] [no 'eval']  // REWRITE
  5:         reg_var_decl  128  150    6     // var tmp128 .. tmp150; // REWRITE
124:                  ret                    // ret;
  3:                 meta    7    0  122     // function end: 125; // REWRITE
// function SubBytes(s, Nb) {    // apply SBox to state S [_5.1.1]
  0:          func_decl_n  254  253          // 
  1:                 meta    2  254  255     // 
  2:                 meta    2  254  255     // 
  0:          func_decl_n  254    2          //  // REWRITE
  3:                 meta    7  253  253     // function end: 65024;
// 
//   for (var r=0; r<4; r++) {
  4:                 meta   12  253  255     // [to be rewritten]
  5:         reg_var_decl  128  253  253     // var tmp128 .. tmp253;
  6:           assignment  130    1    0     // tmp130 = 0: SMALLINT;
  7:           assignment  254    6  130     // r = tmp130 : TYPEOF(tmp130);
  8:             jmp_down  253  253          // goto 65029;
//     for (var c=0; c<Nb; c++) s[r][c] = Sbox[s[r][c]];
  9:           assignment  130    1    0     // tmp130 = 0: SMALLINT;
 10:           assignment  254    6  130     // c = tmp130 : TYPEOF(tmp130);
 11:             jmp_down  253  253          // goto 65032;
 12:          prop_getter  130  254  254     // tmp130 = s[r];
 13:          prop_getter  131  130  254     // tmp131 = tmp130[c];
 13:          prop_getter  132  254  254     // tmp132 = s[r];
 14:          prop_getter  133  132  254     // tmp133 = tmp132[c];
 15:          prop_getter  134  254  133     // tmp134 = Sbox[tmp133];
 16:          prop_setter  130  254  134     // tmp130[c] = tmp134;
 17:            post_incr  135  254          // tmp135 = c++;
 11:             jmp_down    0    7          // goto 18; // REWRITE
 18:           assignment  136    6  254     // tmp136 = c : TYPEOF(c);
 19:            less_than  137  136  254     // tmp137 = tmp136 < Nb;
 20:       is_true_jmp_up  137    0    8     // if (tmp137) goto 12;
//   }
 21:            post_incr  138  254          // tmp138 = r++;
  8:             jmp_down    0   14          // goto 22; // REWRITE
 22:           assignment  139    6  254     // tmp139 = r : TYPEOF(r);
 23:           assignment  140    1    4     // tmp140 = 4: SMALLINT;
 24:            less_than  141  139  140     // tmp141 = tmp139 < tmp140;
 25:       is_true_jmp_up  141    0   16     // if (tmp141) goto 9;
//   return s;
 26:               retval  254               // return s;
// }
  4:                 meta   12    6  255     // [no 'arguments'] [no 'eval']  // REWRITE
  5:         reg_var_decl  128  143    2     // var tmp128 .. tmp143; // REWRITE
 27:                  ret                    // ret;
  3:                 meta    7    0   25     // function end: 28; // REWRITE
// function ShiftRows(s, Nb) {    // shift row r of state S left by r bytes [_5.1.2]
  0:          func_decl_n  254  253          // 
  1:                 meta    2  254  255     // 
  2:                 meta    2  254  255     // 
  0:          func_decl_n  254    2          //  // REWRITE
  3:                 meta    7  253  253     // function end: 65024;
// 
//   var t = new Array(4);
  4:                 meta   12  253  255     // [to be rewritten]
  5:         reg_var_decl  128  253  253     // var tmp128 .. tmp253;
  6:          construct_n  253  254  253     // 
  7:           assignment  130    1    4     // tmp130 = 4: SMALLINT;
  8:                 meta    2  130  255     // 
  6:          construct_n  130  254    1     //  // REWRITE
  9:           assignment  254    6  130     // t = tmp130 : TYPEOF(tmp130);
//   for (var r=1; r<4; r++) {
 10:           assignment  130    1    1     // tmp130 = 1: SMALLINT;
 11:           assignment  254    6  130     // r = tmp130 : TYPEOF(tmp130);
 12:             jmp_down  253  253          // goto 65033;
//     for (var c=0; c<4; c++) t[c] = s[r][(c+r)%Nb];  // shift into temp copy
 13:           assignment  130    1    0     // tmp130 = 0: SMALLINT;
 14:           assignment  254    6  130     // c = tmp130 : TYPEOF(tmp130);
 15:             jmp_down  253  253          // goto 65036;
 16:          prop_getter  130  254  254     // tmp130 = t[c];
 16:          prop_getter  131  254  254     // tmp131 = s[r];
 17:           assignment  132    6  254     // tmp132 = c : TYPEOF(c);
 18:             addition  133  132  254     // tmp133 = tmp132 + r;
 19:            remainder  134  133  254     // tmp134 = tmp133 %% Nb;
 20:          prop_getter  135  131  134     // tmp135 = tmp131[tmp134];
 21:          prop_setter  254  254  135     // t[c] = tmp135;
 22:            post_incr  136  254          // tmp136 = c++;
 15:             jmp_down    0    8          // goto 23; // REWRITE
 23:           assignment  137    6  254     // tmp137 = c : TYPEOF(c);
 24:           assignment  138    1    4     // tmp138 = 4: SMALLINT;
 25:            less_than  139  137  138     // tmp139 = tmp137 < tmp138;
 26:       is_true_jmp_up  139    0   10     // if (tmp139) goto 16;
// 
//     for (var c=0; c<4; c++) s[r][c] = t[c];         // and copy back
 27:           assignment  130    1    0     // tmp130 = 0: SMALLINT;
 28:           assignment  254    6  130     // c = tmp130 : TYPEOF(tmp130);
 29:             jmp_down  253  253          // goto 65050;
 30:          prop_getter  130  254  254     // tmp130 = s[r];
 31:          prop_getter  131  130  254     // tmp131 = tmp130[c];
 31:          prop_getter  132  254  254     // tmp132 = t[c];
 32:          prop_setter  130  254  132     // tmp130[c] = tmp132;
 33:            post_incr  133  254          // tmp133 = c++;
 29:             jmp_down    0    5          // goto 34; // REWRITE
 34:           assignment  134    6  254     // tmp134 = c : TYPEOF(c);
 35:           assignment  135    1    4     // tmp135 = 4: SMALLINT;
 36:            less_than  136  134  135     // tmp136 = tmp134 < tmp135;
 37:       is_true_jmp_up  136    0    7     // if (tmp136) goto 30;
// 
//   }          // note that this will work for Nb=4,5,6, but not 7,8 (always 4 for AES):
 38:            post_incr  137  254          // tmp137 = r++;
 12:             jmp_down    0   27          // goto 39; // REWRITE
 39:           assignment  138    6  254     // tmp138 = r : TYPEOF(r);
 40:           assignment  139    1    4     // tmp139 = 4: SMALLINT;
 41:            less_than  140  138  139     // tmp140 = tmp138 < tmp139;
 42:       is_true_jmp_up  140    0   29     // if (tmp140) goto 13;
// 
//   return s;  // see fp.gladman.plus.com/cryptography_technology/rijndael/aes.spec.311.pdf 
 43:               retval  254               // return s;
// 
// }
  4:                 meta   12    6  255     // [no 'arguments'] [no 'eval']  // REWRITE
  5:         reg_var_decl  128  143    3     // var tmp128 .. tmp143; // REWRITE
 44:                  ret                    // ret;
  3:                 meta    7    0   42     // function end: 45; // REWRITE
// function MixColumns(s, Nb) {   // combine bytes of each col of state S [_5.1.3]
  0:          func_decl_n  254  253          // 
  1:                 meta    2  254  255     // 
  2:                 meta    2  254  255     // 
  0:          func_decl_n  254    2          //  // REWRITE
  3:                 meta    7  253  253     // function end: 65024;
// 
//   for (var c=0; c<4; c++) {
  4:                 meta   12  253  255     // [to be rewritten]
  5:         reg_var_decl  128  253  253     // var tmp128 .. tmp253;
  6:           assignment  130    1    0     // tmp130 = 0: SMALLINT;
  7:           assignment  254    6  130     // c = tmp130 : TYPEOF(tmp130);
  8:             jmp_down  253  253          // goto 65029;
//     var a = new Array(4);  // 'a' is a copy of the current column from 's'
  9:          construct_n  253  254  253     // 
 10:           assignment  130    1    4     // tmp130 = 4: SMALLINT;
 11:                 meta    2  130  255     // 
  9:          construct_n  130  254    1     //  // REWRITE
 12:           assignment  254    6  130     // a = tmp130 : TYPEOF(tmp130);
// 
//     var b = new Array(4);  // 'b' is a_{02} in GF(2^8)
 13:          construct_n  253  254  253     // 
 14:           assignment  130    1    4     // tmp130 = 4: SMALLINT;
 15:                 meta    2  130  255     // 
 13:          construct_n  130  254    1     //  // REWRITE
 16:           assignment  254    6  130     // b = tmp130 : TYPEOF(tmp130);
// 
//     for (var i=0; i<4; i++) {
 17:           assignment  130    1    0     // tmp130 = 0: SMALLINT;
 18:           assignment  254    6  130     // i = tmp130 : TYPEOF(tmp130);
 19:             jmp_down  253  253          // goto 65040;
//       a[i] = s[i][c];
 20:          prop_getter  130  254  254     // tmp130 = a[i];
 20:          prop_getter  131  254  254     // tmp131 = s[i];
 21:          prop_getter  132  131  254     // tmp132 = tmp131[c];
 22:          prop_setter  254  254  132     // a[i] = tmp132;
//       b[i] = s[i][c]&0x80 ? s[i][c]<<1 ^ 0x011b : s[i][c]<<1;
 23:          prop_getter  130  254  254     // tmp130 = b[i];
 23:          prop_getter  131  254  254     // tmp131 = s[i];
 24:          prop_getter  132  131  254     // tmp132 = tmp131[c];
 25:           assignment  133    1  128     // tmp133 = 128: SMALLINT;
 26:                b_and  134  132  133     // tmp134 = tmp132 & tmp133;
 27:    is_false_jmp_down  134  253  253     // if (tmp134 == false) goto 65048;
 28:          prop_getter  135  254  254     // tmp135 = s[i];
 29:          prop_getter  136  135  254     // tmp136 = tmp135[c];
 30:           assignment  137    1    1     // tmp137 = 1: SMALLINT;
 31:         b_shift_left  138  136  137     // tmp138 = tmp136 << tmp137;
 32:           assignment  139    3  254     // tmp139 = 283: NUMBER;
 33:                b_xor  140  138  139     // tmp140 = tmp138 ^ tmp139;
 34:           assignment  141    6  140     // tmp141 = tmp140 : TYPEOF(tmp140);
 35:             jmp_down  253  253          // goto 65056;
 27:    is_false_jmp_down  134    0    9     // if (tmp134 == false) goto 36; // REWRITE
 36:          prop_getter  142  254  254     // tmp142 = s[i];
 37:          prop_getter  143  142  254     // tmp143 = tmp142[c];
 38:           assignment  144    1    1     // tmp144 = 1: SMALLINT;
 39:         b_shift_left  145  143  144     // tmp145 = tmp143 << tmp144;
 40:           assignment  141    6  145     // tmp141 = tmp145 : TYPEOF(tmp145);
 35:             jmp_down    0    6          // goto 41; // REWRITE
 41:          prop_setter  254  254  141     // b[i] = tmp141;
//     }
 42:            post_incr  146  254          // tmp146 = i++;
 19:             jmp_down    0   24          // goto 43; // REWRITE
 43:           assignment  147    6  254     // tmp147 = i : TYPEOF(i);
 44:           assignment  148    1    4     // tmp148 = 4: SMALLINT;
 45:            less_than  149  147  148     // tmp149 = tmp147 < tmp148;
 46:       is_true_jmp_up  149    0   26     // if (tmp149) goto 20;
//     // a[n] ^ b[n] is a_{03} in GF(2^8)
// 
//     s[0][c] = b[0] ^ a[1] ^ b[1] ^ a[2] ^ a[3]; // 2*a0 + 3*a1 + a2 + a3
 47:           assignment  130    1    0     // tmp130 = 0: SMALLINT;
 48:          prop_getter  131  254  130     // tmp131 = s[tmp130];
 49:          prop_getter  132  131  254     // tmp132 = tmp131[c];
 49:           assignment  133    1    0     // tmp133 = 0: SMALLINT;
 50:          prop_getter  134  254  133     // tmp134 = b[tmp133];
 51:           assignment  135    1    1     // tmp135 = 1: SMALLINT;
 52:          prop_getter  136  254  135     // tmp136 = a[tmp135];
 53:                b_xor  137  134  136     // tmp137 = tmp134 ^ tmp136;
 54:           assignment  138    1    1     // tmp138 = 1: SMALLINT;
 55:          prop_getter  139  254  138     // tmp139 = b[tmp138];
 56:                b_xor  140  137  139     // tmp140 = tmp137 ^ tmp139;
 57:           assignment  141    1    2     // tmp141 = 2: SMALLINT;
 58:          prop_getter  142  254  141     // tmp142 = a[tmp141];
 59:                b_xor  143  140  142     // tmp143 = tmp140 ^ tmp142;
 60:           assignment  144    1    3     // tmp144 = 3: SMALLINT;
 61:          prop_getter  145  254  144     // tmp145 = a[tmp144];
 62:                b_xor  146  143  145     // tmp146 = tmp143 ^ tmp145;
 63:          prop_setter  131  254  146     // tmp131[c] = tmp146;
// 
//     s[1][c] = a[0] ^ b[1] ^ a[2] ^ b[2] ^ a[3]; // a0 * 2*a1 + 3*a2 + a3
 64:           assignment  130    1    1     // tmp130 = 1: SMALLINT;
 65:          prop_getter  131  254  130     // tmp131 = s[tmp130];
 66:          prop_getter  132  131  254     // tmp132 = tmp131[c];
 66:           assignment  133    1    0     // tmp133 = 0: SMALLINT;
 67:          prop_getter  134  254  133     // tmp134 = a[tmp133];
 68:           assignment  135    1    1     // tmp135 = 1: SMALLINT;
 69:          prop_getter  136  254  135     // tmp136 = b[tmp135];
 70:                b_xor  137  134  136     // tmp137 = tmp134 ^ tmp136;
 71:           assignment  138    1    2     // tmp138 = 2: SMALLINT;
 72:          prop_getter  139  254  138     // tmp139 = a[tmp138];
 73:                b_xor  140  137  139     // tmp140 = tmp137 ^ tmp139;
 74:           assignment  141    1    2     // tmp141 = 2: SMALLINT;
 75:          prop_getter  142  254  141     // tmp142 = b[tmp141];
 76:                b_xor  143  140  142     // tmp143 = tmp140 ^ tmp142;
 77:           assignment  144    1    3     // tmp144 = 3: SMALLINT;
 78:          prop_getter  145  254  144     // tmp145 = a[tmp144];
 79:                b_xor  146  143  145     // tmp146 = tmp143 ^ tmp145;
 80:          prop_setter  131  254  146     // tmp131[c] = tmp146;
// 
//     s[2][c] = a[0] ^ a[1] ^ b[2] ^ a[3] ^ b[3]; // a0 + a1 + 2*a2 + 3*a3
 81:           assignment  130    1    2     // tmp130 = 2: SMALLINT;
 82:          prop_getter  131  254  130     // tmp131 = s[tmp130];
 83:          prop_getter  132  131  254     // tmp132 = tmp131[c];
 83:           assignment  133    1    0     // tmp133 = 0: SMALLINT;
 84:          prop_getter  134  254  133     // tmp134 = a[tmp133];
 85:           assignment  135    1    1     // tmp135 = 1: SMALLINT;
 86:          prop_getter  136  254  135     // tmp136 = a[tmp135];
 87:                b_xor  137  134  136     // tmp137 = tmp134 ^ tmp136;
 88:           assignment  138    1    2     // tmp138 = 2: SMALLINT;
 89:          prop_getter  139  254  138     // tmp139 = b[tmp138];
 90:                b_xor  140  137  139     // tmp140 = tmp137 ^ tmp139;
 91:           assignment  141    1    3     // tmp141 = 3: SMALLINT;
 92:          prop_getter  142  254  141     // tmp142 = a[tmp141];
 93:                b_xor  143  140  142     // tmp143 = tmp140 ^ tmp142;
 94:           assignment  144    1    3     // tmp144 = 3: SMALLINT;
 95:          prop_getter  145  254  144     // tmp145 = b[tmp144];
 96:                b_xor  146  143  145     // tmp146 = tmp143 ^ tmp145;
 97:          prop_setter  131  254  146     // tmp131[c] = tmp146;
// 
//     s[3][c] = a[0] ^ b[0] ^ a[1] ^ a[2] ^ b[3]; // 3*a0 + a1 + a2 + 2*a3
 98:           assignment  130    1    3     // tmp130 = 3: SMALLINT;
 99:          prop_getter  131  254  130     // tmp131 = s[tmp130];
100:          prop_getter  132  131  254     // tmp132 = tmp131[c];
100:           assignment  133    1    0     // tmp133 = 0: SMALLINT;
101:          prop_getter  134  254  133     // tmp134 = a[tmp133];
102:           assignment  135    1    0     // tmp135 = 0: SMALLINT;
103:          prop_getter  136  254  135     // tmp136 = b[tmp135];
104:                b_xor  137  134  136     // tmp137 = tmp134 ^ tmp136;
105:           assignment  138    1    1     // tmp138 = 1: SMALLINT;
106:          prop_getter  139  254  138     // tmp139 = a[tmp138];
107:                b_xor  140  137  139     // tmp140 = tmp137 ^ tmp139;
108:           assignment  141    1    2     // tmp141 = 2: SMALLINT;
109:          prop_getter  142  254  141     // tmp142 = a[tmp141];
110:                b_xor  143  140  142     // tmp143 = tmp140 ^ tmp142;
111:           assignment  144    1    3     // tmp144 = 3: SMALLINT;
112:          prop_getter  145  254  144     // tmp145 = b[tmp144];
113:                b_xor  146  143  145     // tmp146 = tmp143 ^ tmp145;
114:          prop_setter  131  254  146     // tmp131[c] = tmp146;
// 
//   }
115:            post_incr  147  254          // tmp147 = c++;
  8:             jmp_down    0  108          // goto 116; // REWRITE
116:           assignment  148    6  254     // tmp148 = c : TYPEOF(c);
117:           assignment  149    1    4     // tmp149 = 4: SMALLINT;
118:            less_than  150  148  149     // tmp150 = tmp148 < tmp149;
119:       is_true_jmp_up  150    0  110     // if (tmp150) goto 9;
//   return s;
120:               retval  254               // return s;
// }
  4:                 meta   12    6  255     // [no 'arguments'] [no 'eval']  // REWRITE
  5:         reg_var_decl  128  154    4     // var tmp128 .. tmp154; // REWRITE
121:                  ret                    // ret;
  3:                 meta    7    0  119     // function end: 122; // REWRITE
// function AddRoundKey(state, w, rnd, Nb) {  // xor Round Key into state S [_5.1.4]
  0:          func_decl_n  254  253          // 
  1:                 meta    2  254  255     // 
  2:                 meta    2  254  255     // 
  3:                 meta    2  254  255     // 
  4:                 meta    2  254  255     // 
  0:          func_decl_n  254    4          //  // REWRITE
  5:                 meta    7  253  253     // function end: 65026;
// 
//   for (var r=0; r<4; r++) {
  6:                 meta   12  253  255     // [to be rewritten]
  7:         reg_var_decl  128  253  253     // var tmp128 .. tmp253;
  8:           assignment  130    1    0     // tmp130 = 0: SMALLINT;
  9:           assignment  254    6  130     // r = tmp130 : TYPEOF(tmp130);
 10:             jmp_down  253  253          // goto 65031;
//     for (var c=0; c<Nb; c++) state[r][c] ^= w[rnd*4+c][r];
 11:           assignment  130    1    0     // tmp130 = 0: SMALLINT;
 12:           assignment  254    6  130     // c = tmp130 : TYPEOF(tmp130);
 13:             jmp_down  253  253          // goto 65034;
 14:          prop_getter  130  254  254     // tmp130 = state[r];
 15:          prop_getter  131  130  254     // tmp131 = tmp130[c];
 15:           assignment  132    6  254     // tmp132 = rnd : TYPEOF(rnd);
 16:           assignment  133    1    4     // tmp133 = 4: SMALLINT;
 17:       multiplication  134  132  133     // tmp134 = tmp132 * tmp133;
 18:             addition  135  134  254     // tmp135 = tmp134 + c;
 19:          prop_getter  136  254  135     // tmp136 = w[tmp135];
 20:          prop_getter  137  136  254     // tmp137 = tmp136[r];
 21:          prop_getter  138  130  254     // tmp138 = tmp130[c];
 22:                b_xor  138  138  137     // tmp138 = tmp138 ^ tmp137;
 23:          prop_setter  130  254  138     // tmp130[c] = tmp138;
 24:            post_incr  139  254          // tmp139 = c++;
 13:             jmp_down    0   12          // goto 25; // REWRITE
 25:           assignment  140    6  254     // tmp140 = c : TYPEOF(c);
 26:            less_than  141  140  254     // tmp141 = tmp140 < Nb;
 27:       is_true_jmp_up  141    0   13     // if (tmp141) goto 14;
//   }
 28:            post_incr  142  254          // tmp142 = r++;
 10:             jmp_down    0   19          // goto 29; // REWRITE
 29:           assignment  143    6  254     // tmp143 = r : TYPEOF(r);
 30:           assignment  144    1    4     // tmp144 = 4: SMALLINT;
 31:            less_than  145  143  144     // tmp145 = tmp143 < tmp144;
 32:       is_true_jmp_up  145    0   21     // if (tmp145) goto 11;
//   return state;
 33:               retval  254               // return state;
// }
  6:                 meta   12    6  255     // [no 'arguments'] [no 'eval']  // REWRITE
  7:         reg_var_decl  128  147    2     // var tmp128 .. tmp147; // REWRITE
 34:                  ret                    // ret;
  5:                 meta    7    0   30     // function end: 35; // REWRITE
// function KeyExpansion(key) {  // generate Key Schedule (byte-array Nr+1 x Nb) from Key [_5.2]
  0:          func_decl_n  254  253          // 
  1:                 meta    2  254  255     // 
  0:          func_decl_n  254    1          //  // REWRITE
  2:                 meta    7  253  253     // function end: 65023;
// 
//   var Nb = 4;            // block size (in words): no of columns in state (fixed at 4 for AES)
  3:                 meta   12  253  255     // [to be rewritten]
  4:         reg_var_decl  128  253  253     // var tmp128 .. tmp253;
  5:           assignment  130    1    4     // tmp130 = 4: SMALLINT;
  6:           assignment  254    6  130     // Nb = tmp130 : TYPEOF(tmp130);
// 
//   var Nk = key.length/4  // key length (in words): 4/6/8 for 128/192/256-bit keys
  7:           assignment  130    5  254     // tmp130 = 'length': STRING;
  8:          prop_getter  131  254  130     // tmp131 = key[tmp130];
  9:           assignment  132    1    4     // tmp132 = 4: SMALLINT;
// 
//   var Nr = Nk + 6;       // no of rounds: 10/12/14 for 128/192/256-bit keys
 10:             division  133  131  132     // tmp133 = tmp131 / tmp132;
 11:           assignment  254    6  133     // Nk = tmp133 : TYPEOF(tmp133);
 12:           assignment  130    6  254     // tmp130 = Nk : TYPEOF(Nk);
 13:           assignment  131    1    6     // tmp131 = 6: SMALLINT;
 14:             addition  132  130  131     // tmp132 = tmp130 + tmp131;
 15:           assignment  254    6  132     // Nr = tmp132 : TYPEOF(tmp132);
// 
//   var w = new Array(Nb*(Nr+1));
 16:          construct_n  253  254  253     // 
 17:           assignment  130    6  254     // tmp130 = Nb : TYPEOF(Nb);
 18:           assignment  131    6  254     // tmp131 = Nr : TYPEOF(Nr);
 19:           assignment  132    1    1     // tmp132 = 1: SMALLINT;
 20:             addition  133  131  132     // tmp133 = tmp131 + tmp132;
 21:       multiplication  134  130  133     // tmp134 = tmp130 * tmp133;
 22:                 meta    2  134  255     // 
 16:          construct_n  130  254    1     //  // REWRITE
 23:           assignment  254    6  130     // w = tmp130 : TYPEOF(tmp130);
//   var temp = new Array(4);
 24:          construct_n  253  254  253     // 
 25:           assignment  130    1    4     // tmp130 = 4: SMALLINT;
 26:                 meta    2  130  255     // 
 24:          construct_n  130  254    1     //  // REWRITE
 27:           assignment  254    6  130     // temp = tmp130 : TYPEOF(tmp130);
//   for (var i=0; i<Nk; i++) {
 28:           assignment  130    1    0     // tmp130 = 0: SMALLINT;
 29:           assignment  254    6  130     // i = tmp130 : TYPEOF(tmp130);
 30:             jmp_down  253  253          // goto 65051;
//     var r = [key[4*i], key[4*i+1], key[4*i+2], key[4*i+3]];
 31:           array_decl  253  253  255     // 
 32:           assignment  130    1    4     // tmp130 = 4: SMALLINT;
 33:       multiplication  131  130  254     // tmp131 = tmp130 * i;
 34:          prop_getter  132  254  131     // tmp132 = key[tmp131];
 35:                 meta    2  132  255     // 
 36:           assignment  130    1    4     // tmp130 = 4: SMALLINT;
 37:       multiplication  131  130  254     // tmp131 = tmp130 * i;
 38:           assignment  132    1    1     // tmp132 = 1: SMALLINT;
 39:             addition  133  131  132     // tmp133 = tmp131 + tmp132;
 40:          prop_getter  134  254  133     // tmp134 = key[tmp133];
 41:                 meta    2  134  255     // 
 42:           assignment  130    1    4     // tmp130 = 4: SMALLINT;
 43:       multiplication  131  130  254     // tmp131 = tmp130 * i;
 44:           assignment  132    1    2     // tmp132 = 2: SMALLINT;
 45:             addition  133  131  132     // tmp133 = tmp131 + tmp132;
 46:          prop_getter  134  254  133     // tmp134 = key[tmp133];
 47:                 meta    2  134  255     // 
 48:           assignment  130    1    4     // tmp130 = 4: SMALLINT;
 49:       multiplication  131  130  254     // tmp131 = tmp130 * i;
 50:           assignment  132    1    3     // tmp132 = 3: SMALLINT;
 51:             addition  133  131  132     // tmp133 = tmp131 + tmp132;
 52:          prop_getter  134  254  133     // tmp134 = key[tmp133];
 53:                 meta    2  134  255     // 
 31:           array_decl  130    0    4     //  // REWRITE
 54:           assignment  254    6  130     // r = tmp130 : TYPEOF(tmp130);
//     w[i] = r;
 55:          prop_getter  130  254  254     // tmp130 = w[i];
 55:          prop_setter  254  254  254     // w[i] = r;
 56:           assignment  131    6  254     // tmp131 = r : TYPEOF(r);
//   }
 57:            post_incr  132  254          // tmp132 = i++;
 30:             jmp_down    0   28          // goto 58; // REWRITE
 58:           assignment  133    6  254     // tmp133 = i : TYPEOF(i);
 59:            less_than  134  133  254     // tmp134 = tmp133 < Nk;
 60:       is_true_jmp_up  134    0   29     // if (tmp134) goto 31;
//   for (var i=Nk; i<(Nb*(Nr+1)); i++) {
 61:           assignment  254    6  254     // i = Nk : TYPEOF(Nk);
 62:             jmp_down  253  253          // goto 65083;
//     w[i] = new Array(4);
 63:          prop_getter  130  254  254     // tmp130 = w[i];
 63:          construct_n  253  254  253     // 
 64:           assignment  131    1    4     // tmp131 = 4: SMALLINT;
 65:                 meta    2  131  255     // 
 63:          construct_n  131  254    1     //  // REWRITE
 66:          prop_setter  254  254  131     // w[i] = tmp131;
//     for (var t=0; t<4; t++) temp[t] = w[i-1][t];
 67:           assignment  130    1    0     // tmp130 = 0: SMALLINT;
 68:           assignment  254    6  130     // t = tmp130 : TYPEOF(tmp130);
 69:             jmp_down  253  253          // goto 65090;
 70:          prop_getter  130  254  254     // tmp130 = temp[t];
 70:           assignment  131    6  254     // tmp131 = i : TYPEOF(i);
 71:           assignment  132    1    1     // tmp132 = 1: SMALLINT;
 72:         substraction  133  131  132     // tmp133 = tmp131 - tmp132;
 73:          prop_getter  134  254  133     // tmp134 = w[tmp133];
 74:          prop_getter  135  134  254     // tmp135 = tmp134[t];
 75:          prop_setter  254  254  135     // temp[t] = tmp135;
 76:            post_incr  136  254          // tmp136 = t++;
 69:             jmp_down    0    8          // goto 77; // REWRITE
 77:           assignment  137    6  254     // tmp137 = t : TYPEOF(t);
 78:           assignment  138    1    4     // tmp138 = 4: SMALLINT;
 79:            less_than  139  137  138     // tmp139 = tmp137 < tmp138;
 80:       is_true_jmp_up  139    0   10     // if (tmp139) goto 70;
//     if (i % Nk == 0) {
 81:           assignment  130    6  254     // tmp130 = i : TYPEOF(i);
 82:            remainder  131  130  254     // tmp131 = tmp130 %% Nk;
 83:           assignment  132    1    0     // tmp132 = 0: SMALLINT;
 84:          equal_value  133  131  132     // tmp133 = tmp131 == tmp132;
 85:    is_false_jmp_down  133  253  253     // if (tmp133 == false) goto 65106;
//       temp = SubWord(RotWord(temp));
 86:               call_n  253  254  253     // 
 87:               call_n  253  254  253     // 
 88:                 meta    2  254  255     // 
 87:               call_n  130  254    1     //  // REWRITE
 89:                 meta    2  130  255     // tmp130 = ICE: Assertion 'lit_ids != NULL' failed at /home/john/git/jerry/jerry-core/vm/pretty-printer.cpp(var_to_str):102.
Error: ERR_FAILED_INTERNAL_ASSERTION
