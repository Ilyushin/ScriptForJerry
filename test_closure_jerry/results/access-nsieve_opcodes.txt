// // The Great Computer Language Shootout
// 
// // http://shootout.alioth.debian.org/
// 
// //
// 
// // modified by Isaac Gouy
// 
// function pad(number,width){
  0:                 meta   12  253  255     // [to be rewritten]
  1:         reg_var_decl  128  253  253     // var tmp128 .. tmp253;
  0:          func_decl_n  254  253          // 
  1:                 meta    2  254  255     // 
  2:                 meta    2  254  255     // 
  0:          func_decl_n  254    2          //  // REWRITE
  3:                 meta    7  253  253     // function end: 65024;
//    var s = number.toString();
  4:                 meta   12  253  255     // [to be rewritten]
  5:         reg_var_decl  128  253  253     // var tmp128 .. tmp253;
  6:           assignment  130    5  254     // tmp130 = 'toString': STRING;
  7:          prop_getter  131  254  130     // tmp131 = number[tmp130];
  8:           assignment  132    6  254     // tmp132 = number : TYPEOF(number);
  9:               call_n  253  131  253     // 
 10:                 meta    1    1  132     // 
  9:               call_n  133  131    0     //  // REWRITE
 11:           assignment  254    6  133     // s = tmp133 : TYPEOF(tmp133);
//    var prefixWidth = width - s.length;
 12:           assignment  130    6  254     // tmp130 = width : TYPEOF(width);
 13:           assignment  131    5  254     // tmp131 = 'length': STRING;
 14:          prop_getter  132  254  131     // tmp132 = s[tmp131];
 15:         substraction  133  130  132     // tmp133 = tmp130 - tmp132;
 16:           assignment  254    6  133     // prefixWidth = tmp133 : TYPEOF(tmp133);
//    if (prefixWidth>0){
 17:           assignment  130    6  254     // tmp130 = prefixWidth : TYPEOF(prefixWidth);
 18:           assignment  131    1    0     // tmp131 = 0: SMALLINT;
 19:         greater_than  132  130  131     // tmp132 = tmp130 > tmp131;
 20:    is_false_jmp_down  132  253  253     // if (tmp132 == false) goto 65041;
//       for (var i=1; i<=prefixWidth; i++) s = " " + s;
 21:           assignment  130    1    1     // tmp130 = 1: SMALLINT;
 22:           assignment  254    6  130     // i = tmp130 : TYPEOF(tmp130);
 23:             jmp_down  253  253          // goto 65044;
 24:           assignment  130    5  254     // tmp130 = ' ': STRING;
 25:             addition  131  130  254     // tmp131 = tmp130 + s;
 26:           assignment  254    6  131     // s = tmp131 : TYPEOF(tmp131);
 27:            post_incr  132  254          // tmp132 = i++;
 23:             jmp_down    0    5          // goto 28; // REWRITE
 28:           assignment  133    6  254     // tmp133 = i : TYPEOF(i);
 29:   less_or_equal_than  134  133  254     // tmp134 = tmp133 <= prefixWidth;
 30:       is_true_jmp_up  134    0    6     // if (tmp134) goto 24;
//    }
//    return s;
 20:    is_false_jmp_down  132    0   11     // if (tmp132 == false) goto 31; // REWRITE
 31:               retval  254               // return s;
// }
  4:                 meta   12    6  255     // [no 'arguments'] [no 'eval']  // REWRITE
  5:         reg_var_decl  128  137    3     // var tmp128 .. tmp137; // REWRITE
 32:                  ret                    // ret;
  3:                 meta    7    0   30     // function end: 33; // REWRITE
// function nsieve(m, isPrime){
  0:          func_decl_n  254  253          // 
  1:                 meta    2  254  255     // 
  2:                 meta    2  254  255     // 
  0:          func_decl_n  254    2          //  // REWRITE
  3:                 meta    7  253  253     // function end: 65024;
//    var i, k, count;
  4:                 meta   12  253  255     // [to be rewritten]
  5:         reg_var_decl  128  253  253     // var tmp128 .. tmp253;
//    for (i=2; i<=m; i++) { isPrime[i] = true; }
  6:           assignment  130    1    2     // tmp130 = 2: SMALLINT;
  7:           assignment  254    6  130     // i = tmp130 : TYPEOF(tmp130);
  8:             jmp_down  253  253          // goto 65029;
  9:          prop_getter  130  254  254     // tmp130 = isPrime[i];
  9:           assignment  131    0    4     // tmp131 = true: SIMPLE;
 10:          prop_setter  254  254  131     // isPrime[i] = tmp131;
 11:            post_incr  132  254          // tmp132 = i++;
  8:             jmp_down    0    4          // goto 12; // REWRITE
 12:           assignment  133    6  254     // tmp133 = i : TYPEOF(i);
 13:   less_or_equal_than  134  133  254     // tmp134 = tmp133 <= m;
 14:       is_true_jmp_up  134    0    5     // if (tmp134) goto 9;
//    count = 0;
 15:           assignment  130    1    0     // tmp130 = 0: SMALLINT;
 16:           assignment  254    6  130     // count = tmp130 : TYPEOF(tmp130);
//    for (i=2; i<=m; i++){
 17:           assignment  130    1    2     // tmp130 = 2: SMALLINT;
 18:           assignment  254    6  130     // i = tmp130 : TYPEOF(tmp130);
 19:             jmp_down  253  253          // goto 65040;
//       if (isPrime[i]) {
 20:          prop_getter  130  254  254     // tmp130 = isPrime[i];
 21:    is_false_jmp_down  130  253  253     // if (tmp130 == false) goto 65042;
//          for (k=i+i; k<=m; k+=i) isPrime[k] = false;
 22:           assignment  130    6  254     // tmp130 = i : TYPEOF(i);
 23:             addition  131  130  254     // tmp131 = tmp130 + i;
 24:           assignment  254    6  131     // k = tmp131 : TYPEOF(tmp131);
 25:             jmp_down  253  253          // goto 65046;
 26:          prop_getter  130  254  254     // tmp130 = isPrime[k];
 26:           assignment  131    0    3     // tmp131 = false: SIMPLE;
 27:          prop_setter  254  254  131     // isPrime[k] = tmp131;
 28:             addition  254  254  254     // k = k + i;
 25:             jmp_down    0    4          // goto 29; // REWRITE
 29:           assignment  132    6  254     // tmp132 = k : TYPEOF(k);
 30:   less_or_equal_than  133  132  254     // tmp133 = tmp132 <= m;
 31:       is_true_jmp_up  133    0    5     // if (tmp133) goto 26;
//          count++;
 32:            post_incr  130  254          // tmp130 = count++;
//       }
//    }
 21:    is_false_jmp_down  130    0   12     // if (tmp130 == false) goto 33; // REWRITE
 33:            post_incr  131  254          // tmp131 = i++;
 19:             jmp_down    0   15          // goto 34; // REWRITE
 34:           assignment  132    6  254     // tmp132 = i : TYPEOF(i);
 35:   less_or_equal_than  133  132  254     // tmp133 = tmp132 <= m;
 36:       is_true_jmp_up  133    0   16     // if (tmp133) goto 20;
//    return count;
 37:               retval  254               // return count;
// }
  4:                 meta   12    6  255     // [no 'arguments'] [no 'eval']  // REWRITE
  5:         reg_var_decl  128  137    3     // var tmp128 .. tmp137; // REWRITE
 38:                  ret                    // ret;
  3:                 meta    7    0   36     // function end: 39; // REWRITE
// function sieve() {
  0:          func_decl_n  254  253          // 
  0:          func_decl_n  254    0          // function sieve (); // REWRITE
  1:                 meta    7  253  253     // function end: 65022;
//     var sum = 0;
  2:                 meta   12  253  255     // [to be rewritten]
  3:         reg_var_decl  128  253  253     // var tmp128 .. tmp253;
  4:           assignment  130    1    0     // tmp130 = 0: SMALLINT;
  5:           assignment  254    6  130     // sum = tmp130 : TYPEOF(tmp130);
//     for (var i = 1; i <= 3; i++ ) {
  6:           assignment  130    1    1     // tmp130 = 1: SMALLINT;
  7:           assignment  254    6  130     // i = tmp130 : TYPEOF(tmp130);
  8:             jmp_down  253  253          // goto 65029;
//         var m = (1<<i)*10000;
  9:           assignment  130    1    1     // tmp130 = 1: SMALLINT;
 10:         b_shift_left  131  130  254     // tmp131 = tmp130 << i;
 11:           assignment  132    3  254     // tmp132 = 10000: NUMBER;
 12:       multiplication  133  131  132     // tmp133 = tmp131 * tmp132;
 13:           assignment  254    6  133     // m = tmp133 : TYPEOF(tmp133);
//         var flags = Array(m+1);
 14:               call_n  253  254  253     // 
 15:           assignment  130    6  254     // tmp130 = m : TYPEOF(m);
 16:           assignment  131    1    1     // tmp131 = 1: SMALLINT;
 17:             addition  132  130  131     // tmp132 = tmp130 + tmp131;
 18:                 meta    2  132  255     // 
 14:               call_n  130  254    1     //  // REWRITE
 19:           assignment  254    6  130     // flags = tmp130 : TYPEOF(tmp130);
//         sum += nsieve(m, flags);
 20:               call_n  253  254  253     // 
 21:                 meta    2  254  255     // 
 22:                 meta    2  254  255     // 
 20:               call_n  130  254    2     //  // REWRITE
 23:             addition  254  254  130     // sum = sum + tmp130;
 24:           assignment  131    6  254     // tmp131 = sum : TYPEOF(sum);
//     }
 25:            post_incr  132  254          // tmp132 = i++;
  8:             jmp_down    0   18          // goto 26; // REWRITE
 26:           assignment  133    6  254     // tmp133 = i : TYPEOF(i);
 27:           assignment  134    1    3     // tmp134 = 3: SMALLINT;
 28:   less_or_equal_than  135  133  134     // tmp135 = tmp133 <= tmp134;
 29:       is_true_jmp_up  135    0   20     // if (tmp135) goto 9;
//     return sum;
 30:               retval  254               // return sum;
// }
  2:                 meta   12    6  255     // [no 'arguments'] [no 'eval']  // REWRITE
  3:         reg_var_decl  128  139    4     // var tmp128 .. tmp139; // REWRITE
 31:                  ret                    // ret;
  1:                 meta    7    0   31     // function end: 32; // REWRITE
// var result = sieve();
  2:               call_n  253  254  253     // 
  2:               call_n  130  254    0     //  // REWRITE
  3:           assignment  254    6  130     // result = tmp130 : TYPEOF(tmp130);
// var expected = 14302;
  4:           assignment  130    3  254     // tmp130 = 14302: NUMBER;
  5:           assignment  254    6  130     // expected = tmp130 : TYPEOF(tmp130);
// if (result != expected)
  6:           assignment  130    6  254     // tmp130 = result : TYPEOF(result);
  7:      not_equal_value  131  130  254     // tmp131 = tmp130 != expected;
  8:    is_false_jmp_down  131  253  253     // if (tmp131 == false) goto 65029;
//     throw "ERROR: bad result: expected " + expected + " but got " + result;
  9:           assignment  130    5  254     // tmp130 = 'ERROR: bad result: expected ': STRING;
 10:             addition  131  130  254     // tmp131 = tmp130 + expected;
 11:           assignment  132    5  254     // tmp132 = ' but got ': STRING;
 12:             addition  133  131  132     // tmp133 = tmp131 + tmp132;
 13:             addition  134  133  254     // tmp134 = tmp133 + result;
 14:          throw_value  134               // throw tmp134;
// 
  8:    is_false_jmp_down  131    0    7     // if (tmp131 == false) goto 15; // REWRITE
  0:                 meta   12    6  255     // [no 'arguments'] [no 'eval']  // REWRITE
  1:         reg_var_decl  128  134    0     // var tmp128 .. tmp134; // REWRITE
 15:                  ret                    // ret;
LITERALS:
0x8a54c4 [ 12] pad : STRING
0x8a54d0 [  4] number : MAGIC STRING [id=11] 
0x8a54d4 [ 12] width : STRING
0x8a54e0 [  8] s : STRING
0x8a54e8 [  4] toString : MAGIC STRING [id=104] 
0x8a54ec [ 20] prefixWidth : STRING
0x8a5504 [  4] length : MAGIC STRING [id=15] 
0x8a5508 [  4] i : MAGIC STRING [id=207] 
0x8a550c [  4]   : MAGIC STRING [id=224] 
0x8a5510 [ 12] nsieve : STRING
0x8a551c [  4] m : MAGIC STRING [id=208] 
0x8a5520 [ 16] isPrime : STRING
0x8a5530 [  8] k : STRING
0x8a5538 [ 12] count : STRING
0x8a5548 [ 12] sieve : STRING
0x8a5554 [ 12] sum : STRING
0x8a5560 [ 12] 10000 : NUMBER
0x8a556c [ 12] flags : STRING
0x8a5578 [  4] Array : MAGIC STRING [id=29] 
0x8a557c [ 12] result : STRING
0x8a558c [ 16] expected : STRING
0x8a559c [ 12] 14302 : NUMBER
0x8a55a8 [ 36] ERROR: bad result: expected  : STRING
0x8a55d0 [ 16]  but got  : STRING
0x8a55e0 [ 32]  : EMPTY RECORD
  0:                 meta   12    6  255     // [no 'arguments'] [no 'eval'] 
  1:         reg_var_decl  128  134    0     // var tmp128 .. tmp134;
  2:             var_decl    0               // var result;
  3:             var_decl    1               // var expected;
  4:          func_decl_n    2    2          // 
  5:                 meta    2    3  255     // 
  6:                 meta    2    4  255     // function pad (number, width);
  7:                 meta    7    0   30     // function end: 37;
  8:                 meta   12    6  255     // [no 'arguments'] [no 'eval'] 
  9:         reg_var_decl  128  137    3     // var tmp128 .. tmp137;
 10:           assignment  130    5    5     // tmp130 = 'toString': STRING;
 11:          prop_getter  131    3  130     // tmp131 = number[tmp130];
 12:           assignment  132    6    3     // tmp132 = number : TYPEOF(number);
 13:               call_n  133  131    0     // 
 14:                 meta    1    1  132     // tmp133 = tmp131 (this_arg = tmp132);
 15:           assignment  135    6  133     // tmp135 = tmp133 : TYPEOF(tmp133);
 16:           assignment  130    6    4     // tmp130 = width : TYPEOF(width);
 17:           assignment  131    5    6     // tmp131 = 'length': STRING;
 18:          prop_getter  132  135  131     // tmp132 = tmp135[tmp131];
 19:         substraction  133  130  132     // tmp133 = tmp130 - tmp132;
 20:           assignment  136    6  133     // tmp136 = tmp133 : TYPEOF(tmp133);
 21:           assignment  130    6  136     // tmp130 = tmp136 : TYPEOF(tmp136);
 22:           assignment  131    1    0     // tmp131 = 0: SMALLINT;
 23:         greater_than  132  130  131     // tmp132 = tmp130 > tmp131;
 24:    is_false_jmp_down  132    0   11     // if (tmp132 == false) goto 35;
 25:           assignment  130    1    1     // tmp130 = 1: SMALLINT;
 26:           assignment  137    6  130     // tmp137 = tmp130 : TYPEOF(tmp130);
 27:             jmp_down    0    5          // goto 32;
 28:           assignment  130    5    7     // tmp130 = ' ': STRING;
 29:             addition  131  130  135     // tmp131 = tmp130 + tmp135;
 30:           assignment  135    6  131     // tmp135 = tmp131 : TYPEOF(tmp131);
 31:            post_incr  132  137          // tmp132 = tmp137++;
 32:           assignment  133    6  137     // tmp133 = tmp137 : TYPEOF(tmp137);
 33:   less_or_equal_than  134  133  136     // tmp134 = tmp133 <= tmp136;
 34:       is_true_jmp_up  134    0    6     // if (tmp134) goto 28;
 35:               retval  135               // return tmp135;
 36:                  ret                    // ret;
 37:          func_decl_n    8    2          // 
 38:                 meta    2    9  255     // 
 39:                 meta    2   10  255     // function nsieve (m, isPrime);
 40:                 meta    7    0   36     // function end: 76;
 41:                 meta   12    6  255     // [no 'arguments'] [no 'eval'] 
 42:         reg_var_decl  128  137    3     // var tmp128 .. tmp137;
 43:           assignment  130    1    2     // tmp130 = 2: SMALLINT;
 44:           assignment  135    6  130     // tmp135 = tmp130 : TYPEOF(tmp130);
 45:             jmp_down    0    4          // goto 49;
 46:           assignment  131    0    4     // tmp131 = true: SIMPLE;
 47:          prop_setter   10  135  131     // isPrime[tmp135] = tmp131;
 48:            post_incr  132  135          // tmp132 = tmp135++;
 49:           assignment  133    6  135     // tmp133 = tmp135 : TYPEOF(tmp135);
 50:   less_or_equal_than  134  133    9     // tmp134 = tmp133 <= m;
 51:       is_true_jmp_up  134    0    5     // if (tmp134) goto 46;
 52:           assignment  130    1    0     // tmp130 = 0: SMALLINT;
 53:           assignment  137    6  130     // tmp137 = tmp130 : TYPEOF(tmp130);
 54:           assignment  130    1    2     // tmp130 = 2: SMALLINT;
 55:           assignment  135    6  130     // tmp135 = tmp130 : TYPEOF(tmp130);
 56:             jmp_down    0   15          // goto 71;
 57:          prop_getter  130   10  135     // tmp130 = isPrime[tmp135];
 58:    is_false_jmp_down  130    0   12     // if (tmp130 == false) goto 70;
 59:           assignment  130    6  135     // tmp130 = tmp135 : TYPEOF(tmp135);
 60:             addition  131  130  135     // tmp131 = tmp130 + tmp135;
 61:           assignment  136    6  131     // tmp136 = tmp131 : TYPEOF(tmp131);
 62:             jmp_down    0    4          // goto 66;
 63:           assignment  131    0    3     // tmp131 = false: SIMPLE;
 64:          prop_setter    0  136  131     // isPrime[tmp136] = tmp131;
 65:             addition  136  136  135     // tmp136 = tmp136 + tmp135;
 66:           assignment  132    6  136     // tmp132 = tmp136 : TYPEOF(tmp136);
 67:   less_or_equal_than  133  132    1     // tmp133 = tmp132 <= m;
 68:       is_true_jmp_up  133    0    5     // if (tmp133) goto 63;
 69:            post_incr  130  137          // tmp130 = tmp137++;
 70:            post_incr  131  135          // tmp131 = tmp135++;
 71:           assignment  132    6  135     // tmp132 = tmp135 : TYPEOF(tmp135);
 72:   less_or_equal_than  133  132    1     // tmp133 = tmp132 <= m;
 73:       is_true_jmp_up  133    0   16     // if (tmp133) goto 57;
 74:               retval  137               // return tmp137;
 75:                  ret                    // ret;
 76:          func_decl_n    2    0          // function sieve ();
 77:                 meta    7    0   31     // function end: 108;
 78:                 meta   12    6  255     // [no 'arguments'] [no 'eval'] 
 79:         reg_var_decl  128  139    4     // var tmp128 .. tmp139;
 80:           assignment  130    1    0     // tmp130 = 0: SMALLINT;
 81:           assignment  136    6  130     // tmp136 = tmp130 : TYPEOF(tmp130);
 82:           assignment  130    1    1     // tmp130 = 1: SMALLINT;
 83:           assignment  137    6  130     // tmp137 = tmp130 : TYPEOF(tmp130);
 84:             jmp_down    0   18          // goto 102;
 85:           assignment  130    1    1     // tmp130 = 1: SMALLINT;
 86:         b_shift_left  131  130  137     // tmp131 = tmp130 << tmp137;
 87:           assignment  132    3    3     // tmp132 = 10000: NUMBER;
 88:       multiplication  133  131  132     // tmp133 = tmp131 * tmp132;
 89:           assignment  138    6  133     // tmp138 = tmp133 : TYPEOF(tmp133);
 90:               call_n  130    4    1     // 
 91:           assignment  130    6  138     // tmp130 = tmp138 : TYPEOF(tmp138);
 92:           assignment  131    1    1     // tmp131 = 1: SMALLINT;
 93:             addition  132  130  131     // tmp132 = tmp130 + tmp131;
 94:                 meta    2  132  255     // tmp130 = Array (tmp132);
 95:           assignment  139    6  130     // tmp139 = tmp130 : TYPEOF(tmp130);
 96:               call_n  130    5    2     // 
 97:                 meta    2  138  255     // 
 98:                 meta    2  139  255     // tmp130 = nsieve (tmp138, tmp139);
 99:             addition  136  136  130     // tmp136 = tmp136 + tmp130;
100:           assignment  131    6  136     // tmp131 = tmp136 : TYPEOF(tmp136);
101:            post_incr  132  137          // tmp132 = tmp137++;
102:           assignment  133    6  137     // tmp133 = tmp137 : TYPEOF(tmp137);
103:           assignment  134    1    3     // tmp134 = 3: SMALLINT;
104:   less_or_equal_than  135  133  134     // tmp135 = tmp133 <= tmp134;
105:       is_true_jmp_up  135    0   20     // if (tmp135) goto 85;
106:               retval  136               // return tmp136;
107:                  ret                    // ret;
108:               call_n  130    2    0     // 
109:           assignment    6    6  130     // result = tmp130 : TYPEOF(tmp130);
110:           assignment  130    3    7     // tmp130 = 14302: NUMBER;
111:           assignment    8    6  130     // expected = tmp130 : TYPEOF(tmp130);
112:           assignment  130    6    6     // tmp130 = result : TYPEOF(result);
113:      not_equal_value  131  130    8     // tmp131 = tmp130 != expected;
114:    is_false_jmp_down  131    0    7     // if (tmp131 == false) goto 121;
115:           assignment  130    5    9     // tmp130 = 'ERROR: bad result: expected ': STRING;
116:             addition  131  130    8     // tmp131 = tmp130 + expected;
117:           assignment  132    5   10     // tmp132 = ' but got ': STRING;
118:             addition  133  131  132     // tmp133 = tmp131 + tmp132;
119:             addition  134  133    6     // tmp134 = tmp133 + result;
120:          throw_value  134               // throw tmp134;
121:                  ret                    // ret;
Error: ERR_OUT_OF_MEMORY
